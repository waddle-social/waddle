# Issue #29: Background Service

## User Story
As an **Android user**, I want the **app to maintain connections and sync data in the background** so that **I receive real-time updates and can quickly access fresh content when I open the app**.

## Description
Implement background services for maintaining WebSocket connections, syncing messages, and handling background tasks using Android's WorkManager and foreground services. This includes battery optimization, doze mode handling, and efficient resource management.

## Acceptance Criteria
- [ ] WebSocket connection persistence
- [ ] Background message synchronization
- [ ] Offline message queue
- [ ] Battery-efficient scheduling
- [ ] Doze mode compatibility
- [ ] Background restrictions compliance
- [ ] Connection state recovery
- [ ] Data usage optimization

## Technical Implementation

### 1. Background Service Architecture
```kotlin
// Main Background Service
@AndroidEntryPoint
class WaddleBackgroundService : LifecycleService() {
    @Inject lateinit var webSocketManager: WebSocketManager
    @Inject lateinit var syncManager: SyncManager
    @Inject lateinit var connectivityManager: ConnectivityObserver
    @Inject lateinit var notificationHelper: NotificationHelper
    @Inject lateinit var powerManager: PowerOptimizationManager
    
    private val binder = LocalBinder()
    private var wakeLock: PowerManager.WakeLock? = null
    
    inner class LocalBinder : Binder() {
        fun getService(): WaddleBackgroundService = this@WaddleBackgroundService
    }
    
    override fun onCreate() {
        super.onCreate()
        
        // Start as foreground service
        startForeground(FOREGROUND_ID, notificationHelper.createPersistentNotification())
        
        // Acquire partial wake lock for network operations
        acquireWakeLock()
        
        // Initialize components
        initializeService()
        
        // Observe lifecycle
        lifecycle.addObserver(serviceLifecycleObserver)
    }
    
    private fun initializeService() {
        // Start connectivity monitoring
        lifecycleScope.launch {
            connectivityManager.observe().collect { status ->
                handleConnectivityChange(status)
            }
        }
        
        // Initialize WebSocket connection
        lifecycleScope.launch {
            webSocketManager.connect()
        }
        
        // Start sync manager
        syncManager.startPeriodicSync()
    }
    
    private fun acquireWakeLock() {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "Waddle::BackgroundService"
        ).apply {
            setReferenceCounted(false)
            acquire(10 * 60 * 1000L) // 10 minutes max
        }
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        super.onStartCommand(intent, flags, startId)
        
        intent?.action?.let { action ->
            when (action) {
                ACTION_SYNC_NOW -> performImmediateSync()
                ACTION_SEND_PENDING -> sendPendingMessages()
                ACTION_RECONNECT -> reconnectWebSocket()
                ACTION_STOP_SERVICE -> stopService()
            }
        }
        
        return START_STICKY
    }
    
    private fun handleConnectivityChange(status: ConnectivityStatus) {
        when (status) {
            ConnectivityStatus.Available -> {
                // Resume operations
                webSocketManager.reconnect()
                syncManager.resumeSync()
                sendPendingMessages()
            }
            ConnectivityStatus.Losing -> {
                // Prepare for disconnection
                syncManager.pauseSync()
            }
            ConnectivityStatus.Lost -> {
                // Handle offline mode
                webSocketManager.disconnect()
                updateNotification(ConnectionState.OFFLINE)
            }
        }
    }
    
    private fun performImmediateSync() {
        lifecycleScope.launch {
            try {
                syncManager.syncAll()
                updateNotification(ConnectionState.SYNCED)
            } catch (e: Exception) {
                Log.e(TAG, "Sync failed", e)
                scheduleRetry()
            }
        }
    }
    
    private fun stopService() {
        // Clean up
        webSocketManager.disconnect()
        syncManager.stopSync()
        wakeLock?.release()
        stopForeground(true)
        stopSelf()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        lifecycle.removeObserver(serviceLifecycleObserver)
        wakeLock?.release()
    }
    
    companion object {
        const val ACTION_SYNC_NOW = "com.waddle.android.SYNC_NOW"
        const val ACTION_SEND_PENDING = "com.waddle.android.SEND_PENDING"
        const val ACTION_RECONNECT = "com.waddle.android.RECONNECT"
        const val ACTION_STOP_SERVICE = "com.waddle.android.STOP_SERVICE"
        
        private const val FOREGROUND_ID = 1001
        private const val TAG = "WaddleBackgroundService"
    }
}

// Service Lifecycle Observer
class ServiceLifecycleObserver @Inject constructor(
    private val syncManager: SyncManager,
    private val webSocketManager: WebSocketManager
) : DefaultLifecycleObserver {
    
    override fun onStart(owner: LifecycleOwner) {
        super.onStart(owner)
        // Service is visible, increase sync frequency
        syncManager.setSyncInterval(SyncInterval.ACTIVE)
    }
    
    override fun onStop(owner: LifecycleOwner) {
        super.onStop(owner)
        // Service is in background, reduce sync frequency
        syncManager.setSyncInterval(SyncInterval.BACKGROUND)
    }
}
```

### 2. WebSocket Management
```kotlin
// WebSocket Manager for persistent connection
@Singleton
class WebSocketManager @Inject constructor(
    private val authRepository: AuthRepository,
    private val messageHandler: MessageHandler,
    @ApplicationScope private val scope: CoroutineScope
) {
    private var webSocket: WebSocket? = null
    private var reconnectJob: Job? = null
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState = _connectionState.asStateFlow()
    
    private val reconnectStrategy = ExponentialBackoff(
        initialDelay = 1000L,
        maxDelay = 30000L,
        factor = 2.0
    )
    
    suspend fun connect() {
        if (webSocket?.isOpen == true) return
        
        _connectionState.value = ConnectionState.CONNECTING
        
        try {
            val token = authRepository.getAccessToken() ?: throw AuthException("No token")
            val request = Request.Builder()
                .url(BuildConfig.WEBSOCKET_URL)
                .addHeader("Authorization", "Bearer $token")
                .build()
                
            webSocket = OkHttpClient.Builder()
                .pingInterval(30, TimeUnit.SECONDS)
                .build()
                .newWebSocket(request, webSocketListener)
                
        } catch (e: Exception) {
            Log.e(TAG, "WebSocket connection failed", e)
            _connectionState.value = ConnectionState.ERROR
            scheduleReconnect()
        }
    }
    
    private val webSocketListener = object : WebSocketListener() {
        override fun onOpen(webSocket: WebSocket, response: Response) {
            Log.d(TAG, "WebSocket connected")
            _connectionState.value = ConnectionState.CONNECTED
            reconnectStrategy.reset()
            
            // Send heartbeat
            startHeartbeat()
            
            // Request missed messages
            requestMissedMessages()
        }
        
        override fun onMessage(webSocket: WebSocket, text: String) {
            scope.launch {
                try {
                    val message = parseMessage(text)
                    messageHandler.handleMessage(message)
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to handle message", e)
                }
            }
        }
        
        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
            Log.e(TAG, "WebSocket failure", t)
            _connectionState.value = ConnectionState.ERROR
            scheduleReconnect()
        }
        
        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
            Log.d(TAG, "WebSocket closed: $reason")
            _connectionState.value = ConnectionState.DISCONNECTED
            
            if (code != CLOSE_NORMAL) {
                scheduleReconnect()
            }
        }
    }
    
    private fun scheduleReconnect() {
        reconnectJob?.cancel()
        reconnectJob = scope.launch {
            val delay = reconnectStrategy.nextDelay()
            Log.d(TAG, "Reconnecting in ${delay}ms")
            delay(delay)
            
            if (isActive) {
                connect()
            }
        }
    }
    
    private fun startHeartbeat() {
        scope.launch {
            while (isActive && webSocket?.isOpen == true) {
                delay(30000) // 30 seconds
                webSocket?.send("""{"type":"heartbeat"}""")
            }
        }
    }
    
    fun disconnect() {
        reconnectJob?.cancel()
        webSocket?.close(CLOSE_NORMAL, "Service stopping")
        webSocket = null
        _connectionState.value = ConnectionState.DISCONNECTED
    }
    
    fun sendMessage(message: OutgoingMessage) {
        if (webSocket?.isOpen == true) {
            webSocket?.send(message.toJson())
        } else {
            // Queue for later
            scope.launch {
                messageQueue.add(message)
            }
        }
    }
    
    companion object {
        private const val TAG = "WebSocketManager"
        private const val CLOSE_NORMAL = 1000
    }
}
```

### 3. Sync Manager
```kotlin
// Sync Manager for background data synchronization
@Singleton
class SyncManager @Inject constructor(
    private val waddleRepository: WaddleRepository,
    private val messageRepository: MessageRepository,
    private val userRepository: UserRepository,
    private val workManager: WorkManager,
    private val syncStateStore: SyncStateStore
) {
    private var currentSyncInterval = SyncInterval.BACKGROUND
    
    fun startPeriodicSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
            
        val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            currentSyncInterval.minutes,
            TimeUnit.MINUTES
        )
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .addTag(TAG_SYNC)
            .build()
            
        workManager.enqueueUniquePeriodicWork(
            SYNC_WORK_NAME,
            ExistingPeriodicWorkPolicy.REPLACE,
            syncRequest
        )
    }
    
    suspend fun syncAll(): SyncResult {
        val results = mutableListOf<SyncResult>()
        
        // Sync in priority order
        results.add(syncMessages())
        results.add(syncWaddles())
        results.add(syncUsers())
        
        // Update last sync time
        syncStateStore.setLastSyncTime(System.currentTimeMillis())
        
        return SyncResult(
            success = results.all { it.success },
            itemsSynced = results.sumOf { it.itemsSynced },
            errors = results.flatMap { it.errors }
        )
    }
    
    private suspend fun syncMessages(): SyncResult {
        return try {
            val lastSync = syncStateStore.getLastMessageSync()
            val waddles = waddleRepository.getJoinedWaddles()
            var totalSynced = 0
            
            waddles.forEach { waddle ->
                val messages = messageRepository.getMessagesSince(
                    waddleId = waddle.id,
                    since = lastSync
                )
                totalSynced += messages.size
                
                // Store messages locally
                messageRepository.cacheMessages(messages)
            }
            
            syncStateStore.setLastMessageSync(System.currentTimeMillis())
            
            SyncResult(
                success = true,
                itemsSynced = totalSynced
            )
        } catch (e: Exception) {
            Log.e(TAG, "Message sync failed", e)
            SyncResult(
                success = false,
                errors = listOf(e.message ?: "Unknown error")
            )
        }
    }
    
    fun setSyncInterval(interval: SyncInterval) {
        if (currentSyncInterval != interval) {
            currentSyncInterval = interval
            startPeriodicSync() // Restart with new interval
        }
    }
    
    companion object {
        private const val TAG = "SyncManager"
        private const val SYNC_WORK_NAME = "waddle_sync"
        private const val TAG_SYNC = "sync"
    }
}

// Sync Worker
class SyncWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted params: WorkerParameters,
    private val syncManager: SyncManager
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            val syncResult = syncManager.syncAll()
            
            if (syncResult.success) {
                Result.success(
                    workDataOf("items_synced" to syncResult.itemsSynced)
                )
            } else {
                if (runAttemptCount < 3) {
                    Result.retry()
                } else {
                    Result.failure(
                        workDataOf("errors" to syncResult.errors.toTypedArray())
                    )
                }
            }
        } catch (e: Exception) {
            Log.e("SyncWorker", "Sync failed", e)
            Result.failure()
        }
    }
    
    @AssistedFactory
    interface Factory : ChildWorkerFactory
}
```

### 4. Battery Optimization
```kotlin
// Power Optimization Manager
@Singleton
class PowerOptimizationManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val settingsRepository: SettingsRepository
) {
    private val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
    
    fun checkBatteryOptimizations(): BatteryOptimizationStatus {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            when {
                powerManager.isIgnoringBatteryOptimizations(context.packageName) -> {
                    BatteryOptimizationStatus.DISABLED
                }
                powerManager.isPowerSaveMode -> {
                    BatteryOptimizationStatus.POWER_SAVE_MODE
                }
                else -> {
                    BatteryOptimizationStatus.ENABLED
                }
            }
        } else {
            BatteryOptimizationStatus.NOT_APPLICABLE
        }
    }
    
    fun requestDisableBatteryOptimization() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
                data = Uri.parse("package:${context.packageName}")
            }
            context.startActivity(intent)
        }
    }
    
    suspend fun optimizeForBattery() {
        val batteryLevel = getBatteryLevel()
        val isCharging = isCharging()
        
        when {
            batteryLevel < 15 && !isCharging -> {
                // Critical battery - minimize background activity
                applyPowerProfile(PowerProfile.CRITICAL)
            }
            batteryLevel < 30 && !isCharging -> {
                // Low battery - reduce sync frequency
                applyPowerProfile(PowerProfile.LOW_BATTERY)
            }
            isCharging -> {
                // Charging - maximize performance
                applyPowerProfile(PowerProfile.CHARGING)
            }
            else -> {
                // Normal operation
                applyPowerProfile(PowerProfile.NORMAL)
            }
        }
    }
    
    private suspend fun applyPowerProfile(profile: PowerProfile) {
        settingsRepository.setPowerProfile(profile)
        
        // Notify components to adjust behavior
        PowerProfileManager.notifyProfileChange(profile)
    }
    
    private fun getBatteryLevel(): Int {
        val batteryStatus = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter ->
            context.registerReceiver(null, filter)
        }
        
        val level = batteryStatus?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale = batteryStatus?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        
        return if (level >= 0 && scale > 0) {
            (level * 100 / scale)
        } else {
            100
        }
    }
    
    private fun isCharging(): Boolean {
        val batteryStatus = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter ->
            context.registerReceiver(null, filter)
        }
        
        val status = batteryStatus?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1
        return status == BatteryManager.BATTERY_STATUS_CHARGING ||
               status == BatteryManager.BATTERY_STATUS_FULL
    }
}

enum class PowerProfile {
    CRITICAL,    // Minimal background activity
    LOW_BATTERY, // Reduced sync frequency
    NORMAL,      // Standard operation
    CHARGING     // Maximum performance
}
```

### 5. Offline Message Queue
```kotlin
// Offline Message Queue Manager
@Singleton
class OfflineMessageQueue @Inject constructor(
    private val database: WaddleDatabase,
    private val messageApi: MessageApi,
    @ApplicationScope private val scope: CoroutineScope
) {
    private val pendingMessages = mutableListOf<PendingMessage>()
    private var sendingJob: Job? = null
    
    suspend fun queueMessage(
        channelId: String,
        content: String,
        attachments: List<Uri> = emptyList()
    ): String {
        val tempId = UUID.randomUUID().toString()
        
        val pendingMessage = PendingMessage(
            id = tempId,
            channelId = channelId,
            content = content,
            attachments = attachments,
            createdAt = System.currentTimeMillis(),
            retryCount = 0,
            status = MessageStatus.PENDING
        )
        
        // Store in database
        database.pendingMessageDao().insert(pendingMessage)
        pendingMessages.add(pendingMessage)
        
        // Try to send immediately if online
        sendPendingMessages()
        
        return tempId
    }
    
    fun sendPendingMessages() {
        if (sendingJob?.isActive == true) return
        
        sendingJob = scope.launch {
            val messages = database.pendingMessageDao().getPendingMessages()
            
            messages.forEach { message ->
                try {
                    // Update status to sending
                    updateMessageStatus(message.id, MessageStatus.SENDING)
                    
                    // Upload attachments first
                    val attachmentUrls = uploadAttachments(message.attachments)
                    
                    // Send message
                    val sentMessage = messageApi.sendMessage(
                        channelId = message.channelId,
                        content = message.content,
                        attachments = attachmentUrls
                    )
                    
                    // Success - remove from queue
                    database.pendingMessageDao().delete(message.id)
                    
                    // Notify UI
                    MessageEvents.emit(
                        MessageSent(
                            tempId = message.id,
                            actualId = sentMessage.id
                        )
                    )
                    
                } catch (e: Exception) {
                    handleSendFailure(message, e)
                }
            }
        }
    }
    
    private suspend fun handleSendFailure(message: PendingMessage, error: Exception) {
        val newRetryCount = message.retryCount + 1
        
        if (newRetryCount >= MAX_RETRIES) {
            // Mark as failed
            updateMessageStatus(message.id, MessageStatus.FAILED)
            MessageEvents.emit(
                MessageFailed(
                    tempId = message.id,
                    error = error.message ?: "Unknown error"
                )
            )
        } else {
            // Update retry count and schedule retry
            database.pendingMessageDao().updateRetryCount(message.id, newRetryCount)
            
            val backoffDelay = calculateBackoffDelay(newRetryCount)
            delay(backoffDelay)
            
            // Retry
            sendPendingMessages()
        }
    }
    
    private fun calculateBackoffDelay(retryCount: Int): Long {
        return min(
            INITIAL_BACKOFF_MS * (1 shl (retryCount - 1)),
            MAX_BACKOFF_MS
        )
    }
    
    companion object {
        private const val MAX_RETRIES = 3
        private const val INITIAL_BACKOFF_MS = 1000L
        private const val MAX_BACKOFF_MS = 30000L
    }
}
```

### 6. Service Management UI
```kotlin
@Composable
fun BackgroundServiceSettings(
    viewModel: ServiceSettingsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    LazyColumn {
        item {
            ServiceStatusCard(
                connectionState = uiState.connectionState,
                syncState = uiState.syncState,
                batteryOptimization = uiState.batteryOptimization
            )
        }
        
        item {
            SettingsSection(title = "Background Activity") {
                SwitchPreference(
                    title = "Keep Connection Active",
                    summary = "Maintain connection for real-time updates",
                    checked = uiState.keepConnectionActive,
                    onCheckedChange = viewModel::setKeepConnectionActive
                )
                
                SwitchPreference(
                    title = "Background Sync",
                    summary = "Sync messages when app is closed",
                    checked = uiState.backgroundSyncEnabled,
                    onCheckedChange = viewModel::setBackgroundSync
                )
                
                ListPreference(
                    title = "Sync Frequency",
                    summary = uiState.syncInterval.displayName,
                    value = uiState.syncInterval,
                    onValueChange = viewModel::setSyncInterval,
                    entries = SyncInterval.values().toList(),
                    enabled = uiState.backgroundSyncEnabled
                )
            }
        }
        
        item {
            SettingsSection(title = "Battery Optimization") {
                if (uiState.batteryOptimization == BatteryOptimizationStatus.ENABLED) {
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.errorContainer
                        )
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Text(
                                text = "Battery optimization is enabled",
                                style = MaterialTheme.typography.titleMedium
                            )
                            Text(
                                text = "This may delay notifications and messages",
                                style = MaterialTheme.typography.bodyMedium
                            )
                            Spacer(modifier = Modifier.height(8.dp))
                            Button(
                                onClick = viewModel::requestDisableBatteryOptimization
                            ) {
                                Text("Disable Optimization")
                            }
                        }
                    }
                }
                
                SwitchPreference(
                    title = "Adaptive Battery Mode",
                    summary = "Adjust sync based on battery level",
                    checked = uiState.adaptiveBatteryEnabled,
                    onCheckedChange = viewModel::setAdaptiveBattery
                )
                
                SwitchPreference(
                    title = "Low Power Mode",
                    summary = "Reduce background activity when battery is low",
                    checked = uiState.lowPowerModeEnabled,
                    onCheckedChange = viewModel::setLowPowerMode
                )
            }
        }
        
        item {
            SettingsSection(title = "Data Usage") {
                DataUsageCard(
                    wifiUsage = uiState.wifiDataUsage,
                    mobileUsage = uiState.mobileDataUsage,
                    period = uiState.dataUsagePeriod
                )
                
                SwitchPreference(
                    title = "Sync on Wi-Fi Only",
                    summary = "Only sync when connected to Wi-Fi",
                    checked = uiState.wifiOnlySync,
                    onCheckedChange = viewModel::setWifiOnlySync
                )
                
                SwitchPreference(
                    title = "Reduce Data Usage",
                    summary = "Compress images and limit media downloads",
                    checked = uiState.reduceDataUsage,
                    onCheckedChange = viewModel::setReduceDataUsage
                )
            }
        }
    }
}

@Composable
fun ServiceStatusCard(
    connectionState: ConnectionState,
    syncState: SyncState,
    batteryOptimization: BatteryOptimizationStatus
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = "Service Status",
                style = MaterialTheme.typography.titleMedium
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Connection")
                ConnectionStateChip(state = connectionState)
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Last Sync")
                Text(
                    text = formatRelativeTime(syncState.lastSyncTime),
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Pending Messages")
                Badge {
                    Text(syncState.pendingMessages.toString())
                }
            }
        }
    }
}
```

## Dependencies
- Android WorkManager
- Android Foreground Service
- WebSocket (OkHttp)
- Room Database
- Power Manager API

## Estimated Effort
**5 days**
- 1 day: Background service architecture
- 1 day: WebSocket persistence and reconnection
- 1 day: Sync manager and WorkManager
- 1 day: Battery optimization and doze handling
- 1 day: Offline queue and UI integration

## Notes
- Test on various Android versions
- Handle Android 12+ foreground service restrictions
- Implement proper service lifecycle
- Monitor battery impact
- Consider JobScheduler for older devices