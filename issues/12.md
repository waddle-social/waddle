# Issue #12: Reactions & Message Editing

## User Story
As a **user**, I want to **react to messages with emojis and edit my messages** so that **I can express emotions quickly and fix mistakes**.

## Description
Implement message reactions using emojis and allow users to edit their own messages within a time window. This includes custom emoji support per waddle, reaction animations, and edit history tracking.

## Acceptance Criteria
- [ ] Users can add/remove emoji reactions to any message
- [ ] Custom emoji support per waddle
- [ ] Reactions update in real-time for all users
- [ ] Users can edit their messages within 15 minutes
- [ ] Edit history is tracked and viewable
- [ ] Edited messages show an "edited" indicator
- [ ] Emoji picker with search functionality
- [ ] Reaction notifications (optional)

## Technical Implementation

### 1. Database Schema Updates
```sql
-- Already in schema from Issue #05, but here for reference
CREATE TABLE reactions (
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  emoji TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  PRIMARY KEY (message_id, user_id, emoji),
  INDEX idx_message_reactions (message_id)
);

-- Add edit history table
CREATE TABLE message_edits (
  id TEXT PRIMARY KEY,
  message_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  old_content TEXT NOT NULL,
  new_content TEXT NOT NULL,
  edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_message_edits (message_id, edited_at DESC),
  FOREIGN KEY (message_id) REFERENCES messages(id)
);

-- Custom emojis per waddle
CREATE TABLE custom_emojis (
  id TEXT PRIMARY KEY,
  waddle_id TEXT NOT NULL,
  name TEXT NOT NULL,
  image_url TEXT NOT NULL,
  created_by TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(waddle_id, name),
  INDEX idx_waddle_emojis (waddle_id)
);
```

### 2. Reaction Management
```javascript
export class ReactionManager {
  static async addReaction(messageId, userId, emoji, channelId, env) {
    const waddleId = this.extractWaddleId(channelId);
    const db = env[`WADDLE_DB_${waddleId}`];
    
    try {
      // Validate emoji
      if (!this.isValidEmoji(emoji)) {
        throw new Error('Invalid emoji');
      }
      
      // Check if custom emoji exists
      if (emoji.startsWith(':') && emoji.endsWith(':')) {
        const customEmoji = await this.getCustomEmoji(emoji, waddleId, env);
        if (!customEmoji) {
          throw new Error('Custom emoji not found');
        }
      }
      
      // Add reaction
      await db.prepare(`
        INSERT OR IGNORE INTO reactions (message_id, user_id, emoji)
        VALUES (?, ?, ?)
      `).bind(messageId, userId, emoji).run();
      
      // Get updated reaction counts
      const reactions = await this.getMessageReactions(messageId, db);
      
      // Broadcast update
      await this.broadcastReactionUpdate(channelId, messageId, reactions, env);
      
      // Send notification if enabled
      await this.sendReactionNotification(messageId, userId, emoji, env);
      
      return { success: true, reactions };
      
    } catch (error) {
      console.error('Failed to add reaction:', error);
      return { success: false, error: error.message };
    }
  }
  
  static async removeReaction(messageId, userId, emoji, channelId, env) {
    const waddleId = this.extractWaddleId(channelId);
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Remove reaction
    await db.prepare(`
      DELETE FROM reactions 
      WHERE message_id = ? AND user_id = ? AND emoji = ?
    `).bind(messageId, userId, emoji).run();
    
    // Get updated reactions
    const reactions = await this.getMessageReactions(messageId, db);
    
    // Broadcast update
    await this.broadcastReactionUpdate(channelId, messageId, reactions, env);
    
    return { success: true, reactions };
  }
  
  static async getMessageReactions(messageId, db) {
    const results = await db.prepare(`
      SELECT 
        emoji,
        COUNT(*) as count,
        GROUP_CONCAT(user_id) as user_ids
      FROM reactions
      WHERE message_id = ?
      GROUP BY emoji
    `).bind(messageId).all();
    
    return results.results.map(r => ({
      emoji: r.emoji,
      count: r.count,
      users: r.user_ids.split(','),
      me: false // Will be set client-side
    }));
  }
  
  static isValidEmoji(emoji) {
    // Unicode emoji regex
    const unicodeEmojiRegex = /^[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]$/u;
    
    // Custom emoji format :name:
    const customEmojiRegex = /^:[a-zA-Z0-9_]+:$/;
    
    return unicodeEmojiRegex.test(emoji) || customEmojiRegex.test(emoji);
  }
  
  static async broadcastReactionUpdate(channelId, messageId, reactions, env) {
    const doId = env.CHANNEL_DO.idFromName(channelId);
    const stub = env.CHANNEL_DO.get(doId);
    
    await stub.broadcast({
      type: 'reaction_update',
      messageId,
      reactions
    });
  }
}
```

### 3. Message Editing Implementation
```javascript
export class MessageEditor {
  static async editMessage(messageId, userId, newContent, channelId, env) {
    const waddleId = this.extractWaddleId(channelId);
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Get original message
    const message = await db.prepare(`
      SELECT id, user_id, content, created_at, edit_count
      FROM messages
      WHERE id = ? AND user_id = ?
    `).bind(messageId, userId).first();
    
    if (!message) {
      throw new Error('Message not found or unauthorized');
    }
    
    // Check edit time window (15 minutes)
    const messageAge = Date.now() - new Date(message.created_at).getTime();
    const EDIT_WINDOW = 15 * 60 * 1000; // 15 minutes
    
    if (messageAge > EDIT_WINDOW && !this.hasEditPermission(userId, channelId, env)) {
      throw new Error('Edit window expired');
    }
    
    // Validate new content
    if (!newContent.trim() || newContent.length > 4000) {
      throw new Error('Invalid message content');
    }
    
    // Store edit history
    await db.prepare(`
      INSERT INTO message_edits (id, message_id, user_id, old_content, new_content)
      VALUES (?, ?, ?, ?, ?)
    `).bind(
      crypto.randomUUID(),
      messageId,
      userId,
      message.content,
      newContent
    ).run();
    
    // Update message
    await db.prepare(`
      UPDATE messages 
      SET content = ?,
          edited_at = CURRENT_TIMESTAMP,
          edit_count = edit_count + 1
      WHERE id = ?
    `).bind(newContent, messageId).run();
    
    // Update search index
    await db.prepare(`
      UPDATE messages_fts 
      SET content = ?
      WHERE message_id = ?
    `).bind(newContent, messageId).run();
    
    // Broadcast edit
    await this.broadcastMessageEdit(channelId, messageId, newContent, env);
    
    return { success: true };
  }
  
  static async getEditHistory(messageId, userId, env) {
    const waddleId = this.extractWaddleIdFromMessage(messageId, env);
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Check if user can view edit history
    const canView = await this.canViewEditHistory(userId, messageId, env);
    if (!canView) {
      throw new Error('Unauthorized');
    }
    
    const edits = await db.prepare(`
      SELECT 
        e.id,
        e.old_content,
        e.new_content,
        e.edited_at,
        u.username,
        u.avatar_url
      FROM message_edits e
      JOIN users u ON e.user_id = u.id
      WHERE e.message_id = ?
      ORDER BY e.edited_at DESC
    `).bind(messageId).all();
    
    return edits.results;
  }
  
  static async broadcastMessageEdit(channelId, messageId, newContent, env) {
    const doId = env.CHANNEL_DO.idFromName(channelId);
    const stub = env.CHANNEL_DO.get(doId);
    
    await stub.broadcast({
      type: 'message_edited',
      messageId,
      content: newContent,
      editedAt: new Date().toISOString()
    });
  }
}
```

### 4. Custom Emoji Management
```javascript
export class CustomEmojiManager {
  static async uploadEmoji(waddleId, name, file, userId, env) {
    // Validate emoji name
    if (!/^[a-zA-Z0-9_]+$/.test(name)) {
      throw new Error('Invalid emoji name. Use only letters, numbers, and underscores.');
    }
    
    // Check permissions
    const hasPermission = await this.canManageEmojis(userId, waddleId, env);
    if (!hasPermission) {
      throw new Error('No permission to manage emojis');
    }
    
    // Validate file
    if (!file.type.startsWith('image/') || file.size > 256 * 1024) {
      throw new Error('Invalid file. Must be an image under 256KB.');
    }
    
    // Generate emoji ID
    const emojiId = crypto.randomUUID();
    const key = `emojis/${waddleId}/${emojiId}.${file.type.split('/')[1]}`;
    
    // Upload to R2
    await env.MEDIA_BUCKET.put(key, file.stream(), {
      httpMetadata: {
        contentType: file.type
      },
      customMetadata: {
        waddleId,
        emojiName: name,
        uploadedBy: userId
      }
    });
    
    // Store in database
    const db = env.CENTRAL_DB;
    await db.prepare(`
      INSERT INTO custom_emojis (id, waddle_id, name, image_url, created_by)
      VALUES (?, ?, ?, ?, ?)
    `).bind(
      emojiId,
      waddleId,
      name,
      `${env.MEDIA_CDN_URL}/${key}`,
      userId
    ).run();
    
    // Broadcast new emoji
    await this.broadcastEmojiUpdate(waddleId, 'added', { id: emojiId, name }, env);
    
    return { id: emojiId, name, url: `${env.MEDIA_CDN_URL}/${key}` };
  }
  
  static async getWaddleEmojis(waddleId, env) {
    const emojis = await env.CENTRAL_DB.prepare(`
      SELECT id, name, image_url
      FROM custom_emojis
      WHERE waddle_id = ?
      ORDER BY name
    `).bind(waddleId).all();
    
    return emojis.results;
  }
}
```

### 5. React Components
```tsx
// Reaction picker component
export function ReactionPicker({ 
  messageId, 
  onSelect 
}: { 
  messageId: string;
  onSelect: (emoji: string) => void;
}) {
  const [search, setSearch] = useState('');
  const [showCustom, setShowCustom] = useState(false);
  const { customEmojis } = useWaddleEmojis();
  
  const categories = [
    { id: 'recent', name: 'Recently Used', emojis: getRecentEmojis() },
    { id: 'smileys', name: 'Smileys & Emotion', emojis: SMILEYS },
    { id: 'people', name: 'People & Body', emojis: PEOPLE },
    { id: 'nature', name: 'Animals & Nature', emojis: NATURE },
    { id: 'food', name: 'Food & Drink', emojis: FOOD },
    { id: 'custom', name: 'Custom', emojis: customEmojis }
  ];
  
  const filteredEmojis = search
    ? searchEmojis(search, [...SMILEYS, ...PEOPLE, ...NATURE, ...FOOD, ...customEmojis])
    : null;
  
  return (
    <div className="reaction-picker">
      <div className="picker-header">
        <input
          type="text"
          placeholder="Search emojis..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          autoFocus
        />
      </div>
      
      <div className="picker-body">
        {filteredEmojis ? (
          <EmojiGrid
            emojis={filteredEmojis}
            onSelect={(emoji) => {
              onSelect(emoji);
              addToRecent(emoji);
            }}
          />
        ) : (
          <EmojiCategories
            categories={categories}
            onSelect={(emoji) => {
              onSelect(emoji);
              addToRecent(emoji);
            }}
          />
        )}
      </div>
    </div>
  );
}

// Message reactions display
export function MessageReactions({ 
  messageId, 
  reactions 
}: { 
  messageId: string;
  reactions: Reaction[];
}) {
  const { user } = useAuth();
  const [showPicker, setShowPicker] = useState(false);
  
  const handleReaction = async (emoji: string) => {
    const existing = reactions.find(r => 
      r.emoji === emoji && r.users.includes(user.id)
    );
    
    if (existing) {
      await api.removeReaction(messageId, emoji);
    } else {
      await api.addReaction(messageId, emoji);
    }
    
    setShowPicker(false);
  };
  
  return (
    <div className="message-reactions">
      {reactions.map(reaction => (
        <ReactionButton
          key={reaction.emoji}
          reaction={reaction}
          isMe={reaction.users.includes(user.id)}
          onClick={() => handleReaction(reaction.emoji)}
        />
      ))}
      
      <button
        className="add-reaction"
        onClick={() => setShowPicker(!showPicker)}
      >
        <PlusIcon />
      </button>
      
      {showPicker && (
        <Popover>
          <ReactionPicker
            messageId={messageId}
            onSelect={handleReaction}
          />
        </Popover>
      )}
    </div>
  );
}

// Reaction animation
function ReactionButton({ reaction, isMe, onClick }: ReactionProps) {
  const [animate, setAnimate] = useState(false);
  
  const handleClick = () => {
    setAnimate(true);
    onClick();
    setTimeout(() => setAnimate(false), 300);
  };
  
  return (
    <button
      className={`reaction-button ${isMe ? 'me' : ''} ${animate ? 'animate' : ''}`}
      onClick={handleClick}
      title={`${reaction.users.length} ${reaction.users.length === 1 ? 'person' : 'people'} reacted`}
    >
      <span className="emoji">{reaction.emoji}</span>
      <span className="count">{reaction.count}</span>
    </button>
  );
}
```

### 6. Message Edit UI
```tsx
export function MessageEditForm({ 
  message, 
  onSave, 
  onCancel 
}: {
  message: Message;
  onSave: (content: string) => void;
  onCancel: () => void;
}) {
  const [content, setContent] = useState(message.content);
  const [saving, setSaving] = useState(false);
  
  const handleSave = async () => {
    if (!content.trim() || content === message.content) {
      return;
    }
    
    setSaving(true);
    try {
      await api.editMessage(message.id, content);
      onSave(content);
    } catch (error) {
      toast.error('Failed to edit message');
    } finally {
      setSaving(false);
    }
  };
  
  return (
    <div className="message-edit-form">
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSave();
          }
          if (e.key === 'Escape') {
            onCancel();
          }
        }}
        autoFocus
        maxLength={4000}
      />
      
      <div className="edit-actions">
        <span className="hint">
          escape to <button onClick={onCancel}>cancel</button> â€¢ 
          enter to <button onClick={handleSave} disabled={saving}>save</button>
        </span>
      </div>
    </div>
  );
}

// Edit history viewer
export function EditHistoryModal({ 
  messageId, 
  onClose 
}: { 
  messageId: string;
  onClose: () => void;
}) {
  const { data: history, loading } = useEditHistory(messageId);
  
  return (
    <Modal onClose={onClose} title="Edit History">
      {loading ? (
        <Spinner />
      ) : (
        <div className="edit-history">
          {history.map((edit, index) => (
            <div key={edit.id} className="edit-entry">
              <div className="edit-meta">
                <Avatar user={edit.user} size="small" />
                <span>{edit.username}</span>
                <time>{formatDateTime(edit.edited_at)}</time>
              </div>
              
              {index < history.length - 1 && (
                <DiffViewer
                  before={edit.old_content}
                  after={edit.new_content}
                />
              )}
            </div>
          ))}
        </div>
      )}
    </Modal>
  );
}
```

### 7. Real-time Updates
```javascript
// WebSocket handlers in Durable Object
export class ChannelWebSocketHandlers {
  async handleReactionUpdate(data) {
    const update = JSON.stringify({
      type: 'reaction_update',
      messageId: data.messageId,
      reactions: data.reactions
    });
    
    // Broadcast to all connected clients
    for (const ws of this.state.getWebSockets()) {
      try {
        ws.send(update);
      } catch (err) {
        // Client disconnected
      }
    }
  }
  
  async handleMessageEdit(data) {
    const update = JSON.stringify({
      type: 'message_edited',
      messageId: data.messageId,
      content: data.content,
      editedAt: data.editedAt
    });
    
    // Broadcast to all connected clients
    for (const ws of this.state.getWebSockets()) {
      try {
        ws.send(update);
      } catch (err) {
        // Client disconnected
      }
    }
  }
}

// Client-side WebSocket handler
class MessageUpdateHandler {
  handleUpdate(data) {
    switch (data.type) {
      case 'reaction_update':
        this.updateMessageReactions(data.messageId, data.reactions);
        break;
        
      case 'message_edited':
        this.updateMessageContent(data.messageId, data.content, data.editedAt);
        break;
    }
  }
  
  updateMessageReactions(messageId, reactions) {
    // Update UI with new reactions
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      // Trigger re-render with new reactions
      this.events.emit('reactions:update', { messageId, reactions });
    }
  }
  
  updateMessageContent(messageId, content, editedAt) {
    // Update message content and show edited indicator
    this.events.emit('message:edited', { messageId, content, editedAt });
  }
}
```

## Dependencies
- WebSocket Architecture (Issue #04) for real-time updates
- Database Schema (Issue #05) for reaction storage
- Media Uploads (Issue #09) for custom emoji storage
- Message Flow (Issue #06) for message structure

## Estimated Effort
**5 days**
- 1 day: Reaction backend and database
- 1 day: Message editing implementation
- 1 day: Emoji picker and custom emojis
- 1 day: UI components and animations
- 1 day: Real-time updates and testing

## Notes
- Consider reaction rate limiting to prevent spam
- Add reaction analytics for popular emojis
- Implement emoji categories and skin tone variants
- Plan for animated emoji support (GIF/Lottie)