# Issue #27: Android UI Components

## User Story
As an **Android user**, I want to **have a native, intuitive interface** so that **I can easily navigate and use all waddle features on my mobile device**.

## Description
Build comprehensive UI components for the Android app using Jetpack Compose, following Material Design 3 guidelines. This includes chat interfaces, waddle navigation, channel lists, message composition, and all interactive elements optimized for mobile use.

## Acceptance Criteria
- [ ] Material Design 3 components
- [ ] Responsive layouts for all screen sizes
- [ ] Smooth animations and transitions
- [ ] Dark mode support
- [ ] Gesture navigation
- [ ] Accessibility compliance
- [ ] Performance optimization
- [ ] Offline state handling

## Technical Implementation

### 1. Core UI Components
```kotlin
// Main App Scaffold
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WaddleApp(
    appState: WaddleAppState = rememberWaddleAppState()
) {
    WaddleTheme {
        val navController = appState.navController
        val currentBackStackEntry by navController.currentBackStackEntryAsState()
        val currentDestination = currentBackStackEntry?.destination
        
        Scaffold(
            bottomBar = {
                if (appState.shouldShowBottomBar) {
                    WaddleBottomNavigation(
                        destinations = appState.bottomNavDestinations,
                        currentDestination = currentDestination,
                        onNavigateToDestination = { destination ->
                            navController.navigateToBottomNavDestination(destination)
                        }
                    )
                }
            },
            snackbarHost = {
                SnackbarHost(hostState = appState.snackbarHostState)
            }
        ) { paddingValues ->
            WaddleNavHost(
                navController = navController,
                modifier = Modifier.padding(paddingValues)
            )
        }
    }
}

// App State Management
@Stable
class WaddleAppState(
    val navController: NavHostController,
    val snackbarHostState: SnackbarHostState,
    val coroutineScope: CoroutineScope
) {
    val bottomNavDestinations = listOf(
        BottomNavDestination.Home,
        BottomNavDestination.Messages,
        BottomNavDestination.Discover,
        BottomNavDestination.Profile
    )
    
    val shouldShowBottomBar: Boolean
        @Composable get() = navController
            .currentBackStackEntryAsState().value?.destination?.route in 
            bottomNavDestinations.map { it.route }
    
    fun showSnackbar(message: String, action: String? = null) {
        coroutineScope.launch {
            snackbarHostState.showSnackbar(
                message = message,
                actionLabel = action,
                duration = SnackbarDuration.Short
            )
        }
    }
}

// Bottom Navigation
@Composable
fun WaddleBottomNavigation(
    destinations: List<BottomNavDestination>,
    currentDestination: NavDestination?,
    onNavigateToDestination: (BottomNavDestination) -> Unit
) {
    NavigationBar(
        modifier = Modifier.fillMaxWidth(),
        tonalElevation = 0.dp
    ) {
        destinations.forEach { destination ->
            val selected = currentDestination?.hierarchy?.any { 
                it.route == destination.route 
            } == true
            
            NavigationBarItem(
                selected = selected,
                onClick = { onNavigateToDestination(destination) },
                icon = {
                    Icon(
                        imageVector = if (selected) {
                            destination.selectedIcon
                        } else {
                            destination.unselectedIcon
                        },
                        contentDescription = stringResource(destination.labelResId)
                    )
                },
                label = {
                    Text(text = stringResource(destination.labelResId))
                }
            )
        }
    }
}
```

### 2. Waddle List Screen
```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = hiltViewModel(),
    onNavigateToWaddle: (String) -> Unit,
    onNavigateToCreate: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val pullRefreshState = rememberPullRefreshState(
        refreshing = uiState.isRefreshing,
        onRefresh = { viewModel.refresh() }
    )
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Waddles") },
                actions = {
                    IconButton(onClick = onNavigateToCreate) {
                        Icon(Icons.Default.Add, contentDescription = "Create Waddle")
                    }
                }
            )
        },
        floatingActionButton = {
            ExtendedFloatingActionButton(
                onClick = onNavigateToCreate,
                icon = { Icon(Icons.Default.Add, contentDescription = null) },
                text = { Text("New Waddle") }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .pullRefresh(pullRefreshState)
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading && uiState.waddles.isEmpty() -> {
                    LoadingState()
                }
                uiState.waddles.isEmpty() -> {
                    EmptyState(
                        message = "No waddles yet",
                        action = "Create one" to onNavigateToCreate
                    )
                }
                else -> {
                    WaddleList(
                        waddles = uiState.waddles,
                        onWaddleClick = onNavigateToWaddle
                    )
                }
            }
            
            PullRefreshIndicator(
                refreshing = uiState.isRefreshing,
                state = pullRefreshState,
                modifier = Modifier.align(Alignment.TopCenter)
            )
        }
    }
}

@Composable
fun WaddleList(
    waddles: List<Waddle>,
    onWaddleClick: (String) -> Unit
) {
    LazyColumn(
        contentPadding = PaddingValues(vertical = 8.dp),
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        items(
            items = waddles,
            key = { it.id }
        ) { waddle ->
            WaddleItem(
                waddle = waddle,
                onClick = { onWaddleClick(waddle.id) },
                modifier = Modifier.animateItemPlacement()
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WaddleItem(
    waddle: Waddle,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        onClick = onClick,
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Waddle icon
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(waddle.iconUrl)
                    .crossfade(true)
                    .build(),
                contentDescription = waddle.name,
                modifier = Modifier
                    .size(56.dp)
                    .clip(RoundedCornerShape(12.dp)),
                contentScale = ContentScale.Crop,
                placeholder = painterResource(R.drawable.waddle_placeholder)
            )
            
            // Waddle info
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = waddle.name,
                    style = MaterialTheme.typography.titleMedium,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                
                if (waddle.lastMessage != null) {
                    Text(
                        text = waddle.lastMessage.preview,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    if (waddle.unreadCount > 0) {
                        Badge {
                            Text(waddle.unreadCount.toString())
                        }
                    }
                    
                    if (waddle.mentionCount > 0) {
                        Badge(
                            containerColor = MaterialTheme.colorScheme.error
                        ) {
                            Text("@${waddle.mentionCount}")
                        }
                    }
                }
            }
            
            // Timestamp
            waddle.lastMessage?.let { message ->
                Text(
                    text = formatRelativeTime(message.timestamp),
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
```

### 3. Channel Navigation
```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WaddleScreen(
    waddleId: String,
    viewModel: WaddleViewModel = hiltViewModel(),
    onNavigateToChannel: (String) -> Unit,
    onNavigateBack: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()
    
    BackHandler(enabled = drawerState.isOpen) {
        scope.launch { drawerState.close() }
    }
    
    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            ModalDrawerSheet {
                WaddleDrawerContent(
                    waddle = uiState.waddle,
                    channels = uiState.channels,
                    currentChannelId = uiState.currentChannelId,
                    onChannelClick = { channelId ->
                        onNavigateToChannel(channelId)
                        scope.launch { drawerState.close() }
                    },
                    onSettingsClick = {
                        // Navigate to waddle settings
                    }
                )
            }
        }
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(uiState.currentChannel?.name ?: "") },
                    navigationIcon = {
                        IconButton(onClick = { 
                            scope.launch { drawerState.open() }
                        }) {
                            Icon(Icons.Default.Menu, contentDescription = "Menu")
                        }
                    },
                    actions = {
                        if (uiState.currentChannel?.type == ChannelType.VOICE) {
                            IconButton(onClick = { /* Join voice */ }) {
                                Icon(Icons.Default.Call, contentDescription = "Join Voice")
                            }
                        }
                        IconButton(onClick = { /* Channel info */ }) {
                            Icon(Icons.Default.Info, contentDescription = "Channel Info")
                        }
                    }
                )
            }
        ) { paddingValues ->
            // Channel content
            when (uiState.currentChannel?.type) {
                ChannelType.TEXT -> {
                    TextChannelScreen(
                        channelId = uiState.currentChannelId!!,
                        modifier = Modifier.padding(paddingValues)
                    )
                }
                ChannelType.VOICE -> {
                    VoiceChannelPreview(
                        channel = uiState.currentChannel,
                        participants = uiState.voiceParticipants,
                        onJoin = { /* Join voice */ },
                        modifier = Modifier.padding(paddingValues)
                    )
                }
                else -> {
                    // Loading or error state
                }
            }
        }
    }
}

@Composable
fun WaddleDrawerContent(
    waddle: Waddle?,
    channels: List<Channel>,
    currentChannelId: String?,
    onChannelClick: (String) -> Unit,
    onSettingsClick: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
    ) {
        // Waddle header
        waddle?.let {
            WaddleHeader(
                waddle = it,
                onSettingsClick = onSettingsClick
            )
        }
        
        Divider()
        
        // Channel categories
        val groupedChannels = channels.groupBy { it.categoryId }
        
        groupedChannels.forEach { (categoryId, channelsInCategory) ->
            if (categoryId != null) {
                CategoryHeader(
                    category = categories.find { it.id == categoryId }!!
                )
            }
            
            channelsInCategory.forEach { channel ->
                ChannelItem(
                    channel = channel,
                    isSelected = channel.id == currentChannelId,
                    onClick = { onChannelClick(channel.id) }
                )
            }
        }
    }
}

@Composable
fun ChannelItem(
    channel: Channel,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    NavigationDrawerItem(
        icon = {
            Icon(
                imageVector = when (channel.type) {
                    ChannelType.TEXT -> Icons.Default.Tag
                    ChannelType.VOICE -> Icons.Default.VolumeUp
                    ChannelType.ANNOUNCEMENT -> Icons.Default.Campaign
                    ChannelType.FORUM -> Icons.Default.Forum
                },
                contentDescription = null
            )
        },
        label = { 
            Text(
                text = channel.name,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
        },
        selected = isSelected,
        onClick = onClick,
        badge = {
            if (channel.unreadCount > 0) {
                Badge {
                    Text(channel.unreadCount.toString())
                }
            }
        }
    )
}
```

### 4. Message Composition
```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MessageComposer(
    channelId: String,
    replyingTo: Message? = null,
    onSendMessage: (String, List<Uri>) -> Unit,
    modifier: Modifier = Modifier
) {
    var messageText by remember { mutableStateOf("") }
    var attachments by remember { mutableStateOf<List<Uri>>(emptyList()) }
    var isRecordingVoice by remember { mutableStateOf(false) }
    val focusRequester = remember { FocusRequester() }
    
    val attachmentLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetMultipleContents()
    ) { uris ->
        attachments = attachments + uris
    }
    
    Column(modifier = modifier) {
        // Reply preview
        AnimatedVisibility(visible = replyingTo != null) {
            ReplyPreview(
                message = replyingTo!!,
                onDismiss = { /* Clear reply */ }
            )
        }
        
        // Attachments preview
        AnimatedVisibility(visible = attachments.isNotEmpty()) {
            AttachmentsPreview(
                attachments = attachments,
                onRemove = { uri ->
                    attachments = attachments - uri
                }
            )
        }
        
        // Input area
        Surface(
            color = MaterialTheme.colorScheme.surfaceVariant,
            shape = RoundedCornerShape(24.dp),
            modifier = Modifier.padding(8.dp)
        ) {
            Row(
                modifier = Modifier.padding(4.dp),
                verticalAlignment = Alignment.Bottom
            ) {
                // Attachment button
                IconButton(
                    onClick = { attachmentLauncher.launch("*/*") }
                ) {
                    Icon(Icons.Default.AttachFile, contentDescription = "Attach")
                }
                
                // Text input
                BasicTextField(
                    value = messageText,
                    onValueChange = { messageText = it },
                    modifier = Modifier
                        .weight(1f)
                        .padding(horizontal = 8.dp, vertical = 12.dp)
                        .focusRequester(focusRequester),
                    textStyle = MaterialTheme.typography.bodyLarge.copy(
                        color = MaterialTheme.colorScheme.onSurface
                    ),
                    decorationBox = { innerTextField ->
                        Box {
                            if (messageText.isEmpty()) {
                                Text(
                                    text = "Type a message...",
                                    style = MaterialTheme.typography.bodyLarge,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            innerTextField()
                        }
                    },
                    keyboardOptions = KeyboardOptions(
                        capitalization = KeyboardCapitalization.Sentences,
                        autoCorrect = true
                    ),
                    maxLines = 5
                )
                
                // Send/Voice button
                AnimatedContent(
                    targetState = messageText.isNotEmpty() || attachments.isNotEmpty()
                ) { hasContent ->
                    if (hasContent) {
                        IconButton(
                            onClick = {
                                onSendMessage(messageText, attachments)
                                messageText = ""
                                attachments = emptyList()
                            }
                        ) {
                            Icon(Icons.Default.Send, contentDescription = "Send")
                        }
                    } else {
                        IconButton(
                            onClick = { isRecordingVoice = !isRecordingVoice }
                        ) {
                            Icon(
                                imageVector = if (isRecordingVoice) {
                                    Icons.Default.Stop
                                } else {
                                    Icons.Default.Mic
                                },
                                contentDescription = "Voice message",
                                tint = if (isRecordingVoice) {
                                    MaterialTheme.colorScheme.error
                                } else {
                                    LocalContentColor.current
                                }
                            )
                        }
                    }
                }
            }
        }
        
        // Voice recording indicator
        AnimatedVisibility(visible = isRecordingVoice) {
            VoiceRecordingIndicator(
                onCancel = { isRecordingVoice = false },
                onSend = { audioUri ->
                    onSendMessage("", listOf(audioUri))
                    isRecordingVoice = false
                }
            )
        }
    }
}

@Composable
fun VoiceRecordingIndicator(
    onCancel: () -> Unit,
    onSend: (Uri) -> Unit
) {
    var duration by remember { mutableStateOf(0) }
    
    LaunchedEffect(Unit) {
        while (true) {
            delay(1000)
            duration++
        }
    }
    
    Surface(
        color = MaterialTheme.colorScheme.errorContainer,
        shape = RoundedCornerShape(8.dp),
        modifier = Modifier.padding(8.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Recording animation
                Box(
                    modifier = Modifier
                        .size(12.dp)
                        .background(
                            Color.Red,
                            CircleShape
                        )
                ) {
                    // Pulsing animation
                    val infiniteTransition = rememberInfiniteTransition()
                    val alpha by infiniteTransition.animateFloat(
                        initialValue = 1f,
                        targetValue = 0.3f,
                        animationSpec = infiniteRepeatable(
                            animation = tween(600),
                            repeatMode = RepeatMode.Reverse
                        )
                    )
                    
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .alpha(alpha)
                            .background(Color.Red, CircleShape)
                    )
                }
                
                Text(
                    text = "Recording voice message",
                    style = MaterialTheme.typography.bodyMedium
                )
                
                Text(
                    text = formatDuration(duration),
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold
                )
            }
            
            Row {
                TextButton(onClick = onCancel) {
                    Text("Cancel")
                }
                
                Button(
                    onClick = { /* Stop and send */ }
                ) {
                    Text("Send")
                }
            }
        }
    }
}
```

### 5. Message List
```kotlin
@Composable
fun MessageList(
    messages: List<Message>,
    currentUserId: String,
    onMessageLongPress: (Message) -> Unit,
    onUserClick: (String) -> Unit,
    onLoadMore: () -> Unit,
    modifier: Modifier = Modifier
) {
    val listState = rememberLazyListState()
    
    // Load more when reaching top
    LaunchedEffect(listState) {
        snapshotFlow { listState.firstVisibleItemIndex }
            .filter { it == 0 }
            .collect { onLoadMore() }
    }
    
    LazyColumn(
        state = listState,
        reverseLayout = true,
        contentPadding = PaddingValues(vertical = 8.dp),
        verticalArrangement = Arrangement.spacedBy(4.dp),
        modifier = modifier
    ) {
        itemsIndexed(
            items = messages,
            key = { _, message -> message.id }
        ) { index, message ->
            val previousMessage = messages.getOrNull(index + 1)
            val showHeader = shouldShowHeader(message, previousMessage)
            
            MessageItem(
                message = message,
                isOwnMessage = message.authorId == currentUserId,
                showHeader = showHeader,
                onLongPress = { onMessageLongPress(message) },
                onUserClick = { onUserClick(message.authorId) },
                modifier = Modifier.animateItemPlacement()
            )
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun MessageItem(
    message: Message,
    isOwnMessage: Boolean,
    showHeader: Boolean,
    onLongPress: () -> Unit,
    onUserClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxWidth()
            .combinedClickable(
                onLongClick = onLongPress,
                onClick = {}
            )
            .padding(horizontal = 16.dp)
    ) {
        if (showHeader) {
            Row(
                modifier = Modifier.padding(top = 16.dp, bottom = 4.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                AsyncImage(
                    model = message.author.avatarUrl,
                    contentDescription = message.author.username,
                    modifier = Modifier
                        .size(40.dp)
                        .clip(CircleShape)
                        .clickable { onUserClick() },
                    contentScale = ContentScale.Crop
                )
                
                Text(
                    text = message.author.displayName ?: message.author.username,
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.clickable { onUserClick() }
                )
                
                Text(
                    text = formatTimestamp(message.timestamp),
                    style = MaterialTheme.typography.labelSmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        
        // Message content
        Surface(
            color = if (isOwnMessage) {
                MaterialTheme.colorScheme.primaryContainer
            } else {
                Color.Transparent
            },
            shape = RoundedCornerShape(
                topStart = if (!showHeader && !isOwnMessage) 4.dp else 12.dp,
                topEnd = if (!showHeader && isOwnMessage) 4.dp else 12.dp,
                bottomStart = 12.dp,
                bottomEnd = 12.dp
            ),
            modifier = Modifier.padding(
                start = if (!showHeader) 48.dp else 0.dp
            )
        ) {
            Column(
                modifier = Modifier.padding(8.dp)
            ) {
                // Text content
                if (message.content.isNotEmpty()) {
                    SelectionContainer {
                        MarkdownText(
                            markdown = message.content,
                            style = MaterialTheme.typography.bodyLarge,
                            onClick = { url ->
                                // Handle URL clicks
                            }
                        )
                    }
                }
                
                // Attachments
                message.attachments.forEach { attachment ->
                    when (attachment.type) {
                        AttachmentType.IMAGE -> {
                            ImageAttachment(
                                attachment = attachment,
                                modifier = Modifier.padding(top = 4.dp)
                            )
                        }
                        AttachmentType.VIDEO -> {
                            VideoAttachment(
                                attachment = attachment,
                                modifier = Modifier.padding(top = 4.dp)
                            )
                        }
                        AttachmentType.FILE -> {
                            FileAttachment(
                                attachment = attachment,
                                modifier = Modifier.padding(top = 4.dp)
                            )
                        }
                    }
                }
                
                // Reactions
                if (message.reactions.isNotEmpty()) {
                    MessageReactions(
                        reactions = message.reactions,
                        onAddReaction = { /* Add reaction */ },
                        onRemoveReaction = { /* Remove reaction */ },
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun MessageReactions(
    reactions: List<Reaction>,
    onAddReaction: () -> Unit,
    onRemoveReaction: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    FlowRow(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(4.dp),
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        reactions.forEach { reaction ->
            ReactionChip(
                reaction = reaction,
                onClick = {
                    if (reaction.hasReacted) {
                        onRemoveReaction(reaction.emoji)
                    } else {
                        // React with same emoji
                    }
                }
            )
        }
        
        // Add reaction button
        AssistChip(
            onClick = onAddReaction,
            leadingIcon = {
                Icon(
                    Icons.Default.AddReaction,
                    contentDescription = "Add reaction",
                    modifier = Modifier.size(16.dp)
                )
            },
            label = { Text("+") },
            modifier = Modifier.height(28.dp)
        )
    }
}
```

### 6. Adaptive Layouts
```kotlin
// Adaptive layout for tablets
@Composable
fun AdaptiveWaddleLayout(
    windowSizeClass: WindowSizeClass,
    waddleId: String
) {
    when (windowSizeClass.widthSizeClass) {
        WindowWidthSizeClass.Compact -> {
            // Phone layout - navigation drawer
            CompactWaddleLayout(waddleId)
        }
        WindowWidthSizeClass.Medium -> {
            // Small tablet - rail navigation
            MediumWaddleLayout(waddleId)
        }
        WindowWidthSizeClass.Expanded -> {
            // Large tablet/desktop - permanent drawer
            ExpandedWaddleLayout(waddleId)
        }
    }
}

@Composable
fun ExpandedWaddleLayout(waddleId: String) {
    Row(modifier = Modifier.fillMaxSize()) {
        // Permanent navigation drawer
        Surface(
            modifier = Modifier
                .fillMaxHeight()
                .width(280.dp),
            tonalElevation = 1.dp
        ) {
            WaddleNavigation(waddleId)
        }
        
        // Channel list
        Surface(
            modifier = Modifier
                .fillMaxHeight()
                .width(320.dp),
            tonalElevation = 0.dp
        ) {
            ChannelList(waddleId)
        }
        
        // Main content
        Box(
            modifier = Modifier
                .fillMaxHeight()
                .weight(1f)
        ) {
            ChannelContent()
        }
    }
}

// Responsive grid for images
@Composable
fun ResponsiveImageGrid(
    images: List<ImageData>,
    windowSizeClass: WindowSizeClass
) {
    val columns = when (windowSizeClass.widthSizeClass) {
        WindowWidthSizeClass.Compact -> 2
        WindowWidthSizeClass.Medium -> 3
        WindowWidthSizeClass.Expanded -> 4
    }
    
    LazyVerticalGrid(
        columns = GridCells.Fixed(columns),
        contentPadding = PaddingValues(8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(images) { image ->
            ImageGridItem(image)
        }
    }
}
```

### 7. Gesture Handling
```kotlin
// Swipe to reply
@OptIn(ExperimentalMaterialApi::class)
@Composable
fun SwipeableMessageItem(
    message: Message,
    onReply: () -> Unit,
    content: @Composable () -> Unit
) {
    val swipeableState = rememberSwipeableState(0)
    val sizePx = with(LocalDensity.current) { 72.dp.toPx() }
    val anchors = mapOf(0f to 0, sizePx to 1)
    
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .swipeable(
                state = swipeableState,
                anchors = anchors,
                thresholds = { _, _ -> FractionalThreshold(0.3f) },
                orientation = Orientation.Horizontal
            )
    ) {
        // Reply indicator
        Row(
            modifier = Modifier
                .fillMaxHeight()
                .padding(horizontal = 16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            val progress = (swipeableState.offset.value / sizePx).coerceIn(0f, 1f)
            Icon(
                Icons.Default.Reply,
                contentDescription = "Reply",
                modifier = Modifier
                    .alpha(progress)
                    .scale(progress),
                tint = MaterialTheme.colorScheme.primary
            )
        }
        
        // Message content
        Surface(
            modifier = Modifier
                .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
                .fillMaxWidth()
        ) {
            content()
        }
    }
    
    // Trigger reply when threshold reached
    LaunchedEffect(swipeableState.currentValue) {
        if (swipeableState.currentValue == 1) {
            onReply()
            swipeableState.animateTo(0)
        }
    }
}

// Pull to refresh with custom indicator
@Composable
fun CustomPullRefresh(
    refreshing: Boolean,
    onRefresh: () -> Unit,
    content: @Composable () -> Unit
) {
    val refreshScope = rememberCoroutineScope()
    val refreshState = rememberPullRefreshState(refreshing, onRefresh)
    
    Box(
        modifier = Modifier.pullRefresh(refreshState)
    ) {
        content()
        
        // Custom refresh indicator
        Box(
            modifier = Modifier
                .align(Alignment.TopCenter)
                .graphicsLayer {
                    val scale = (refreshState.progress * 2f).coerceAtMost(1f)
                    scaleX = scale
                    scaleY = scale
                    alpha = refreshState.progress
                }
        ) {
            WaddleLoadingAnimation(
                modifier = Modifier.size(40.dp)
            )
        }
    }
}
```

## Dependencies
- Jetpack Compose
- Material Design 3
- Coil for image loading
- Accompanist for additional components
- Window Size Classes for adaptive layouts

## Estimated Effort
**5 days**
- 1 day: Core components and navigation
- 1 day: Waddle and channel screens
- 1 day: Message composition and display
- 1 day: Adaptive layouts and responsiveness
- 1 day: Animations and gestures

## Notes
- Follow Material Design 3 guidelines
- Ensure smooth 60fps animations
- Test on various screen sizes
- Implement proper state restoration
- Add haptic feedback for interactions