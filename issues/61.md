# Issue #61: Performance Monitoring

## User Story
As a **platform operator**, I want to **monitor global performance metrics in real-time** so that **I can ensure optimal user experience and quickly identify and resolve performance issues**.

## Description
Implement a comprehensive performance monitoring system that tracks metrics across all services, regions, and user interactions. The system should provide real-time dashboards, intelligent alerting, performance analytics, and automated remediation capabilities.

## Acceptance Criteria
- [ ] Real-time performance metrics collection
- [ ] Global performance dashboard
- [ ] User experience monitoring (RUM)
- [ ] Synthetic monitoring and health checks
- [ ] Intelligent anomaly detection
- [ ] Performance SLA tracking
- [ ] Automated incident response
- [ ] Historical performance analytics

## Technical Implementation

### 1. Performance Monitoring Infrastructure
```typescript
// Core performance monitoring system
export class PerformanceMonitor {
  private collectors: Map<string, MetricCollector> = new Map();
  private aggregator: MetricAggregator;
  private storage: TimeSeriesDatabase;
  private analyzer: PerformanceAnalyzer;
  
  constructor(
    private env: Env,
    private config: MonitoringConfig
  ) {
    this.aggregator = new MetricAggregator();
    this.storage = new TimeSeriesDatabase(env);
    this.analyzer = new PerformanceAnalyzer();
    this.initializeCollectors();
  }
  
  private initializeCollectors() {
    // Application performance monitoring
    this.collectors.set('apm', new APMCollector({
      sampleRate: 0.1, // 10% sampling
      traceRetention: 86400000, // 24 hours
      customMetrics: ['waddle_operations', 'voice_quality', 'message_latency']
    }));
    
    // Real User Monitoring
    this.collectors.set('rum', new RUMCollector({
      sessionTimeout: 1800000, // 30 minutes
      captureErrors: true,
      capturePerformance: true
    }));
    
    // Infrastructure monitoring
    this.collectors.set('infra', new InfrastructureCollector({
      interval: 60000, // 1 minute
      metrics: ['cpu', 'memory', 'disk', 'network']
    }));
    
    // WebRTC quality monitoring
    this.collectors.set('webrtc', new WebRTCQualityCollector({
      statsInterval: 5000, // 5 seconds
      qualityThresholds: {
        excellent: { loss: 0.01, jitter: 30, latency: 150 },
        good: { loss: 0.05, jitter: 50, latency: 300 },
        fair: { loss: 0.1, jitter: 100, latency: 500 }
      }
    }));
    
    // Database performance
    this.collectors.set('database', new DatabaseCollector({
      slowQueryThreshold: 100, // 100ms
      captureQueryPlans: true
    }));
  }
  
  async collectMetrics(): Promise<void> {
    const timestamp = Date.now();
    const metrics: CollectedMetrics = {};
    
    // Collect from all sources in parallel
    const collections = await Promise.all(
      Array.from(this.collectors.entries()).map(async ([name, collector]) => ({
        name,
        data: await collector.collect()
      }))
    );
    
    // Process collected metrics
    for (const { name, data } of collections) {
      metrics[name] = this.processMetrics(data, timestamp);
    }
    
    // Aggregate metrics
    const aggregated = await this.aggregator.aggregate(metrics);
    
    // Store metrics
    await this.storage.write(aggregated);
    
    // Real-time analysis
    await this.analyzer.analyze(aggregated);
  }
  
  private processMetrics(
    data: RawMetrics,
    timestamp: number
  ): ProcessedMetrics {
    return {
      timestamp,
      values: data.values,
      percentiles: this.calculatePercentiles(data.samples),
      rate: this.calculateRate(data.counters),
      tags: data.tags,
      metadata: {
        sampleCount: data.samples?.length || 0,
        processingTime: Date.now() - timestamp
      }
    };
  }
}

// Application Performance Monitoring
export class APMCollector implements MetricCollector {
  private tracer: Tracer;
  private spans: Map<string, Span> = new Map();
  
  constructor(private config: APMConfig) {
    this.tracer = new Tracer(config);
  }
  
  async collect(): Promise<APMMetrics> {
    const traces = await this.tracer.getCompletedTraces();
    
    return {
      operations: this.analyzeOperations(traces),
      errors: this.analyzeErrors(traces),
      dependencies: this.analyzeDependencies(traces),
      userFlows: this.analyzeUserFlows(traces),
      performance: {
        p50: this.calculatePercentile(traces, 50),
        p95: this.calculatePercentile(traces, 95),
        p99: this.calculatePercentile(traces, 99),
        errorRate: this.calculateErrorRate(traces)
      }
    };
  }
  
  startSpan(operation: string, tags?: Record<string, any>): Span {
    const span = this.tracer.startSpan(operation, {
      tags: {
        ...tags,
        'waddle.version': process.env.VERSION,
        'waddle.environment': process.env.ENVIRONMENT
      }
    });
    
    this.spans.set(span.id, span);
    return span;
  }
  
  private analyzeOperations(traces: Trace[]): OperationMetrics[] {
    const operations = new Map<string, OperationStats>();
    
    for (const trace of traces) {
      for (const span of trace.spans) {
        const stats = operations.get(span.operation) || new OperationStats();
        stats.addSample(span.duration);
        stats.addError(span.error);
        operations.set(span.operation, stats);
      }
    }
    
    return Array.from(operations.entries()).map(([name, stats]) => ({
      name,
      count: stats.count,
      duration: {
        min: stats.min,
        max: stats.max,
        avg: stats.avg,
        p50: stats.percentile(50),
        p95: stats.percentile(95),
        p99: stats.percentile(99)
      },
      errorRate: stats.errorRate,
      throughput: stats.throughput
    }));
  }
  
  private analyzeUserFlows(traces: Trace[]): UserFlowAnalysis {
    const flows = new Map<string, FlowStats>();
    
    // Group traces by user session
    const sessions = this.groupBySession(traces);
    
    for (const [sessionId, sessionTraces] of sessions) {
      const flow = this.extractUserFlow(sessionTraces);
      const flowKey = flow.steps.join(' -> ');
      
      const stats = flows.get(flowKey) || new FlowStats();
      stats.addFlow(flow);
      flows.set(flowKey, stats);
    }
    
    // Find critical paths
    const criticalPaths = this.identifyCriticalPaths(flows);
    
    return {
      commonFlows: this.getTopFlows(flows, 10),
      criticalPaths,
      dropoffPoints: this.identifyDropoffPoints(flows),
      conversionFunnels: this.analyzeFunnels(flows)
    };
  }
}

// Real User Monitoring
export class RUMCollector implements MetricCollector {
  private sessions: Map<string, UserSession> = new Map();
  
  constructor(private config: RUMConfig) {
    this.initializeCollection();
  }
  
  private initializeCollection() {
    // Inject RUM script
    this.injectRUMScript();
    
    // Set up data collection endpoint
    this.setupEndpoint();
  }
  
  async collect(): Promise<RUMMetrics> {
    const activeSessions = this.getActiveSessions();
    
    return {
      pageLoad: this.analyzePageLoad(activeSessions),
      interactions: this.analyzeInteractions(activeSessions),
      resources: this.analyzeResources(activeSessions),
      errors: this.analyzeErrors(activeSessions),
      devices: this.analyzeDevices(activeSessions),
      geography: this.analyzeGeography(activeSessions),
      userExperience: this.calculateUXMetrics(activeSessions)
    };
  }
  
  private analyzePageLoad(sessions: UserSession[]): PageLoadMetrics {
    const samples = sessions.flatMap(s => s.pageLoads);
    
    return {
      count: samples.length,
      timing: {
        dns: this.aggregateTiming(samples, 'dns'),
        tcp: this.aggregateTiming(samples, 'tcp'),
        ttfb: this.aggregateTiming(samples, 'ttfb'),
        domContentLoaded: this.aggregateTiming(samples, 'domContentLoaded'),
        load: this.aggregateTiming(samples, 'load'),
        firstPaint: this.aggregateTiming(samples, 'firstPaint'),
        firstContentfulPaint: this.aggregateTiming(samples, 'firstContentfulPaint'),
        largestContentfulPaint: this.aggregateTiming(samples, 'largestContentfulPaint')
      },
      coreWebVitals: {
        lcp: this.calculateWebVital(samples, 'lcp'),
        fid: this.calculateWebVital(samples, 'fid'),
        cls: this.calculateWebVital(samples, 'cls')
      }
    };
  }
  
  private calculateUXMetrics(sessions: UserSession[]): UXMetrics {
    return {
      apdex: this.calculateApdex(sessions),
      frustrationIndex: this.calculateFrustrationIndex(sessions),
      engagementScore: this.calculateEngagementScore(sessions),
      satisfactionScore: this.calculateSatisfactionScore(sessions),
      recommendations: this.generateUXRecommendations(sessions)
    };
  }
  
  private calculateApdex(sessions: UserSession[]): number {
    const threshold = 2000; // 2 seconds
    let satisfied = 0;
    let tolerating = 0;
    let total = 0;
    
    for (const session of sessions) {
      for (const interaction of session.interactions) {
        total++;
        if (interaction.duration <= threshold) {
          satisfied++;
        } else if (interaction.duration <= threshold * 4) {
          tolerating++;
        }
      }
    }
    
    return (satisfied + tolerating / 2) / total;
  }
  
  private calculateFrustrationIndex(sessions: UserSession[]): number {
    const frustrationSignals = [
      'rage_click',
      'dead_click',
      'error_click',
      'form_abandonment',
      'rapid_scrolling'
    ];
    
    let frustrationCount = 0;
    let totalInteractions = 0;
    
    for (const session of sessions) {
      for (const interaction of session.interactions) {
        totalInteractions++;
        if (frustrationSignals.includes(interaction.type)) {
          frustrationCount++;
        }
      }
    }
    
    return frustrationCount / totalInteractions;
  }
}
```

### 2. WebRTC Quality Monitoring
```typescript
// WebRTC performance monitoring
export class WebRTCQualityMonitor {
  private qualityTrackers: Map<string, QualityTracker> = new Map();
  private metricsBuffer: CircularBuffer<WebRTCMetrics>;
  
  constructor(
    private config: WebRTCMonitorConfig,
    private alerting: AlertingService
  ) {
    this.metricsBuffer = new CircularBuffer(10000);
  }
  
  async trackConnection(connectionId: string, stats: RTCStatsReport): Promise<void> {
    const tracker = this.getOrCreateTracker(connectionId);
    const metrics = await this.extractMetrics(stats);
    
    // Update tracker
    tracker.addMetrics(metrics);
    
    // Buffer for analysis
    this.metricsBuffer.add({
      connectionId,
      timestamp: Date.now(),
      ...metrics
    });
    
    // Check quality thresholds
    const quality = this.assessQuality(metrics);
    if (quality.score < this.config.qualityThreshold) {
      await this.handlePoorQuality(connectionId, quality);
    }
  }
  
  private async extractMetrics(stats: RTCStatsReport): Promise<ConnectionMetrics> {
    const metrics: ConnectionMetrics = {
      audio: { sent: {}, received: {} },
      video: { sent: {}, received: {} },
      connection: {},
      quality: {}
    };
    
    stats.forEach(stat => {
      switch (stat.type) {
        case 'inbound-rtp':
          this.processInboundRTP(stat, metrics);
          break;
          
        case 'outbound-rtp':
          this.processOutboundRTP(stat, metrics);
          break;
          
        case 'candidate-pair':
          this.processCandidatePair(stat, metrics);
          break;
          
        case 'transport':
          this.processTransport(stat, metrics);
          break;
      }
    });
    
    // Calculate quality metrics
    metrics.quality = this.calculateQualityMetrics(metrics);
    
    return metrics;
  }
  
  private calculateQualityMetrics(metrics: ConnectionMetrics): QualityMetrics {
    const audio = metrics.audio;
    const video = metrics.video;
    
    return {
      // Audio quality
      audioMOS: this.calculateMOS(
        audio.received.packetsLost || 0,
        audio.received.packetsReceived || 1,
        audio.received.jitter || 0,
        metrics.connection.rtt || 0
      ),
      
      // Video quality
      videoMOS: video.received.packetsReceived ? this.calculateMOS(
        video.received.packetsLost || 0,
        video.received.packetsReceived || 1,
        video.received.jitter || 0,
        metrics.connection.rtt || 0
      ) : null,
      
      // Overall quality score
      overall: this.calculateOverallQuality(metrics),
      
      // Issues detected
      issues: this.detectIssues(metrics)
    };
  }
  
  private calculateMOS(lost: number, received: number, jitter: number, rtt: number): number {
    // E-Model calculation for VoIP quality
    const lossRate = lost / (lost + received);
    const effectiveLatency = rtt + jitter * 2;
    
    // R-Factor calculation
    let R = 93.2; // Base R-factor
    
    // Delay impairment
    if (effectiveLatency > 177.3) {
      R -= (effectiveLatency - 177.3) * 0.5;
    }
    
    // Packet loss impairment
    R -= 2.5 * lossRate * 100;
    
    // Jitter impairment
    R -= Math.min(jitter * 0.1, 10);
    
    // Convert to MOS (1-5 scale)
    let mos: number;
    if (R < 0) {
      mos = 1;
    } else if (R > 100) {
      mos = 4.5;
    } else {
      mos = 1 + 0.035 * R + 0.000007 * R * (R - 60) * (100 - R);
    }
    
    return Math.round(mos * 10) / 10;
  }
  
  private detectIssues(metrics: ConnectionMetrics): QualityIssue[] {
    const issues: QualityIssue[] = [];
    
    // High packet loss
    if (metrics.audio.received.lossRate > 0.02) {
      issues.push({
        type: 'high_packet_loss',
        severity: metrics.audio.received.lossRate > 0.05 ? 'high' : 'medium',
        media: 'audio',
        value: metrics.audio.received.lossRate,
        threshold: 0.02,
        impact: 'Audio quality degradation'
      });
    }
    
    // High jitter
    if (metrics.audio.received.jitter > 30) {
      issues.push({
        type: 'high_jitter',
        severity: metrics.audio.received.jitter > 50 ? 'high' : 'medium',
        media: 'audio',
        value: metrics.audio.received.jitter,
        threshold: 30,
        impact: 'Audio stuttering'
      });
    }
    
    // High latency
    if (metrics.connection.rtt > 300) {
      issues.push({
        type: 'high_latency',
        severity: metrics.connection.rtt > 500 ? 'high' : 'medium',
        media: 'connection',
        value: metrics.connection.rtt,
        threshold: 300,
        impact: 'Noticeable delay in conversation'
      });
    }
    
    // Low bitrate
    if (metrics.video.sent.bitrate < 500000 && metrics.video.sent.frameRate > 0) {
      issues.push({
        type: 'low_bitrate',
        severity: 'medium',
        media: 'video',
        value: metrics.video.sent.bitrate,
        threshold: 500000,
        impact: 'Poor video quality'
      });
    }
    
    return issues;
  }
  
  async generateQualityReport(timeRange: TimeRange): Promise<QualityReport> {
    const metrics = this.metricsBuffer.getInRange(timeRange);
    
    return {
      summary: {
        totalConnections: new Set(metrics.map(m => m.connectionId)).size,
        avgAudioMOS: this.average(metrics.map(m => m.quality.audioMOS)),
        avgVideoMOS: this.average(metrics.filter(m => m.quality.videoMOS).map(m => m.quality.videoMOS!)),
        qualityDistribution: this.calculateQualityDistribution(metrics)
      },
      issues: {
        byType: this.groupIssuesByType(metrics),
        bySeverity: this.groupIssuesBySeverity(metrics),
        trends: this.analyzeIssueTrends(metrics)
      },
      recommendations: this.generateRecommendations(metrics),
      regionAnalysis: this.analyzeByRegion(metrics)
    };
  }
}
```

### 3. Synthetic Monitoring
```typescript
// Synthetic monitoring for proactive detection
export class SyntheticMonitor {
  private monitors: Map<string, SyntheticTest> = new Map();
  private scheduler: TestScheduler;
  private executor: TestExecutor;
  
  constructor(
    private config: SyntheticConfig,
    private alerting: AlertingService
  ) {
    this.scheduler = new TestScheduler();
    this.executor = new TestExecutor();
    this.initializeMonitors();
  }
  
  private initializeMonitors() {
    // API endpoint monitoring
    this.monitors.set('api_health', new APIHealthTest({
      endpoints: [
        { url: '/api/health', expectedStatus: 200, timeout: 5000 },
        { url: '/api/waddles', method: 'GET', auth: true, timeout: 10000 },
        { url: '/api/messages', method: 'POST', auth: true, payload: { test: true } }
      ],
      interval: 60000, // 1 minute
      locations: ['us-east', 'eu-west', 'asia-pacific']
    }));
    
    // WebSocket connectivity
    this.monitors.set('websocket', new WebSocketTest({
      endpoints: [
        'wss://api.waddle.chat/ws',
        'wss://rtc.waddle.chat/signal'
      ],
      testMessages: [
        { type: 'ping' },
        { type: 'subscribe', channel: 'test' }
      ],
      timeout: 30000,
      interval: 300000 // 5 minutes
    }));
    
    // User journey testing
    this.monitors.set('user_journey', new UserJourneyTest({
      scenarios: [
        {
          name: 'join_waddle',
          steps: [
            { action: 'navigate', url: '/' },
            { action: 'click', selector: '#join-waddle' },
            { action: 'fill', selector: '#waddle-code', value: 'TEST123' },
            { action: 'click', selector: '#join-button' },
            { action: 'wait', selector: '.waddle-home', timeout: 10000 }
          ]
        },
        {
          name: 'send_message',
          steps: [
            { action: 'navigate', url: '/waddle/test' },
            { action: 'fill', selector: '.message-input', value: 'Test message' },
            { action: 'press', key: 'Enter' },
            { action: 'wait', selector: '.message-sent', timeout: 5000 }
          ]
        }
      ],
      browsers: ['chrome', 'firefox', 'safari'],
      interval: 900000 // 15 minutes
    }));
    
    // WebRTC connectivity
    this.monitors.set('webrtc_connectivity', new WebRTCTest({
      scenarios: [
        {
          name: 'peer_connection',
          steps: [
            'create_offer',
            'set_local_description',
            'exchange_ice_candidates',
            'establish_connection',
            'send_data',
            'verify_data_received'
          ]
        }
      ],
      stunServers: ['stun:stun.waddle.chat:3478'],
      turnServers: ['turn:turn.waddle.chat:3478'],
      timeout: 60000,
      interval: 600000 // 10 minutes
    }));
  }
  
  async runTest(testName: string): Promise<TestResult> {
    const test = this.monitors.get(testName);
    if (!test) throw new Error(`Unknown test: ${testName}`);
    
    const startTime = Date.now();
    const results: LocationResult[] = [];
    
    // Run from multiple locations
    for (const location of test.config.locations || ['default']) {
      try {
        const locationResult = await this.executor.execute(test, location);
        results.push(locationResult);
      } catch (error) {
        results.push({
          location,
          success: false,
          error: error.message,
          duration: Date.now() - startTime
        });
      }
    }
    
    // Analyze results
    const analysis = this.analyzeResults(results);
    
    // Check for failures
    if (analysis.failureRate > 0) {
      await this.handleTestFailure(testName, analysis);
    }
    
    return {
      testName,
      timestamp: startTime,
      duration: Date.now() - startTime,
      results,
      analysis
    };
  }
  
  private analyzeResults(results: LocationResult[]): TestAnalysis {
    const successful = results.filter(r => r.success).length;
    const total = results.length;
    
    return {
      successRate: successful / total,
      failureRate: (total - successful) / total,
      avgDuration: this.average(results.map(r => r.duration)),
      locations: {
        successful: results.filter(r => r.success).map(r => r.location),
        failed: results.filter(r => !r.success).map(r => r.location)
      },
      issues: this.identifyIssues(results)
    };
  }
}

// User journey testing
export class UserJourneyTest extends SyntheticTest {
  private browser: Browser;
  
  async execute(scenario: UserJourneyScenario): Promise<JourneyResult> {
    const context = await this.browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'SyntheticMonitor/1.0'
    });
    
    const page = await context.newPage();
    const metrics: StepMetric[] = [];
    
    try {
      for (const step of scenario.steps) {
        const stepStart = Date.now();
        
        try {
          await this.executeStep(page, step);
          
          metrics.push({
            step: step.action,
            success: true,
            duration: Date.now() - stepStart,
            metrics: await this.captureMetrics(page)
          });
        } catch (error) {
          metrics.push({
            step: step.action,
            success: false,
            duration: Date.now() - stepStart,
            error: error.message
          });
          
          // Take screenshot on failure
          await page.screenshot({
            path: `./failures/${scenario.name}_${step.action}_${Date.now()}.png`
          });
          
          throw error;
        }
      }
      
      return {
        scenario: scenario.name,
        success: true,
        duration: metrics.reduce((sum, m) => sum + m.duration, 0),
        steps: metrics,
        performance: await this.capturePerformanceMetrics(page)
      };
    } finally {
      await context.close();
    }
  }
  
  private async captureMetrics(page: Page): Promise<PageMetrics> {
    return await page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      const paint = performance.getEntriesByType('paint');
      
      return {
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        load: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: paint.find(p => p.name === 'first-paint')?.startTime,
        firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime,
        resources: performance.getEntriesByType('resource').length,
        memory: (performance as any).memory?.usedJSHeapSize
      };
    });
  }
}
```

### 4. Anomaly Detection
```typescript
// Intelligent anomaly detection
export class AnomalyDetector {
  private models: Map<string, AnomalyModel> = new Map();
  private baseline: BaselineCalculator;
  private alerting: AlertingService;
  
  constructor(
    private config: AnomalyConfig,
    private storage: TimeSeriesDatabase
  ) {
    this.baseline = new BaselineCalculator();
    this.alerting = new AlertingService();
    this.initializeModels();
  }
  
  private initializeModels() {
    // Statistical anomaly detection
    this.models.set('statistical', new StatisticalAnomalyModel({
      sensitivity: 0.95,
      windowSize: 3600000, // 1 hour
      methods: ['zscore', 'iqr', 'isolation_forest']
    }));
    
    // Machine learning based detection
    this.models.set('ml', new MLAnomalyModel({
      algorithm: 'lstm_autoencoder',
      features: ['value', 'hour', 'dayOfWeek', 'trend'],
      threshold: 0.05
    }));
    
    // Pattern-based detection
    this.models.set('pattern', new PatternAnomalyModel({
      patterns: [
        'sudden_spike',
        'gradual_degradation',
        'periodic_anomaly',
        'level_shift'
      ]
    }));
  }
  
  async detectAnomalies(
    metric: string,
    timeRange: TimeRange
  ): Promise<AnomalyResult[]> {
    const data = await this.storage.query(metric, timeRange);
    const anomalies: AnomalyResult[] = [];
    
    // Run each model
    for (const [modelName, model] of this.models) {
      const modelAnomalies = await model.detect(data);
      
      for (const anomaly of modelAnomalies) {
        anomalies.push({
          ...anomaly,
          model: modelName,
          confidence: this.calculateConfidence(anomaly, data)
        });
      }
    }
    
    // Correlate anomalies across models
    const correlated = this.correlateAnomalies(anomalies);
    
    // Filter by confidence
    const significant = correlated.filter(a => a.confidence > this.config.threshold);
    
    // Check for alerts
    for (const anomaly of significant) {
      await this.checkAlertConditions(anomaly);
    }
    
    return significant;
  }
  
  private correlateAnomalies(anomalies: AnomalyResult[]): AnomalyResult[] {
    const correlated: AnomalyResult[] = [];
    const timeWindow = 300000; // 5 minutes
    
    // Group by time window
    const groups = new Map<number, AnomalyResult[]>();
    
    for (const anomaly of anomalies) {
      const window = Math.floor(anomaly.timestamp / timeWindow);
      const group = groups.get(window) || [];
      group.push(anomaly);
      groups.set(window, group);
    }
    
    // Merge anomalies detected by multiple models
    for (const [window, group] of groups) {
      if (group.length === 1) {
        correlated.push(group[0]);
      } else {
        // Multiple models detected anomaly - increase confidence
        const merged: AnomalyResult = {
          timestamp: group[0].timestamp,
          metric: group[0].metric,
          value: group[0].value,
          expected: group[0].expected,
          deviation: group[0].deviation,
          type: this.determineAnomalyType(group),
          severity: this.calculateSeverity(group),
          confidence: Math.min(1, this.average(group.map(a => a.confidence)) * 1.5),
          models: group.map(a => a.model)
        };
        
        correlated.push(merged);
      }
    }
    
    return correlated;
  }
  
  async explainAnomaly(anomaly: AnomalyResult): Promise<AnomalyExplanation> {
    // Get context data
    const context = await this.getAnomalyContext(anomaly);
    
    // Analyze contributing factors
    const factors = await this.analyzeContributingFactors(anomaly, context);
    
    // Find similar past incidents
    const similar = await this.findSimilarAnomalies(anomaly);
    
    // Generate explanation
    return {
      summary: this.generateSummary(anomaly, factors),
      factors: factors.sort((a, b) => b.impact - a.impact),
      context: {
        relatedMetrics: context.relatedMetrics,
        events: context.events,
        changes: context.changes
      },
      similar: similar.map(s => ({
        timestamp: s.timestamp,
        resolution: s.resolution,
        duration: s.duration,
        similarity: s.similarity
      })),
      recommendations: this.generateRecommendations(anomaly, factors, similar)
    };
  }
  
  private async analyzeContributingFactors(
    anomaly: AnomalyResult,
    context: AnomalyContext
  ): Promise<ContributingFactor[]> {
    const factors: ContributingFactor[] = [];
    
    // Check for correlated metrics
    for (const related of context.relatedMetrics) {
      const correlation = this.calculateCorrelation(
        anomaly.metric,
        related.metric,
        context.timeRange
      );
      
      if (Math.abs(correlation) > 0.7) {
        factors.push({
          type: 'correlated_metric',
          name: related.metric,
          impact: Math.abs(correlation),
          description: `${related.metric} shows ${correlation > 0 ? 'similar' : 'inverse'} pattern`
        });
      }
    }
    
    // Check for recent changes
    for (const change of context.changes) {
      if (change.timestamp > anomaly.timestamp - 3600000) { // Within 1 hour
        factors.push({
          type: 'recent_change',
          name: change.type,
          impact: 0.8,
          description: `${change.type}: ${change.description}`
        });
      }
    }
    
    // Check for external events
    for (const event of context.events) {
      if (this.isEventRelated(event, anomaly)) {
        factors.push({
          type: 'external_event',
          name: event.type,
          impact: 0.6,
          description: event.description
        });
      }
    }
    
    return factors;
  }
}
```

### 5. Performance Dashboard
```typescript
// Real-time performance dashboard
export function PerformanceDashboard() {
  const [metrics, setMetrics] = useState<PerformanceMetrics>();
  const [selectedService, setSelectedService] = useState('all');
  const [timeRange, setTimeRange] = useState('1h');
  const [anomalies, setAnomalies] = useState<AnomalyResult[]>([]);
  
  useEffect(() => {
    const ws = connectToMetricsStream();
    loadInitialData();
    
    return () => ws.close();
  }, [selectedService, timeRange]);
  
  const connectToMetricsStream = () => {
    const ws = new WebSocket('wss://api.waddle.chat/metrics/stream');
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      
      if (update.type === 'metrics') {
        setMetrics(prev => mergeMetrics(prev, update.data));
      } else if (update.type === 'anomaly') {
        setAnomalies(prev => [update.anomaly, ...prev].slice(0, 50));
      }
    };
    
    return ws;
  };
  
  return (
    <div className="performance-dashboard">
      <div className="dashboard-header">
        <h1>Performance Monitoring</h1>
        <div className="controls">
          <ServiceSelector
            value={selectedService}
            onChange={setSelectedService}
          />
          <TimeRangeSelector
            value={timeRange}
            onChange={setTimeRange}
          />
        </div>
      </div>
      
      {metrics && (
        <>
          <div className="health-overview">
            <HealthScore score={metrics.health.overall} />
            <ServiceHealth services={metrics.health.services} />
            <ActiveAlerts alerts={metrics.alerts} />
          </div>
          
          <div className="metrics-grid">
            <MetricCard
              title="Response Time"
              current={metrics.responseTime.current}
              average={metrics.responseTime.avg}
              chart={<ResponseTimeChart data={metrics.responseTime.history} />}
              status={getMetricStatus(metrics.responseTime)}
            />
            
            <MetricCard
              title="Error Rate"
              current={`${(metrics.errorRate.current * 100).toFixed(2)}%`}
              threshold={`< ${(metrics.errorRate.threshold * 100).toFixed(1)}%`}
              chart={<ErrorRateChart data={metrics.errorRate.history} />}
              status={getMetricStatus(metrics.errorRate)}
            />
            
            <MetricCard
              title="Throughput"
              current={`${metrics.throughput.current.toFixed(0)} req/s`}
              peak={`Peak: ${metrics.throughput.peak.toFixed(0)}`}
              chart={<ThroughputChart data={metrics.throughput.history} />}
            />
            
            <MetricCard
              title="Active Users"
              current={metrics.activeUsers.current}
              change={metrics.activeUsers.change}
              chart={<ActiveUsersChart data={metrics.activeUsers.history} />}
            />
          </div>
          
          <div className="detailed-metrics">
            <Tabs defaultValue="apm">
              <TabsList>
                <Tab value="apm">Application Performance</Tab>
                <Tab value="rum">User Experience</Tab>
                <Tab value="webrtc">WebRTC Quality</Tab>
                <Tab value="infrastructure">Infrastructure</Tab>
                <Tab value="synthetic">Synthetic Tests</Tab>
              </TabsList>
              
              <TabContent value="apm">
                <APMDashboard metrics={metrics.apm} />
              </TabContent>
              
              <TabContent value="rum">
                <RUMDashboard metrics={metrics.rum} />
              </TabContent>
              
              <TabContent value="webrtc">
                <WebRTCDashboard metrics={metrics.webrtc} />
              </TabContent>
              
              <TabContent value="infrastructure">
                <InfrastructureDashboard metrics={metrics.infrastructure} />
              </TabContent>
              
              <TabContent value="synthetic">
                <SyntheticDashboard tests={metrics.synthetic} />
              </TabContent>
            </Tabs>
          </div>
          
          {anomalies.length > 0 && (
            <div className="anomalies-section">
              <h2>Detected Anomalies</h2>
              <AnomaliesList
                anomalies={anomalies}
                onInvestigate={investigateAnomaly}
              />
            </div>
          )}
        </>
      )}
    </div>
  );
}

// WebRTC quality dashboard component
function WebRTCDashboard({ metrics }: { metrics: WebRTCMetrics }) {
  const [selectedMetric, setSelectedMetric] = useState('mos');
  
  return (
    <div className="webrtc-dashboard">
      <div className="quality-overview">
        <QualityGauge
          title="Audio Quality"
          value={metrics.audio.mos}
          thresholds={{ excellent: 4, good: 3.5, fair: 3 }}
        />
        
        <QualityGauge
          title="Video Quality"
          value={metrics.video.mos}
          thresholds={{ excellent: 4, good: 3.5, fair: 3 }}
        />
        
        <QualityGauge
          title="Connection Quality"
          value={metrics.connection.quality}
          thresholds={{ excellent: 90, good: 75, fair: 60 }}
        />
      </div>
      
      <div className="quality-metrics">
        <MetricSelector
          value={selectedMetric}
          onChange={setSelectedMetric}
          options={[
            { value: 'mos', label: 'Quality Score (MOS)' },
            { value: 'latency', label: 'Latency' },
            { value: 'jitter', label: 'Jitter' },
            { value: 'packetLoss', label: 'Packet Loss' },
            { value: 'bitrate', label: 'Bitrate' }
          ]}
        />
        
        <TimeSeriesChart
          data={metrics[selectedMetric].history}
          yAxis={{ label: getMetricLabel(selectedMetric) }}
          thresholds={getMetricThresholds(selectedMetric)}
        />
      </div>
      
      <div className="quality-distribution">
        <h3>Quality Distribution</h3>
        <QualityHistogram
          data={metrics.qualityDistribution}
          categories={['Excellent', 'Good', 'Fair', 'Poor']}
        />
      </div>
      
      <div className="issues-summary">
        <h3>Active Issues</h3>
        <IssuesList
          issues={metrics.issues}
          onResolve={resolveIssue}
        />
      </div>
      
      <div className="regional-analysis">
        <h3>Regional Performance</h3>
        <RegionalMap
          data={metrics.regional}
          metric={selectedMetric}
        />
      </div>
    </div>
  );
}

// Performance alerts configuration
export class PerformanceAlertConfig {
  getDefaultAlerts(): AlertRule[] {
    return [
      {
        name: 'high_response_time',
        metric: 'response_time_p95',
        condition: 'greater_than',
        threshold: 1000, // 1 second
        duration: 300000, // 5 minutes
        severity: 'warning'
      },
      {
        name: 'critical_error_rate',
        metric: 'error_rate',
        condition: 'greater_than',
        threshold: 0.05, // 5%
        duration: 60000, // 1 minute
        severity: 'critical'
      },
      {
        name: 'webrtc_quality_degradation',
        metric: 'webrtc_mos',
        condition: 'less_than',
        threshold: 3.5,
        duration: 180000, // 3 minutes
        severity: 'warning'
      },
      {
        name: 'memory_leak_detection',
        metric: 'memory_usage_trend',
        condition: 'increasing',
        threshold: 0.1, // 10% per hour
        duration: 3600000, // 1 hour
        severity: 'warning'
      }
    ];
  }
}
```

## Dependencies
- OpenTelemetry for distributed tracing
- Prometheus for metrics collection
- Grafana for visualization
- ElasticSearch for log aggregation
- Machine learning libraries for anomaly detection

## Estimated Effort
**5 days**
- 1 day: Core monitoring infrastructure
- 1 day: APM and RUM implementation
- 1 day: WebRTC quality monitoring
- 1 day: Synthetic monitoring and anomaly detection
- 1 day: Dashboard and alerting

## Notes
- Implement sampling for high-volume metrics
- Use edge computing for regional monitoring
- Set up data retention policies
- Regular calibration of anomaly models
- Integration with incident management