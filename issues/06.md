# Issue #06: Message Flow Implementation

## User Story
As a **user**, I want to **send and receive messages seamlessly** so that **I can communicate without delays or lost messages**.

## Description
Implement the core message flow pipeline from client input through WebSocket to Durable Objects and finally to D1 storage. This includes message validation, broadcasting, and persistence with proper error handling.

## Acceptance Criteria
- [ ] Messages sent via WebSocket are delivered to all participants
- [ ] Messages are persisted to D1 within 1 second
- [ ] Failed messages are retried with exponential backoff
- [ ] Duplicate messages are prevented (idempotency)
- [ ] Message order is preserved within channels
- [ ] Offline messages are queued and delivered on reconnect
- [ ] Message delivery receipts are implemented

## Technical Implementation

### 1. Message Flow Architecture
```
Client → WebSocket → Durable Object → Broadcast → D1 Storage
                           ↓
                    Other Clients ← Push Updates
```

### 2. Client Message Sending
```typescript
// TypeScript client implementation
interface Message {
  id: string;
  channelId: string;
  content: string;
  threadId?: string;
  replyToId?: string;
  attachments?: Attachment[];
}

class MessageSender {
  private pendingMessages = new Map<string, Message>();
  private messageQueue: Message[] = [];
  
  async sendMessage(content: string, options?: MessageOptions): Promise<void> {
    const message: Message = {
      id: generateUUID(), // Client-generated for idempotency
      channelId: this.currentChannel.id,
      content,
      threadId: options?.threadId,
      replyToId: options?.replyToId,
      attachments: options?.attachments
    };
    
    // Optimistic UI update
    this.ui.addMessage({
      ...message,
      status: 'pending',
      timestamp: Date.now()
    });
    
    // Add to pending
    this.pendingMessages.set(message.id, message);
    
    try {
      await this.sendViaWebSocket(message);
    } catch (error) {
      // Queue for retry
      this.messageQueue.push(message);
      this.scheduleRetry();
    }
  }
  
  private async sendViaWebSocket(message: Message): Promise<void> {
    if (this.ws.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected');
    }
    
    this.ws.send(JSON.stringify({
      type: 'message',
      message,
      clientId: this.clientId,
      timestamp: Date.now()
    }));
    
    // Set timeout for acknowledgment
    setTimeout(() => {
      if (this.pendingMessages.has(message.id)) {
        this.handleMessageTimeout(message);
      }
    }, 5000);
  }
}
```

### 3. Durable Object Message Handler
```javascript
export class ChannelDurableObject {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.messageBuffer = [];
    this.flushInterval = null;
  }
  
  async webSocketMessage(ws, message) {
    const data = JSON.parse(message);
    const attachment = ws.deserializeAttachment();
    
    if (data.type === 'message') {
      await this.handleIncomingMessage(ws, data.message, attachment);
    }
  }
  
  async handleIncomingMessage(senderWs, message, senderInfo) {
    // Validate message
    const validation = await this.validateMessage(message, senderInfo);
    if (!validation.valid) {
      senderWs.send(JSON.stringify({
        type: 'error',
        messageId: message.id,
        error: validation.error
      }));
      return;
    }
    
    // Check for duplicates (idempotency)
    const isDuplicate = await this.checkDuplicate(message.id);
    if (isDuplicate) {
      senderWs.send(JSON.stringify({
        type: 'ack',
        messageId: message.id
      }));
      return;
    }
    
    // Enrich message
    const enrichedMessage = {
      ...message,
      userId: senderInfo.userId,
      username: senderInfo.username,
      timestamp: Date.now(),
      editCount: 0,
      reactions: {}
    };
    
    // Add to buffer for batch persistence
    this.messageBuffer.push(enrichedMessage);
    
    // Broadcast immediately
    await this.broadcastMessage(enrichedMessage, senderWs);
    
    // Schedule flush if not already scheduled
    if (!this.flushInterval) {
      this.scheduleFlush();
    }
    
    // Send acknowledgment to sender
    senderWs.send(JSON.stringify({
      type: 'ack',
      messageId: message.id,
      timestamp: enrichedMessage.timestamp
    }));
  }
  
  async broadcastMessage(message, senderWs) {
    const broadcastData = JSON.stringify({
      type: 'message',
      message
    });
    
    const sockets = this.state.getWebSockets();
    const broadcasts = [];
    
    for (const client of sockets) {
      try {
        // Skip sender for optimistic UI
        if (client !== senderWs) {
          client.send(broadcastData);
        }
      } catch (error) {
        // Client disconnected, will be cleaned up
        console.error('Broadcast error:', error);
      }
    }
  }
  
  scheduleFlush() {
    this.flushInterval = setTimeout(() => {
      this.flushMessages();
    }, 100); // Flush every 100ms
  }
  
  async flushMessages() {
    if (this.messageBuffer.length === 0) {
      this.flushInterval = null;
      return;
    }
    
    const messages = [...this.messageBuffer];
    this.messageBuffer = [];
    
    try {
      await this.persistMessages(messages);
      
      // Update message count
      await this.updateStats(messages.length);
    } catch (error) {
      console.error('Failed to persist messages:', error);
      // Re-add to buffer for retry
      this.messageBuffer.unshift(...messages);
    }
    
    // Schedule next flush if buffer not empty
    if (this.messageBuffer.length > 0) {
      this.scheduleFlush();
    } else {
      this.flushInterval = null;
    }
  }
}
```

### 4. Message Persistence Layer
```javascript
class MessagePersistence {
  static async persistMessages(messages, waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Batch insert for efficiency
    const statements = messages.map(msg => 
      db.prepare(`
        INSERT INTO messages (
          id, channel_id, thread_id, user_id, content, 
          content_type, metadata, reply_to_id, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(
        msg.id,
        msg.channelId,
        msg.threadId || null,
        msg.userId,
        msg.content,
        msg.contentType || 'text',
        JSON.stringify(msg.metadata || {}),
        msg.replyToId || null,
        new Date(msg.timestamp).toISOString()
      )
    );
    
    // Execute batch
    await db.batch(statements);
    
    // Update thread activity if needed
    const threadUpdates = messages
      .filter(msg => msg.threadId)
      .map(msg => 
        db.prepare(`
          UPDATE threads 
          SET message_count = message_count + 1,
              last_message_at = ?
          WHERE id = ?
        `).bind(new Date(msg.timestamp).toISOString(), msg.threadId)
      );
    
    if (threadUpdates.length > 0) {
      await db.batch(threadUpdates);
    }
  }
  
  static async checkDuplicate(messageId, waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    const existing = await db.prepare(
      'SELECT id FROM messages WHERE id = ? LIMIT 1'
    ).bind(messageId).first();
    
    return !!existing;
  }
}
```

### 5. Message Validation
```javascript
class MessageValidator {
  static async validateMessage(message, senderInfo, env) {
    // Check required fields
    if (!message.id || !message.content || !message.channelId) {
      return {
        valid: false,
        error: 'Missing required fields'
      };
    }
    
    // Validate message length
    if (message.content.length > 4000) {
      return {
        valid: false,
        error: 'Message too long (max 4000 characters)'
      };
    }
    
    // Check permissions
    if (!senderInfo.permissions.includes('write')) {
      return {
        valid: false,
        error: 'No write permission in this channel'
      };
    }
    
    // Rate limiting
    const rateLimitKey = `rate:${senderInfo.userId}:${Date.now() / 1000 | 0}`;
    const count = await env.RATE_LIMITER.increment(rateLimitKey);
    
    if (count > 10) { // 10 messages per second
      return {
        valid: false,
        error: 'Rate limit exceeded'
      };
    }
    
    // Content filtering (basic)
    if (await this.containsProhibitedContent(message.content, env)) {
      return {
        valid: false,
        error: 'Message contains prohibited content'
      };
    }
    
    return { valid: true };
  }
}
```

### 6. Offline Message Queue
```javascript
class OfflineMessageQueue {
  constructor() {
    this.queue = [];
    this.isOnline = navigator.onLine;
    
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
  }
  
  async queueMessage(message) {
    // Store in IndexedDB for persistence
    await this.db.messages.add({
      ...message,
      queuedAt: Date.now(),
      attempts: 0
    });
    
    this.queue.push(message);
    
    if (this.isOnline) {
      this.processQueue();
    }
  }
  
  async processQueue() {
    while (this.queue.length > 0 && this.isOnline) {
      const message = this.queue[0];
      
      try {
        await this.sendMessage(message);
        this.queue.shift();
        await this.db.messages.delete(message.id);
      } catch (error) {
        message.attempts++;
        
        if (message.attempts >= 3) {
          // Mark as failed
          this.ui.markMessageFailed(message.id);
          this.queue.shift();
        } else {
          // Retry with backoff
          await this.delay(Math.pow(2, message.attempts) * 1000);
        }
      }
    }
  }
}
```

### 7. Message Delivery Receipts
```javascript
// Extended message flow with receipts
class MessageReceipts {
  static async markDelivered(messageId, userId, waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    await db.prepare(`
      INSERT OR IGNORE INTO message_receipts (message_id, user_id, delivered_at)
      VALUES (?, ?, CURRENT_TIMESTAMP)
    `).bind(messageId, userId).run();
  }
  
  static async markRead(messageId, userId, waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    await db.prepare(`
      UPDATE message_receipts 
      SET read_at = CURRENT_TIMESTAMP
      WHERE message_id = ? AND user_id = ?
    `).bind(messageId, userId).run();
  }
  
  static async getReceipts(messageId, waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    const receipts = await db.prepare(`
      SELECT user_id, delivered_at, read_at
      FROM message_receipts
      WHERE message_id = ?
    `).bind(messageId).all();
    
    return receipts.results;
  }
}
```

## Dependencies
- WebSocket Architecture (Issue #04)
- Database Schema (Issue #05)
- Authentication System (Issue #03)

## Estimated Effort
**5 days**
- 1 day: Client-side message handling
- 2 days: DO message processing and broadcasting
- 1 day: Persistence layer with batching
- 1 day: Offline queue and delivery receipts

## Notes
- Consider implementing message compression for large messages
- Monitor buffer sizes to prevent memory issues
- Add metrics for message latency tracking
- Plan for message archival strategy