# Issue #30: Android Voice Optimization

## User Story
As an **Android user**, I want **optimized voice chat performance** so that **I can have clear, low-latency conversations without draining my battery**.

## Description
Optimize voice chat performance on Android by implementing advanced audio processing, codec optimization, jitter buffer tuning, and battery-efficient voice transmission. This includes adaptive quality based on network conditions and device capabilities.

## Acceptance Criteria
- [ ] Optimized audio codec selection
- [ ] Adaptive bitrate based on network
- [ ] Echo cancellation tuning
- [ ] Jitter buffer optimization
- [ ] CPU/Battery usage monitoring
- [ ] Network quality adaptation
- [ ] Audio route optimization
- [ ] Voice quality metrics

## Technical Implementation

### 1. Advanced Audio Configuration
```kotlin
// Audio Configuration Manager
@Singleton
class AudioConfigurationManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val deviceProfiler: DeviceProfiler,
    private val networkMonitor: NetworkQualityMonitor
) {
    private val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
    
    fun getOptimalAudioConfig(): AudioConfig {
        val deviceProfile = deviceProfiler.getProfile()
        val networkQuality = networkMonitor.getCurrentQuality()
        
        return AudioConfig(
            sampleRate = selectOptimalSampleRate(deviceProfile),
            channelConfig = selectChannelConfig(deviceProfile),
            audioFormat = AudioFormat.ENCODING_PCM_16BIT,
            bufferSize = calculateOptimalBufferSize(deviceProfile, networkQuality),
            codecConfig = selectOptimalCodec(deviceProfile, networkQuality),
            processingConfig = getProcessingConfig(deviceProfile)
        )
    }
    
    private fun selectOptimalSampleRate(profile: DeviceProfile): Int {
        // Check native sample rate for optimal performance
        val nativeSampleRate = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            audioManager.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE)?.toIntOrNull()
        } else {
            null
        }
        
        return when {
            profile.isHighEnd && nativeSampleRate == 48000 -> 48000
            profile.isHighEnd -> 44100
            profile.isMidRange -> 16000
            else -> 8000 // Low-end devices
        }
    }
    
    private fun calculateOptimalBufferSize(
        profile: DeviceProfile,
        networkQuality: NetworkQuality
    ): Int {
        val baseBufferSize = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            audioManager.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER)?.toIntOrNull() ?: 256
        } else {
            256
        }
        
        // Adjust based on network conditions
        return when (networkQuality) {
            NetworkQuality.EXCELLENT -> baseBufferSize
            NetworkQuality.GOOD -> baseBufferSize * 2
            NetworkQuality.FAIR -> baseBufferSize * 4
            NetworkQuality.POOR -> baseBufferSize * 8
        }
    }
    
    private fun selectOptimalCodec(
        profile: DeviceProfile,
        networkQuality: NetworkQuality
    ): CodecConfig {
        return when {
            networkQuality == NetworkQuality.EXCELLENT && profile.isHighEnd -> {
                CodecConfig.OPUS_FULLBAND // 48kHz, high quality
            }
            networkQuality >= NetworkQuality.GOOD -> {
                CodecConfig.OPUS_WIDEBAND // 16kHz, good quality
            }
            networkQuality == NetworkQuality.FAIR -> {
                CodecConfig.OPUS_NARROWBAND // 8kHz, acceptable quality
            }
            else -> {
                CodecConfig.OPUS_NARROWBAND_LOW // 8kHz, low bitrate
            }
        }
    }
    
    private fun getProcessingConfig(profile: DeviceProfile): AudioProcessingConfig {
        return AudioProcessingConfig(
            echoCancellation = EchoCancellationConfig(
                enabled = true,
                mode = if (profile.isHighEnd) {
                    EchoCancellationMode.AGGRESSIVE
                } else {
                    EchoCancellationMode.MODERATE
                }
            ),
            noiseSuppression = NoiseSuppressionConfig(
                enabled = true,
                level = if (profile.isHighEnd) {
                    NoiseSuppressionLevel.HIGH
                } else {
                    NoiseSuppressionLevel.MODERATE
                }
            ),
            automaticGainControl = AutomaticGainControlConfig(
                enabled = true,
                targetLevel = -3, // dBFS
                compressionGain = 9 // dB
            ),
            voiceDetection = VoiceDetectionConfig(
                enabled = true,
                sensitivity = 0.7f
            )
        )
    }
}

// Codec configurations
enum class CodecConfig(
    val codec: String,
    val sampleRate: Int,
    val bitrate: Int,
    val complexity: Int,
    val packetLoss: Int
) {
    OPUS_FULLBAND("opus", 48000, 64000, 10, 10),
    OPUS_WIDEBAND("opus", 16000, 32000, 8, 15),
    OPUS_NARROWBAND("opus", 8000, 16000, 5, 20),
    OPUS_NARROWBAND_LOW("opus", 8000, 8000, 3, 25)
}
```

### 2. Adaptive Quality Control
```kotlin
// Adaptive Quality Controller
@Singleton
class AdaptiveQualityController @Inject constructor(
    private val webRTCManager: WebRTCManager,
    private val networkMonitor: NetworkQualityMonitor,
    private val audioConfigManager: AudioConfigurationManager,
    @ApplicationScope private val scope: CoroutineScope
) {
    private var currentQuality = VoiceQuality.MEDIUM
    private val qualityHistory = CircularBuffer<QualityMetrics>(30)
    
    init {
        startQualityMonitoring()
    }
    
    private fun startQualityMonitoring() {
        scope.launch {
            combine(
                networkMonitor.networkQuality,
                webRTCManager.connectionStats,
                audioMetricsFlow()
            ) { network, stats, audio ->
                QualityMetrics(
                    networkQuality = network,
                    rtcStats = stats,
                    audioMetrics = audio,
                    timestamp = System.currentTimeMillis()
                )
            }.collect { metrics ->
                qualityHistory.add(metrics)
                adjustQualityIfNeeded(metrics)
            }
        }
    }
    
    private fun adjustQualityIfNeeded(metrics: QualityMetrics) {
        val targetQuality = determineTargetQuality(metrics)
        
        if (targetQuality != currentQuality) {
            Log.d(TAG, "Adjusting quality from $currentQuality to $targetQuality")
            applyQualitySettings(targetQuality)
            currentQuality = targetQuality
        }
    }
    
    private fun determineTargetQuality(metrics: QualityMetrics): VoiceQuality {
        // Analyze recent history for stability
        val recentMetrics = qualityHistory.takeLast(10)
        val avgPacketLoss = recentMetrics.map { it.rtcStats.packetLossRate }.average()
        val avgJitter = recentMetrics.map { it.rtcStats.jitter }.average()
        val avgRtt = recentMetrics.map { it.rtcStats.roundTripTime }.average()
        
        return when {
            avgPacketLoss > 5.0 || avgRtt > 300 -> VoiceQuality.LOW
            avgPacketLoss > 2.0 || avgRtt > 150 -> VoiceQuality.MEDIUM
            avgPacketLoss < 1.0 && avgRtt < 100 -> VoiceQuality.HIGH
            else -> VoiceQuality.MEDIUM
        }
    }
    
    private fun applyQualitySettings(quality: VoiceQuality) {
        scope.launch {
            val config = when (quality) {
                VoiceQuality.HIGH -> QualitySettings(
                    bitrate = 64000,
                    fec = false,
                    dtx = false,
                    complexity = 10
                )
                VoiceQuality.MEDIUM -> QualitySettings(
                    bitrate = 32000,
                    fec = true,
                    dtx = true,
                    complexity = 5
                )
                VoiceQuality.LOW -> QualitySettings(
                    bitrate = 16000,
                    fec = true,
                    dtx = true,
                    complexity = 1
                )
            }
            
            webRTCManager.updateAudioSettings(config)
        }
    }
}
```

### 3. Jitter Buffer Optimization
```kotlin
// Jitter Buffer Manager
class JitterBufferManager @Inject constructor() {
    private val adaptiveJitterBuffer = AdaptiveJitterBuffer()
    
    fun configureJitterBuffer(networkConditions: NetworkConditions): JitterBufferConfig {
        val baseDelay = calculateBaseDelay(networkConditions)
        val maxDelay = calculateMaxDelay(networkConditions)
        
        return JitterBufferConfig(
            minDelay = baseDelay,
            maxDelay = maxDelay,
            targetDelay = (baseDelay + maxDelay) / 2,
            adaptiveMode = true,
            accelerationEnabled = networkConditions.jitter < 30,
            preemptiveExpansion = networkConditions.packetLoss > 2
        )
    }
    
    private fun calculateBaseDelay(conditions: NetworkConditions): Int {
        return when {
            conditions.jitter < 10 -> 20  // Excellent network
            conditions.jitter < 30 -> 40  // Good network
            conditions.jitter < 50 -> 60  // Fair network
            else -> 80                    // Poor network
        }
    }
    
    private fun calculateMaxDelay(conditions: NetworkConditions): Int {
        val baseMax = calculateBaseDelay(conditions) * 3
        
        // Add extra buffer for high packet loss scenarios
        val packetLossBuffer = if (conditions.packetLoss > 5) {
            50
        } else if (conditions.packetLoss > 2) {
            30
        } else {
            0
        }
        
        return minOf(baseMax + packetLossBuffer, 200) // Cap at 200ms
    }
}

// Adaptive Jitter Buffer implementation
class AdaptiveJitterBuffer {
    private val packetBuffer = TreeMap<Long, AudioPacket>()
    private var targetDelay = 40 // ms
    private var currentDelay = 0
    private val delayHistory = CircularBuffer<Int>(100)
    
    fun addPacket(packet: AudioPacket) {
        synchronized(packetBuffer) {
            packetBuffer[packet.timestamp] = packet
            
            // Adaptive adjustment
            adjustTargetDelay()
        }
    }
    
    fun getNextPacket(): AudioPacket? {
        synchronized(packetBuffer) {
            val now = System.currentTimeMillis()
            val targetTimestamp = now - targetDelay
            
            return packetBuffer.entries
                .firstOrNull { it.key <= targetTimestamp }
                ?.let { entry ->
                    packetBuffer.remove(entry.key)
                    entry.value
                }
        }
    }
    
    private fun adjustTargetDelay() {
        val bufferDepth = calculateBufferDepth()
        delayHistory.add(bufferDepth)
        
        if (delayHistory.size >= 50) {
            val avgDelay = delayHistory.average()
            val variance = delayHistory.variance()
            
            when {
                variance > 20 && avgDelay < targetDelay - 10 -> {
                    // High variance, reduce delay cautiously
                    targetDelay = maxOf(targetDelay - 5, 20)
                }
                variance < 10 && avgDelay > targetDelay + 20 -> {
                    // Low variance, safe to reduce delay
                    targetDelay = maxOf(targetDelay - 10, 20)
                }
                avgDelay < 10 -> {
                    // Buffer running low, increase delay
                    targetDelay = minOf(targetDelay + 10, 200)
                }
            }
        }
    }
}
```

### 4. Battery and CPU Optimization
```kotlin
// Performance Monitor
@Singleton
class VoicePerformanceMonitor @Inject constructor(
    @ApplicationContext private val context: Context,
    private val powerManager: PowerOptimizationManager,
    private val thermalMonitor: ThermalMonitor
) {
    private val cpuMonitor = CpuMonitor()
    private val batteryMonitor = BatteryMonitor(context)
    
    fun startMonitoring(): Flow<PerformanceMetrics> = flow {
        while (currentCoroutineContext().isActive) {
            val metrics = PerformanceMetrics(
                cpuUsage = cpuMonitor.getCurrentUsage(),
                batteryLevel = batteryMonitor.getBatteryLevel(),
                batteryTemperature = batteryMonitor.getTemperature(),
                thermalStatus = thermalMonitor.getThermalStatus(),
                memoryUsage = getMemoryUsage()
            )
            
            emit(metrics)
            
            // Adjust monitoring frequency based on thermal status
            val delay = when (metrics.thermalStatus) {
                ThermalStatus.NORMAL -> 5000L
                ThermalStatus.WARM -> 3000L
                ThermalStatus.HOT -> 1000L
                ThermalStatus.CRITICAL -> 500L
            }
            
            delay(delay)
        }
    }.flowOn(Dispatchers.Default)
    
    fun optimizeForPerformance(metrics: PerformanceMetrics): PerformanceOptimizations {
        return PerformanceOptimizations(
            reduceCpuUsage = metrics.cpuUsage > 60 || metrics.thermalStatus >= ThermalStatus.WARM,
            enablePowerSaving = metrics.batteryLevel < 20 && !batteryMonitor.isCharging(),
            reduceQuality = metrics.thermalStatus >= ThermalStatus.HOT,
            disableVideoProcessing = metrics.cpuUsage > 80,
            reduceAudioComplexity = metrics.memoryUsage > 80
        )
    }
}

// CPU Monitor
class CpuMonitor {
    private var lastCpuTime = 0L
    private var lastAppCpuTime = 0L
    
    fun getCurrentUsage(): Float {
        try {
            val reader = RandomAccessFile("/proc/stat", "r")
            val cpuLine = reader.readLine()
            reader.close()
            
            val cpuValues = cpuLine.split(" ")
                .drop(2)
                .take(7)
                .map { it.toLong() }
            
            val totalCpuTime = cpuValues.sum()
            val deltaCpuTime = totalCpuTime - lastCpuTime
            
            val appCpuTime = getAppCpuTime()
            val deltaAppCpuTime = appCpuTime - lastAppCpuTime
            
            lastCpuTime = totalCpuTime
            lastAppCpuTime = appCpuTime
            
            return if (deltaCpuTime > 0) {
                (deltaAppCpuTime.toFloat() / deltaCpuTime.toFloat()) * 100f
            } else {
                0f
            }
        } catch (e: Exception) {
            return 0f
        }
    }
    
    private fun getAppCpuTime(): Long {
        return try {
            val pid = android.os.Process.myPid()
            val reader = RandomAccessFile("/proc/$pid/stat", "r")
            val statLine = reader.readLine()
            reader.close()
            
            val fields = statLine.split(" ")
            fields[13].toLong() + fields[14].toLong() // utime + stime
        } catch (e: Exception) {
            0L
        }
    }
}
```

### 5. Network Adaptation
```kotlin
// Network Adaptive Controller
@Singleton
class NetworkAdaptiveController @Inject constructor(
    private val connectivityManager: ConnectivityManager,
    private val webRTCManager: WebRTCManager
) {
    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onCapabilitiesChanged(
            network: Network,
            capabilities: NetworkCapabilities
        ) {
            handleNetworkChange(capabilities)
        }
        
        override fun onLost(network: Network) {
            handleNetworkLost()
        }
    }
    
    fun startNetworkAdaptation() {
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
            
        connectivityManager.registerNetworkCallback(request, networkCallback)
    }
    
    private fun handleNetworkChange(capabilities: NetworkCapabilities) {
        val bandwidth = capabilities.linkDownstreamBandwidthKbps
        val isMetered = !capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED)
        val isCellular = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)
        
        val config = when {
            isCellular && isMetered -> {
                // Cellular metered - minimize data usage
                NetworkAdaptiveConfig(
                    maxBitrate = 16000,
                    enableFEC = true,
                    enableDTX = true,
                    videoEnabled = false
                )
            }
            bandwidth < 100 -> {
                // Very low bandwidth
                NetworkAdaptiveConfig(
                    maxBitrate = 8000,
                    enableFEC = true,
                    enableDTX = true,
                    videoEnabled = false
                )
            }
            bandwidth < 500 -> {
                // Low bandwidth
                NetworkAdaptiveConfig(
                    maxBitrate = 24000,
                    enableFEC = true,
                    enableDTX = true,
                    videoEnabled = false
                )
            }
            bandwidth < 1000 -> {
                // Medium bandwidth
                NetworkAdaptiveConfig(
                    maxBitrate = 48000,
                    enableFEC = true,
                    enableDTX = false,
                    videoEnabled = true
                )
            }
            else -> {
                // High bandwidth
                NetworkAdaptiveConfig(
                    maxBitrate = 64000,
                    enableFEC = false,
                    enableDTX = false,
                    videoEnabled = true
                )
            }
        }
        
        webRTCManager.applyNetworkConfig(config)
    }
}

// Bandwidth Estimator
class BandwidthEstimator {
    private val measurements = CircularBuffer<BandwidthMeasurement>(20)
    
    fun addMeasurement(bytesReceived: Long, duration: Long) {
        if (duration > 0) {
            val bitsPerSecond = (bytesReceived * 8 * 1000) / duration
            measurements.add(
                BandwidthMeasurement(
                    bandwidth = bitsPerSecond,
                    timestamp = System.currentTimeMillis()
                )
            )
        }
    }
    
    fun getEstimatedBandwidth(): Long {
        if (measurements.isEmpty()) return 0
        
        // Use weighted average with recent measurements having more weight
        val now = System.currentTimeMillis()
        var totalWeight = 0.0
        var weightedSum = 0.0
        
        measurements.forEach { measurement ->
            val age = now - measurement.timestamp
            val weight = 1.0 / (1.0 + age / 10000.0) // Decay over 10 seconds
            
            weightedSum += measurement.bandwidth * weight
            totalWeight += weight
        }
        
        return if (totalWeight > 0) {
            (weightedSum / totalWeight).toLong()
        } else {
            0
        }
    }
}
```

### 6. Voice Quality Metrics
```kotlin
// Voice Quality Analyzer
@Singleton
class VoiceQualityAnalyzer @Inject constructor() {
    private val metricsCollector = MetricsCollector()
    
    fun analyzeQuality(audioSamples: ShortArray): VoiceQualityMetrics {
        return VoiceQualityMetrics(
            signalLevel = calculateSignalLevel(audioSamples),
            noiseLevel = estimateNoiseLevel(audioSamples),
            snr = calculateSNR(audioSamples),
            thd = calculateTHD(audioSamples),
            clarity = estimateClarity(audioSamples)
        )
    }
    
    private fun calculateSignalLevel(samples: ShortArray): Double {
        val rms = sqrt(samples.map { it * it }.average())
        return 20 * log10(rms / Short.MAX_VALUE)
    }
    
    private fun estimateNoiseLevel(samples: ShortArray): Double {
        // Simple noise estimation using minimum statistics
        val frameSize = 256
        val frameCount = samples.size / frameSize
        val framePowers = mutableListOf<Double>()
        
        for (i in 0 until frameCount) {
            val frameStart = i * frameSize
            val frameEnd = minOf(frameStart + frameSize, samples.size)
            val frame = samples.sliceArray(frameStart until frameEnd)
            
            val power = frame.map { it * it }.average()
            framePowers.add(power)
        }
        
        // Noise level is approximately the 10th percentile
        framePowers.sort()
        val noiseIndex = (framePowers.size * 0.1).toInt()
        val noisePower = framePowers.getOrElse(noiseIndex) { framePowers.first() }
        
        return 10 * log10(noisePower / (Short.MAX_VALUE * Short.MAX_VALUE))
    }
    
    private fun calculateSNR(samples: ShortArray): Double {
        val signal = calculateSignalLevel(samples)
        val noise = estimateNoiseLevel(samples)
        return signal - noise
    }
    
    private fun calculateTHD(samples: ShortArray): Double {
        // Simplified THD calculation using FFT
        val fft = FFT(samples.size)
        val spectrum = fft.transform(samples)
        
        val fundamental = spectrum.maxBy { it.magnitude }
        val harmonics = spectrum.filter { 
            it.frequency > fundamental.frequency * 1.5 &&
            it.frequency < fundamental.frequency * 10
        }
        
        val harmonicPower = harmonics.sumOf { it.magnitude * it.magnitude }
        val fundamentalPower = fundamental.magnitude * fundamental.magnitude
        
        return sqrt(harmonicPower / fundamentalPower) * 100
    }
    
    fun generateQualityReport(): VoiceQualityReport {
        val metrics = metricsCollector.getAggregatedMetrics()
        
        return VoiceQualityReport(
            overallScore = calculateOverallScore(metrics),
            signalQuality = metrics.averageSnr > 20 ? "Excellent" : 
                           metrics.averageSnr > 10 ? "Good" : "Poor",
            networkQuality = evaluateNetworkQuality(metrics),
            recommendations = generateRecommendations(metrics)
        )
    }
}

// UI for Voice Quality Display
@Composable
fun VoiceQualityIndicator(
    quality: VoiceQualityMetrics,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = when {
                quality.overallScore > 80 -> Color.Green.copy(alpha = 0.1f)
                quality.overallScore > 60 -> Color.Yellow.copy(alpha = 0.1f)
                else -> Color.Red.copy(alpha = 0.1f)
            }
        )
    ) {
        Row(
            modifier = Modifier.padding(8.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = when {
                    quality.overallScore > 80 -> Icons.Default.SignalCellular4Bar
                    quality.overallScore > 60 -> Icons.Default.SignalCellular2Bar
                    else -> Icons.Default.SignalCellular0Bar
                },
                contentDescription = "Voice Quality",
                tint = when {
                    quality.overallScore > 80 -> Color.Green
                    quality.overallScore > 60 -> Color.Yellow
                    else -> Color.Red
                }
            )
            
            Column {
                Text(
                    text = "Voice Quality",
                    style = MaterialTheme.typography.labelMedium
                )
                Text(
                    text = "${quality.overallScore}%",
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}
```

## Dependencies
- WebRTC Android SDK
- Opus Codec
- Audio processing libraries
- Performance monitoring tools

## Estimated Effort
**5 days**
- 1 day: Advanced audio configuration
- 1 day: Adaptive quality control
- 1 day: Jitter buffer optimization
- 1 day: Performance monitoring
- 1 day: Network adaptation and metrics

## Notes
- Test on various network conditions
- Profile CPU usage on different devices
- Monitor battery impact
- Implement A/B testing for quality settings
- Consider device-specific optimizations