# Issue #16: Audio Permissions & Device Selection

## User Story
As a **user**, I want to **easily manage my audio devices and permissions** so that **I can use my preferred microphone and speakers without technical difficulties**.

## Description
Implement comprehensive audio device management including permission requests, device enumeration, selection persistence, and graceful handling of device changes. This includes both web browser permissions and OS-level audio routing.

## Acceptance Criteria
- [ ] Smooth browser permission request flow
- [ ] Clear device enumeration and labeling
- [ ] Device selection persists across sessions
- [ ] Graceful handling of device disconnection
- [ ] Audio level testing before joining
- [ ] Default device handling
- [ ] Error messages for permission denial
- [ ] Device change notifications

## Technical Implementation

### 1. Permission Request Manager
```typescript
export class AudioPermissionManager {
  private static instance: AudioPermissionManager;
  private permissionState: PermissionState = 'prompt';
  private mediaStream: MediaStream | null = null;
  
  static getInstance(): AudioPermissionManager {
    if (!this.instance) {
      this.instance = new AudioPermissionManager();
    }
    return this.instance;
  }
  
  async checkPermissions(): Promise<PermissionStatus> {
    try {
      // Check if we already have permissions
      const result = await navigator.permissions.query({ 
        name: 'microphone' as PermissionName 
      });
      
      this.permissionState = result.state;
      
      // Listen for permission changes
      result.addEventListener('change', () => {
        this.permissionState = result.state;
        this.onPermissionChange(result.state);
      });
      
      return {
        granted: result.state === 'granted',
        state: result.state,
        canRequest: result.state !== 'denied'
      };
    } catch (error) {
      // Fallback for browsers that don't support permissions API
      return this.checkPermissionsFallback();
    }
  }
  
  async requestPermissions(): Promise<RequestResult> {
    try {
      // Show custom UI explanation before request
      const shouldProceed = await this.showPermissionExplanation();
      if (!shouldProceed) {
        return { 
          success: false, 
          error: 'User cancelled permission request' 
        };
      }
      
      // Request microphone access
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      // Successfully got permissions
      this.permissionState = 'granted';
      
      // Get initial device list
      const devices = await this.enumerateDevices();
      
      return {
        success: true,
        stream: this.mediaStream,
        devices
      };
      
    } catch (error: any) {
      return this.handlePermissionError(error);
    }
  }
  
  private async showPermissionExplanation(): Promise<boolean> {
    return new Promise((resolve) => {
      const modal = new PermissionModal({
        title: 'Microphone Access Required',
        message: 'Waddle needs access to your microphone to join voice channels.',
        icon: 'microphone',
        actions: [
          {
            label: 'Grant Access',
            action: () => resolve(true),
            primary: true
          },
          {
            label: 'Not Now',
            action: () => resolve(false)
          }
        ]
      });
      
      modal.show();
    });
  }
  
  private handlePermissionError(error: DOMException): RequestResult {
    const errorMap: Record<string, string> = {
      'NotAllowedError': 'Microphone access was denied',
      'NotFoundError': 'No microphone found',
      'NotReadableError': 'Microphone is already in use',
      'OverconstrainedError': 'No microphone meets the requirements',
      'SecurityError': 'Microphone access is not allowed in this context'
    };
    
    const userMessage = errorMap[error.name] || 'Failed to access microphone';
    
    // Show user-friendly error
    this.showErrorNotification(userMessage, error.name);
    
    return {
      success: false,
      error: userMessage,
      errorCode: error.name,
      canRetry: error.name !== 'NotAllowedError'
    };
  }
  
  async releasePermissions(): Promise<void> {
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach(track => track.stop());
      this.mediaStream = null;
    }
  }
}
```

### 2. Device Enumeration and Management
```typescript
export class AudioDeviceManager {
  private devices: Map<string, MediaDeviceInfo> = new Map();
  private currentInput: string | null = null;
  private currentOutput: string | null = null;
  private deviceChangeListeners: Set<DeviceChangeListener> = new Set();
  
  constructor() {
    this.initializeDeviceMonitoring();
  }
  
  private initializeDeviceMonitoring(): void {
    // Monitor device changes
    navigator.mediaDevices.addEventListener('devicechange', async () => {
      await this.refreshDeviceList();
      this.notifyDeviceChange();
    });
  }
  
  async enumerateDevices(): Promise<DeviceList> {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      
      const audioInputs: AudioDevice[] = [];
      const audioOutputs: AudioDevice[] = [];
      
      devices.forEach(device => {
        // Store raw device info
        this.devices.set(device.deviceId, device);
        
        // Create user-friendly device object
        const audioDevice: AudioDevice = {
          id: device.deviceId,
          label: this.getDeviceLabel(device),
          kind: device.kind,
          isDefault: device.deviceId === 'default',
          groupId: device.groupId
        };
        
        if (device.kind === 'audioinput') {
          audioInputs.push(audioDevice);
        } else if (device.kind === 'audiooutput') {
          audioOutputs.push(audioDevice);
        }
      });
      
      return {
        inputs: this.sortDevices(audioInputs),
        outputs: this.sortDevices(audioOutputs),
        hasPermissions: this.hasRealDeviceLabels(devices)
      };
      
    } catch (error) {
      console.error('Failed to enumerate devices:', error);
      return { inputs: [], outputs: [], hasPermissions: false };
    }
  }
  
  private getDeviceLabel(device: MediaDeviceInfo): string {
    // Handle cases where labels aren't available
    if (!device.label) {
      if (device.kind === 'audioinput') {
        return `Microphone ${device.deviceId.slice(0, 8)}`;
      } else {
        return `Speaker ${device.deviceId.slice(0, 8)}`;
      }
    }
    
    // Clean up common device label patterns
    return device.label
      .replace(/\s*\(.*?\)\s*$/, '') // Remove text in parentheses
      .replace(/^(USB\s+|HD\s+|Webcam\s+)/i, '') // Remove common prefixes
      .trim();
  }
  
  private sortDevices(devices: AudioDevice[]): AudioDevice[] {
    return devices.sort((a, b) => {
      // Default devices first
      if (a.isDefault && !b.isDefault) return -1;
      if (!a.isDefault && b.isDefault) return 1;
      
      // Then sort alphabetically
      return a.label.localeCompare(b.label);
    });
  }
  
  async selectInputDevice(deviceId: string): Promise<SelectionResult> {
    try {
      // Validate device exists
      if (!this.devices.has(deviceId) && deviceId !== 'default') {
        throw new Error('Device not found');
      }
      
      // Test device by getting stream
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: { exact: deviceId },
          echoCancellation: true,
          noiseSuppression: true
        }
      });
      
      // Success - update current device
      this.currentInput = deviceId;
      
      // Save preference
      await this.saveDevicePreference('input', deviceId);
      
      // Return stream for immediate use
      return {
        success: true,
        stream,
        device: this.devices.get(deviceId) || null
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Failed to select input device',
        details: error
      };
    }
  }
  
  async selectOutputDevice(deviceId: string): Promise<SelectionResult> {
    try {
      // Check if setSinkId is supported
      if (!('setSinkId' in HTMLAudioElement.prototype)) {
        throw new Error('Audio output selection not supported');
      }
      
      // Test with dummy audio element
      const audio = new Audio();
      await (audio as any).setSinkId(deviceId);
      
      // Success - update current device
      this.currentOutput = deviceId;
      
      // Save preference
      await this.saveDevicePreference('output', deviceId);
      
      return {
        success: true,
        device: this.devices.get(deviceId) || null
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Failed to select output device',
        details: error
      };
    }
  }
  
  private async saveDevicePreference(type: 'input' | 'output', deviceId: string): Promise<void> {
    const preferences = {
      ...await this.loadDevicePreferences(),
      [`audio${type.charAt(0).toUpperCase() + type.slice(1)}`]: deviceId
    };
    
    localStorage.setItem('waddle_audio_preferences', JSON.stringify(preferences));
  }
  
  async loadDevicePreferences(): Promise<DevicePreferences> {
    try {
      const saved = localStorage.getItem('waddle_audio_preferences');
      return saved ? JSON.parse(saved) : {};
    } catch {
      return {};
    }
  }
}
```

### 3. Audio Level Testing
```typescript
export class AudioLevelTester {
  private analyser: AnalyserNode | null = null;
  private microphone: MediaStreamAudioSourceNode | null = null;
  private rafId: number | null = null;
  private levelCallback: ((level: number) => void) | null = null;
  
  async startTest(stream: MediaStream, onLevel: (level: number) => void): Promise<void> {
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    
    // Create analyser node
    this.analyser = audioContext.createAnalyser();
    this.analyser.fftSize = 256;
    this.analyser.smoothingTimeConstant = 0.8;
    
    // Connect microphone to analyser
    this.microphone = audioContext.createMediaStreamSource(stream);
    this.microphone.connect(this.analyser);
    
    // Set callback
    this.levelCallback = onLevel;
    
    // Start monitoring
    this.monitorLevel();
  }
  
  private monitorLevel(): void {
    if (!this.analyser || !this.levelCallback) return;
    
    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteFrequencyData(dataArray);
    
    // Calculate average level
    const sum = dataArray.reduce((a, b) => a + b, 0);
    const average = sum / dataArray.length;
    const normalizedLevel = Math.min(100, (average / 255) * 100);
    
    this.levelCallback(normalizedLevel);
    
    // Continue monitoring
    this.rafId = requestAnimationFrame(() => this.monitorLevel());
  }
  
  stopTest(): void {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    
    if (this.microphone) {
      this.microphone.disconnect();
      this.microphone = null;
    }
    
    this.analyser = null;
    this.levelCallback = null;
  }
}

// React component for testing
export function AudioTestComponent() {
  const [isTestting, setIsTesting] = useState(false);
  const [audioLevel, setAudioLevel] = useState(0);
  const [selectedDevice, setSelectedDevice] = useState<string>('default');
  const tester = useRef<AudioLevelTester>(new AudioLevelTester());
  
  const startTest = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { deviceId: { exact: selectedDevice } }
      });
      
      setIsTesting(true);
      await tester.current.startTest(stream, setAudioLevel);
      
      // Play test sound for output
      await playTestSound(selectedDevice);
      
    } catch (error) {
      console.error('Test failed:', error);
    }
  };
  
  const stopTest = () => {
    tester.current.stopTest();
    setIsTesting(false);
    setAudioLevel(0);
  };
  
  return (
    <div className="audio-test">
      <div className="test-controls">
        <Button
          onClick={isTestting ? stopTest : startTest}
          variant={isTestting ? 'danger' : 'primary'}
        >
          {isTestting ? 'Stop Test' : 'Test Audio'}
        </Button>
      </div>
      
      <div className="level-meter">
        <div className="level-label">Microphone Level</div>
        <div className="level-bar-container">
          <div 
            className="level-bar-fill"
            style={{ width: `${audioLevel}%` }}
          />
        </div>
        <div className="level-status">
          {audioLevel > 60 ? 'ðŸŸ¢ Good' : 
           audioLevel > 20 ? 'ðŸŸ¡ Low' : 
           'ðŸ”´ Very Low'}
        </div>
      </div>
      
      {isTestting && (
        <div className="test-hint">
          Speak into your microphone to test the levels
        </div>
      )}
    </div>
  );
}
```

### 4. Device Change Handling
```typescript
export class DeviceChangeHandler {
  private notificationQueue: DeviceNotification[] = [];
  private isShowingNotification = false;
  
  async handleDeviceRemoved(device: MediaDeviceInfo): Promise<void> {
    // Check if it was the active device
    const { currentInput, currentOutput } = await this.getCurrentDevices();
    
    if (device.deviceId === currentInput || device.deviceId === currentOutput) {
      // Active device was removed
      await this.handleActiveDeviceRemoval(device);
    } else {
      // Just notify
      this.queueNotification({
        type: 'device_removed',
        device,
        message: `${device.label || 'Audio device'} was disconnected`
      });
    }
  }
  
  async handleActiveDeviceRemoval(device: MediaDeviceInfo): Promise<void> {
    // Find replacement device
    const devices = await this.deviceManager.enumerateDevices();
    const replacements = device.kind === 'audioinput' ? devices.inputs : devices.outputs;
    
    if (replacements.length > 0) {
      // Auto-switch to default or first available
      const replacement = replacements.find(d => d.isDefault) || replacements[0];
      
      await this.switchToDevice(replacement, device.kind);
      
      this.queueNotification({
        type: 'device_switched',
        oldDevice: device,
        newDevice: replacement,
        message: `Switched to ${replacement.label}`,
        action: {
          label: 'Change',
          onClick: () => this.openDeviceSettings()
        }
      });
    } else {
      // No devices available
      this.queueNotification({
        type: 'no_device',
        device,
        message: `No ${device.kind === 'audioinput' ? 'microphone' : 'speaker'} available`,
        severity: 'error'
      });
      
      // Disconnect from voice if in call
      if (this.voiceManager.isConnected()) {
        await this.voiceManager.disconnect();
      }
    }
  }
  
  async handleNewDevice(device: MediaDeviceInfo): Promise<void> {
    // Check if user has no current device
    const { currentInput, currentOutput } = await this.getCurrentDevices();
    
    if ((device.kind === 'audioinput' && !currentInput) ||
        (device.kind === 'audiooutput' && !currentOutput)) {
      // Suggest using the new device
      this.queueNotification({
        type: 'new_device',
        device,
        message: `New ${device.kind === 'audioinput' ? 'microphone' : 'speaker'} detected`,
        action: {
          label: 'Use This Device',
          onClick: () => this.switchToDevice(device, device.kind)
        }
      });
    }
  }
  
  private async showNotificationQueue(): Promise<void> {
    if (this.isShowingNotification || this.notificationQueue.length === 0) {
      return;
    }
    
    this.isShowingNotification = true;
    const notification = this.notificationQueue.shift()!;
    
    await this.showNotification(notification);
    
    this.isShowingNotification = false;
    
    // Show next if any
    if (this.notificationQueue.length > 0) {
      setTimeout(() => this.showNotificationQueue(), 500);
    }
  }
}
```

### 5. Permission Recovery Strategies
```typescript
export class PermissionRecovery {
  static strategies = {
    denied: {
      message: 'Microphone access was denied',
      steps: [
        'Click the lock icon in your browser\'s address bar',
        'Find "Microphone" in the permissions',
        'Change it from "Blocked" to "Allow"',
        'Refresh the page'
      ],
      showSystemSettings: true
    },
    
    inUse: {
      message: 'Your microphone is being used by another application',
      steps: [
        'Close other applications that might be using your microphone',
        'Check if you\'re in another call or meeting',
        'Try disconnecting and reconnecting your microphone'
      ],
      canRetry: true,
      retryDelay: 2000
    },
    
    notFound: {
      message: 'No microphone detected',
      steps: [
        'Check if your microphone is properly connected',
        'Try unplugging and reconnecting your microphone',
        'Check your system sound settings',
        'Make sure your microphone is not muted at the hardware level'
      ],
      showSystemSettings: true
    }
  };
  
  static async attemptRecovery(
    error: PermissionError, 
    onProgress?: (step: string) => void
  ): Promise<RecoveryResult> {
    const strategy = this.strategies[error.type];
    if (!strategy) {
      return { recovered: false, error: 'No recovery strategy available' };
    }
    
    // Show recovery UI
    const recovery = new RecoveryModal({
      error,
      strategy,
      onProgress
    });
    
    const result = await recovery.show();
    
    if (result.action === 'retry' && strategy.canRetry) {
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, strategy.retryDelay || 0));
      
      // Attempt to get permissions again
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        return { recovered: true, stream };
      } catch (retryError) {
        return { recovered: false, error: 'Retry failed' };
      }
    }
    
    if (result.action === 'settings' && strategy.showSystemSettings) {
      // Open system settings
      await this.openSystemAudioSettings();
      return { recovered: false, userAction: 'opened_settings' };
    }
    
    return { recovered: false, userCancelled: true };
  }
  
  static async openSystemAudioSettings(): Promise<void> {
    const platform = this.detectPlatform();
    
    const urls: Record<string, string> = {
      'windows': 'ms-settings:sound',
      'macos': 'x-apple.systempreferences:com.apple.preference.sound',
      'linux': 'unity-control-center sound'
    };
    
    if (urls[platform]) {
      window.location.href = urls[platform];
    } else {
      // Fallback - show instructions
      this.showManualInstructions(platform);
    }
  }
}
```

### 6. React Hooks for Device Management
```typescript
export function useAudioDevices() {
  const [devices, setDevices] = useState<DeviceList>({ 
    inputs: [], 
    outputs: [], 
    hasPermissions: false 
  });
  const [currentInput, setCurrentInput] = useState<string>('default');
  const [currentOutput, setCurrentOutput] = useState<string>('default');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const deviceManager = useRef(new AudioDeviceManager());
  const permissionManager = useRef(AudioPermissionManager.getInstance());
  
  useEffect(() => {
    initializeDevices();
    
    // Listen for device changes
    const handleDeviceChange = () => {
      refreshDevices();
    };
    
    deviceManager.current.addChangeListener(handleDeviceChange);
    
    return () => {
      deviceManager.current.removeChangeListener(handleDeviceChange);
    };
  }, []);
  
  const initializeDevices = async () => {
    try {
      setLoading(true);
      
      // Check permissions
      const permissionStatus = await permissionManager.current.checkPermissions();
      
      if (!permissionStatus.granted && permissionStatus.canRequest) {
        // Need to request permissions
        const result = await permissionManager.current.requestPermissions();
        if (!result.success) {
          setError(result.error);
          return;
        }
      }
      
      // Load saved preferences
      const preferences = await deviceManager.current.loadDevicePreferences();
      if (preferences.audioInput) setCurrentInput(preferences.audioInput);
      if (preferences.audioOutput) setCurrentOutput(preferences.audioOutput);
      
      // Enumerate devices
      await refreshDevices();
      
    } catch (err) {
      setError('Failed to initialize audio devices');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };
  
  const refreshDevices = async () => {
    const deviceList = await deviceManager.current.enumerateDevices();
    setDevices(deviceList);
    
    // Validate current selections still exist
    const inputExists = deviceList.inputs.some(d => d.id === currentInput);
    const outputExists = deviceList.outputs.some(d => d.id === currentOutput);
    
    if (!inputExists && deviceList.inputs.length > 0) {
      setCurrentInput(deviceList.inputs[0].id);
    }
    
    if (!outputExists && deviceList.outputs.length > 0) {
      setCurrentOutput(deviceList.outputs[0].id);
    }
  };
  
  const selectInput = async (deviceId: string) => {
    const result = await deviceManager.current.selectInputDevice(deviceId);
    if (result.success) {
      setCurrentInput(deviceId);
    } else {
      throw new Error(result.error);
    }
    return result;
  };
  
  const selectOutput = async (deviceId: string) => {
    const result = await deviceManager.current.selectOutputDevice(deviceId);
    if (result.success) {
      setCurrentOutput(deviceId);
    } else {
      throw new Error(result.error);
    }
    return result;
  };
  
  return {
    devices,
    currentInput,
    currentOutput,
    loading,
    error,
    selectInput,
    selectOutput,
    refresh: refreshDevices,
    hasPermissions: devices.hasPermissions
  };
}
```

## Dependencies
- RealTimeKit Setup (Issue #02) for audio configuration
- Voice UI Components (Issue #15) for integration
- Voice Session Management (Issue #14) for device application

## Estimated Effort
**4 days**
- 1 day: Permission request flow and UI
- 1 day: Device enumeration and selection
- 1 day: Audio testing and level monitoring
- 1 day: Device change handling and recovery

## Notes
- Test across different browsers and OS combinations
- Handle privacy-focused browsers that limit device info
- Consider persisting device selections to server
- Add telemetry for common permission issues