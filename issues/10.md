# Issue #10: Rich Embeds (Link Previews)

## User Story
As a **user**, I want to **see previews of links I share** so that **others can understand the content without clicking through**.

## Description
Implement automatic link preview generation using Cloudflare Workers. This includes fetching metadata, generating previews for various content types (articles, videos, tweets), and caching results for performance.

## Acceptance Criteria
- [ ] Links automatically expand to show preview
- [ ] Previews include title, description, image, and favicon
- [ ] Support for Open Graph and Twitter Card metadata
- [ ] Special handling for YouTube, Twitter, GitHub links
- [ ] Previews cached for 24 hours
- [ ] Users can dismiss/collapse previews
- [ ] Respect robots.txt and preview permissions
- [ ] Preview generation doesn't block message sending

## Technical Implementation

### 1. Link Detection and Extraction
```javascript
export class LinkExtractor {
  static readonly URL_REGEX = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*)/gi;
  
  static extractLinks(text) {
    const matches = text.match(this.URL_REGEX) || [];
    return [...new Set(matches)]; // Remove duplicates
  }
  
  static async processMessageLinks(message, env) {
    const links = this.extractLinks(message.content);
    
    if (links.length === 0) {
      return message;
    }
    
    // Queue preview generation (non-blocking)
    await env.PREVIEW_QUEUE.send({
      messageId: message.id,
      links,
      channelId: message.channelId,
      userId: message.userId
    });
    
    // Return message immediately
    return {
      ...message,
      links,
      embeds: [] // Will be populated async
    };
  }
}
```

### 2. Preview Generation Worker
```javascript
export class PreviewGenerator {
  async queue(batch, env) {
    for (const message of batch.messages) {
      await this.generatePreviews(message.body, env);
    }
  }
  
  async generatePreviews(data, env) {
    const { messageId, links, channelId, userId } = data;
    const embeds = [];
    
    for (const url of links) {
      try {
        // Check cache first
        const cached = await this.getCachedPreview(url, env);
        if (cached) {
          embeds.push(cached);
          continue;
        }
        
        // Generate new preview
        const preview = await this.fetchPreview(url, env);
        if (preview) {
          embeds.push(preview);
          await this.cachePreview(url, preview, env);
        }
      } catch (error) {
        console.error(`Failed to generate preview for ${url}:`, error);
      }
    }
    
    // Update message with embeds
    if (embeds.length > 0) {
      await this.updateMessageEmbeds(messageId, embeds, channelId, env);
    }
  }
  
  async fetchPreview(url, env) {
    // Check if URL is allowed
    if (!await this.isUrlAllowed(url, env)) {
      return null;
    }
    
    // Detect special handlers
    const handler = this.getSpecialHandler(url);
    if (handler) {
      return handler(url, env);
    }
    
    // Fetch page with timeout
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'WaddleBot/1.0 (+https://waddle.chat/bot)',
        'Accept': 'text/html,application/xhtml+xml'
      },
      signal: AbortSignal.timeout(5000) // 5 second timeout
    });
    
    if (!response.ok) {
      return null;
    }
    
    // Parse HTML
    const html = await response.text();
    const metadata = await this.parseMetadata(html, url);
    
    return this.createEmbed(metadata, url);
  }
  
  async parseMetadata(html, url) {
    const metadata = {
      title: null,
      description: null,
      image: null,
      favicon: null,
      siteName: null,
      type: 'link'
    };
    
    // Use HTMLRewriter for efficient parsing
    const rewriter = new HTMLRewriter()
      .on('title', {
        text(text) {
          if (!metadata.title && text.text.trim()) {
            metadata.title = text.text.trim();
          }
        }
      })
      .on('meta', {
        element(element) {
          const property = element.getAttribute('property');
          const name = element.getAttribute('name');
          const content = element.getAttribute('content');
          
          if (!content) return;
          
          // Open Graph
          if (property === 'og:title') metadata.title = content;
          if (property === 'og:description') metadata.description = content;
          if (property === 'og:image') metadata.image = this.resolveUrl(content, url);
          if (property === 'og:site_name') metadata.siteName = content;
          if (property === 'og:type') metadata.type = content;
          
          // Twitter Card
          if (name === 'twitter:title' && !metadata.title) metadata.title = content;
          if (name === 'twitter:description' && !metadata.description) metadata.description = content;
          if (name === 'twitter:image' && !metadata.image) metadata.image = this.resolveUrl(content, url);
          
          // Standard meta
          if (name === 'description' && !metadata.description) metadata.description = content;
        }
      })
      .on('link[rel="icon"], link[rel="shortcut icon"]', {
        element(element) {
          const href = element.getAttribute('href');
          if (href && !metadata.favicon) {
            metadata.favicon = this.resolveUrl(href, url);
          }
        }
      });
    
    // Process HTML
    await rewriter.transform(new Response(html)).text();
    
    // Fallback favicon
    if (!metadata.favicon) {
      const urlObj = new URL(url);
      metadata.favicon = `${urlObj.origin}/favicon.ico`;
    }
    
    return metadata;
  }
  
  resolveUrl(path, baseUrl) {
    try {
      return new URL(path, baseUrl).href;
    } catch {
      return null;
    }
  }
  
  createEmbed(metadata, url) {
    const urlObj = new URL(url);
    
    return {
      type: 'rich',
      url,
      title: metadata.title || urlObj.hostname,
      description: metadata.description,
      thumbnail: metadata.image ? {
        url: metadata.image,
        proxy_url: this.getProxyUrl(metadata.image)
      } : null,
      provider: {
        name: metadata.siteName || urlObj.hostname,
        url: urlObj.origin
      },
      favicon: metadata.favicon,
      color: this.getEmbedColor(urlObj.hostname),
      timestamp: new Date().toISOString()
    };
  }
}
```

### 3. Special Handlers for Popular Sites
```javascript
export class SpecialHandlers {
  static handlers = {
    'youtube.com': this.handleYouTube,
    'youtu.be': this.handleYouTube,
    'twitter.com': this.handleTwitter,
    'x.com': this.handleTwitter,
    'github.com': this.handleGitHub,
    'spotify.com': this.handleSpotify
  };
  
  static getHandler(url) {
    const urlObj = new URL(url);
    const domain = urlObj.hostname.replace('www.', '');
    
    for (const [matcher, handler] of Object.entries(this.handlers)) {
      if (domain.includes(matcher)) {
        return handler;
      }
    }
    
    return null;
  }
  
  static async handleYouTube(url, env) {
    const videoId = this.extractYouTubeId(url);
    if (!videoId) return null;
    
    // Use YouTube oEmbed API
    const oembed = await fetch(
      `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`
    ).then(r => r.json());
    
    return {
      type: 'video',
      url,
      title: oembed.title,
      description: `By ${oembed.author_name}`,
      thumbnail: {
        url: oembed.thumbnail_url,
        width: oembed.thumbnail_width,
        height: oembed.thumbnail_height
      },
      video: {
        url: `https://www.youtube.com/embed/${videoId}`,
        width: oembed.width,
        height: oembed.height
      },
      provider: {
        name: 'YouTube',
        url: 'https://youtube.com'
      },
      color: 0xFF0000
    };
  }
  
  static async handleTwitter(url, env) {
    // Extract tweet ID
    const match = url.match(/status\/(\d+)/);
    if (!match) return null;
    
    const tweetId = match[1];
    
    // Use Twitter oEmbed API (requires auth)
    try {
      const response = await fetch(
        `https://publish.twitter.com/oembed?url=${encodeURIComponent(url)}`,
        {
          headers: {
            'User-Agent': 'WaddleBot/1.0'
          }
        }
      );
      
      const data = await response.json();
      
      return {
        type: 'twitter',
        url,
        title: 'Tweet',
        description: data.text,
        html: data.html, // Rendered tweet HTML
        author: {
          name: data.author_name,
          url: data.author_url
        },
        provider: {
          name: 'Twitter',
          url: 'https://twitter.com'
        },
        color: 0x1DA1F2
      };
    } catch (error) {
      return null; // Fallback to standard preview
    }
  }
  
  static async handleGitHub(url, env) {
    const urlObj = new URL(url);
    const pathParts = urlObj.pathname.split('/').filter(Boolean);
    
    if (pathParts.length < 2) return null;
    
    const [owner, repo, ...rest] = pathParts;
    
    // Handle different GitHub URLs
    if (rest[0] === 'pull' && rest[1]) {
      // Pull request
      const prNumber = rest[1];
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}`;
      
      const data = await fetch(apiUrl, {
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'WaddleBot/1.0'
        }
      }).then(r => r.json());
      
      return {
        type: 'github_pr',
        url,
        title: `PR #${prNumber}: ${data.title}`,
        description: data.body?.substring(0, 200) + '...',
        thumbnail: {
          url: data.user.avatar_url
        },
        fields: [
          { name: 'Status', value: data.state, inline: true },
          { name: 'Changes', value: `+${data.additions} -${data.deletions}`, inline: true }
        ],
        provider: {
          name: 'GitHub',
          url: 'https://github.com'
        },
        color: this.getGitHubColor(data.state)
      };
    }
    
    // Repository
    const apiUrl = `https://api.github.com/repos/${owner}/${repo}`;
    const data = await fetch(apiUrl, {
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'WaddleBot/1.0'
      }
    }).then(r => r.json());
    
    return {
      type: 'github_repo',
      url,
      title: data.full_name,
      description: data.description,
      thumbnail: {
        url: data.owner.avatar_url
      },
      fields: [
        { name: 'Stars', value: data.stargazers_count.toLocaleString(), inline: true },
        { name: 'Forks', value: data.forks_count.toLocaleString(), inline: true },
        { name: 'Language', value: data.language || 'Unknown', inline: true }
      ],
      provider: {
        name: 'GitHub',
        url: 'https://github.com'
      },
      color: 0x24292e
    };
  }
}
```

### 4. Caching Strategy
```javascript
export class PreviewCache {
  static async getCached(url, env) {
    const key = `preview:${this.hashUrl(url)}`;
    const cached = await env.PREVIEW_KV.get(key, 'json');
    
    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }
    
    return null;
  }
  
  static async cache(url, preview, env) {
    const key = `preview:${this.hashUrl(url)}`;
    const data = {
      data: preview,
      expires: Date.now() + 86400000, // 24 hours
      cachedAt: Date.now()
    };
    
    await env.PREVIEW_KV.put(key, JSON.stringify(data), {
      expirationTtl: 86400 // 24 hours
    });
  }
  
  static hashUrl(url) {
    // Simple hash for URL
    let hash = 0;
    for (let i = 0; i < url.length; i++) {
      const char = url.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }
}
```

### 5. Client-side Embed Rendering
```tsx
export function MessageEmbed({ embed }: { embed: Embed }) {
  const [collapsed, setCollapsed] = useState(false);
  
  if (collapsed) {
    return (
      <div className="embed-collapsed" onClick={() => setCollapsed(false)}>
        <LinkIcon />
        <span>{new URL(embed.url).hostname}</span>
      </div>
    );
  }
  
  return (
    <div className="message-embed" style={{ borderLeftColor: embed.color }}>
      <button 
        className="embed-close" 
        onClick={() => setCollapsed(true)}
        aria-label="Collapse preview"
      >
        <CloseIcon />
      </button>
      
      {embed.provider && (
        <div className="embed-provider">
          {embed.favicon && (
            <img src={embed.favicon} alt="" width="16" height="16" />
          )}
          <span>{embed.provider.name}</span>
        </div>
      )}
      
      {embed.title && (
        <a 
          href={embed.url} 
          className="embed-title" 
          target="_blank" 
          rel="noopener noreferrer"
        >
          {embed.title}
        </a>
      )}
      
      {embed.description && (
        <div className="embed-description">
          {embed.description}
        </div>
      )}
      
      {embed.fields && (
        <div className="embed-fields">
          {embed.fields.map((field, i) => (
            <div key={i} className={`embed-field ${field.inline ? 'inline' : ''}`}>
              <div className="field-name">{field.name}</div>
              <div className="field-value">{field.value}</div>
            </div>
          ))}
        </div>
      )}
      
      {embed.thumbnail && (
        <img 
          src={embed.thumbnail.proxy_url || embed.thumbnail.url}
          alt=""
          className="embed-thumbnail"
          loading="lazy"
        />
      )}
      
      {embed.video && (
        <div className="embed-video">
          <iframe
            src={embed.video.url}
            width={embed.video.width}
            height={embed.video.height}
            frameBorder="0"
            allowFullScreen
            sandbox="allow-scripts allow-same-origin allow-presentation"
          />
        </div>
      )}
      
      {embed.html && (
        <div 
          className="embed-html"
          dangerouslySetInnerHTML={{ __html: embed.html }}
        />
      )}
    </div>
  );
}
```

### 6. Security and Privacy
```javascript
export class EmbedSecurity {
  static async isUrlAllowed(url, env) {
    const urlObj = new URL(url);
    
    // Check blocklist
    const blocked = await env.BLOCKED_DOMAINS.get(urlObj.hostname);
    if (blocked) return false;
    
    // Check robots.txt
    try {
      const robotsUrl = `${urlObj.origin}/robots.txt`;
      const robots = await fetch(robotsUrl, {
        signal: AbortSignal.timeout(2000)
      }).then(r => r.text());
      
      if (robots.includes('User-agent: WaddleBot') && 
          robots.includes('Disallow: /')) {
        return false;
      }
    } catch {
      // Ignore robots.txt fetch errors
    }
    
    // Check for private IPs
    if (this.isPrivateIP(urlObj.hostname)) {
      return false;
    }
    
    return true;
  }
  
  static isPrivateIP(hostname) {
    // Check for private IP ranges
    const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (!ipRegex.test(hostname)) return false;
    
    const parts = hostname.split('.').map(Number);
    
    // 10.0.0.0/8
    if (parts[0] === 10) return true;
    
    // 172.16.0.0/12
    if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
    
    // 192.168.0.0/16
    if (parts[0] === 192 && parts[1] === 168) return true;
    
    // 127.0.0.0/8
    if (parts[0] === 127) return true;
    
    return false;
  }
  
  static sanitizeEmbed(embed) {
    // Remove any potentially dangerous content
    const sanitized = { ...embed };
    
    // Limit text lengths
    if (sanitized.title) {
      sanitized.title = sanitized.title.substring(0, 256);
    }
    
    if (sanitized.description) {
      sanitized.description = sanitized.description.substring(0, 1024);
    }
    
    // Ensure URLs are valid
    try {
      new URL(sanitized.url);
      if (sanitized.thumbnail?.url) new URL(sanitized.thumbnail.url);
      if (sanitized.provider?.url) new URL(sanitized.provider.url);
    } catch {
      return null;
    }
    
    return sanitized;
  }
}
```

### 7. Settings and User Preferences
```javascript
export class EmbedSettings {
  static async getUserPreferences(userId, env) {
    const settings = await env.USERS_DB.prepare(`
      SELECT embed_settings
      FROM user_settings
      WHERE user_id = ?
    `).bind(userId).first();
    
    return settings?.embed_settings || {
      enabled: true,
      autoPlayVideos: false,
      showLargeThumbnails: true,
      maxEmbeds: 5
    };
  }
  
  static async updatePreferences(userId, settings, env) {
    await env.USERS_DB.prepare(`
      UPDATE user_settings
      SET embed_settings = ?
      WHERE user_id = ?
    `).bind(JSON.stringify(settings), userId).run();
  }
}
```

## Dependencies
- Message Flow (Issue #06) for message processing
- WebSocket Architecture (Issue #04) for real-time updates
- Database Schema (Issue #05) for storing embeds

## Estimated Effort
**4 days**
- 1 day: Basic link extraction and preview generation
- 1 day: Special handlers for popular sites
- 1 day: Caching and performance optimization
- 1 day: Security measures and testing

## Notes
- Consider proxy service for images to protect user IPs
- Add support for more oEmbed providers
- Implement preview refresh for outdated content
- Monitor API rate limits for third-party services