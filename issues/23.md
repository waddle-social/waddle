# Issue #23: Permission System

## User Story
As a **waddle administrator**, I want to **manage roles and permissions for members** so that **I can control who can perform different actions in my waddle**.

## Description
Implement a comprehensive role-based permission system supporting custom roles, permission inheritance, channel overrides, and permission syncing. This includes both waddle-wide and channel-specific permissions with a flexible hierarchy system.

## Acceptance Criteria
- [ ] Create and manage custom roles
- [ ] Assign multiple roles to members
- [ ] Define granular permissions
- [ ] Support channel permission overrides
- [ ] Role hierarchy and inheritance
- [ ] Permission calculation and caching
- [ ] Audit log for permission changes
- [ ] Visual permission editor

## Technical Implementation

### 1. Permission System Architecture
```typescript
export enum Permission {
  // General
  VIEW_CHANNELS = 1 << 0,
  MANAGE_CHANNELS = 1 << 1,
  MANAGE_ROLES = 1 << 2,
  MANAGE_WADDLE = 1 << 3,
  
  // Text
  SEND_MESSAGES = 1 << 4,
  EMBED_LINKS = 1 << 5,
  ATTACH_FILES = 1 << 6,
  ADD_REACTIONS = 1 << 7,
  USE_EXTERNAL_EMOJIS = 1 << 8,
  MENTION_EVERYONE = 1 << 9,
  MANAGE_MESSAGES = 1 << 10,
  READ_MESSAGE_HISTORY = 1 << 11,
  USE_SLASH_COMMANDS = 1 << 12,
  
  // Voice
  CONNECT = 1 << 13,
  SPEAK = 1 << 14,
  VIDEO = 1 << 15,
  MUTE_MEMBERS = 1 << 16,
  DEAFEN_MEMBERS = 1 << 17,
  MOVE_MEMBERS = 1 << 18,
  USE_VOICE_ACTIVITY = 1 << 19,
  PRIORITY_SPEAKER = 1 << 20,
  STREAM = 1 << 21,
  
  // Stage
  REQUEST_TO_SPEAK = 1 << 22,
  MANAGE_STAGE = 1 << 23,
  
  // Membership
  CREATE_INVITES = 1 << 24,
  KICK_MEMBERS = 1 << 25,
  BAN_MEMBERS = 1 << 26,
  CHANGE_NICKNAME = 1 << 27,
  MANAGE_NICKNAMES = 1 << 28,
  
  // Advanced
  ADMINISTRATOR = 1 << 29,
  VIEW_AUDIT_LOG = 1 << 30,
  VIEW_ANALYTICS = 1 << 31,
  MANAGE_WEBHOOKS = 1 << 32,
  MANAGE_EMOJIS = 1 << 33
}

export interface Role {
  id: string;
  waddleId: string;
  name: string;
  color: string;
  permissions: bigint;
  position: number;
  hoist: boolean; // Display separately
  mentionable: boolean;
  isDefault: boolean;
  isManaged: boolean; // System role
  metadata?: {
    botId?: string;
    integrationId?: string;
    subscriberTier?: number;
  };
}

export class PermissionManager {
  private permissionCache = new Map<string, bigint>();
  private readonly CACHE_TTL = 300000; // 5 minutes
  
  constructor(
    private db: D1Database,
    private cache: KVNamespace
  ) {}
  
  async calculatePermissions(
    userId: string,
    waddleId: string,
    channelId?: string
  ): Promise<bigint> {
    const cacheKey = `perms:${userId}:${waddleId}:${channelId || 'waddle'}`;
    
    // Check cache
    const cached = this.permissionCache.get(cacheKey);
    if (cached !== undefined) {
      return cached;
    }
    
    // Get member data
    const member = await this.getMember(userId, waddleId);
    if (!member) {
      return 0n;
    }
    
    // Owner has all permissions
    const waddle = await this.getWaddle(waddleId);
    if (waddle.ownerId === userId) {
      const allPerms = this.getAllPermissions();
      this.cachePermissions(cacheKey, allPerms);
      return allPerms;
    }
    
    // Calculate base permissions from roles
    let permissions = await this.calculateRolePermissions(member.roles);
    
    // Check for administrator permission
    if (permissions & BigInt(Permission.ADMINISTRATOR)) {
      const allPerms = this.getAllPermissions();
      this.cachePermissions(cacheKey, allPerms);
      return allPerms;
    }
    
    // Apply channel overrides if specified
    if (channelId) {
      permissions = await this.applyChannelOverrides(
        permissions,
        member.roles,
        userId,
        channelId
      );
    }
    
    this.cachePermissions(cacheKey, permissions);
    return permissions;
  }
  
  private async calculateRolePermissions(roleIds: string[]): Promise<bigint> {
    if (roleIds.length === 0) {
      return 0n;
    }
    
    const roles = await this.db.prepare(`
      SELECT permissions FROM roles 
      WHERE id IN (${roleIds.map(() => '?').join(',')})
    `).bind(...roleIds).all();
    
    // Combine all role permissions with OR
    return roles.results.reduce((perms, role) => {
      return perms | BigInt(role.permissions);
    }, 0n);
  }
  
  private async applyChannelOverrides(
    basePermissions: bigint,
    roleIds: string[],
    userId: string,
    channelId: string
  ): Promise<bigint> {
    // Get all relevant overrides
    const overrides = await this.db.prepare(`
      SELECT * FROM channel_permission_overrides
      WHERE channel_id = ?
        AND (
          (type = 'role' AND target_id IN (${roleIds.map(() => '?').join(',')}))
          OR (type = 'member' AND target_id = ?)
        )
      ORDER BY type DESC -- Member overrides take precedence
    `).bind(channelId, ...roleIds, userId).all();
    
    let permissions = basePermissions;
    
    // Apply role overrides first
    const roleOverrides = overrides.results.filter(o => o.type === 'role');
    for (const override of roleOverrides) {
      permissions &= ~BigInt(override.deny); // Remove denied permissions
      permissions |= BigInt(override.allow); // Add allowed permissions
    }
    
    // Apply member overrides (highest priority)
    const memberOverride = overrides.results.find(
      o => o.type === 'member' && o.target_id === userId
    );
    if (memberOverride) {
      permissions &= ~BigInt(memberOverride.deny);
      permissions |= BigInt(memberOverride.allow);
    }
    
    return permissions;
  }
  
  hasPermission(
    permissions: bigint,
    permission: Permission
  ): boolean {
    // Admin bypasses all checks
    if (permissions & BigInt(Permission.ADMINISTRATOR)) {
      return true;
    }
    
    return (permissions & BigInt(permission)) === BigInt(permission);
  }
  
  async createRole(
    waddleId: string,
    data: CreateRoleData,
    creatorId: string
  ): Promise<Role> {
    // Validate permissions
    const canManage = await this.checkPermission(
      creatorId,
      waddleId,
      Permission.MANAGE_ROLES
    );
    if (!canManage) {
      throw new ForbiddenError('No permission to manage roles');
    }
    
    // Get next position
    const maxPosition = await this.db.prepare(`
      SELECT MAX(position) as max FROM roles WHERE waddle_id = ?
    `).bind(waddleId).first();
    
    const role: Role = {
      id: crypto.randomUUID(),
      waddleId,
      name: data.name,
      color: data.color || '#99AAB5',
      permissions: BigInt(data.permissions || 0),
      position: (maxPosition?.max || 0) + 1,
      hoist: data.hoist || false,
      mentionable: data.mentionable || false,
      isDefault: false,
      isManaged: false
    };
    
    await this.db.prepare(`
      INSERT INTO roles (
        id, waddle_id, name, color, permissions, 
        position, hoist, mentionable, is_default, is_managed
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      role.id,
      role.waddleId,
      role.name,
      role.color,
      role.permissions.toString(),
      role.position,
      role.hoist,
      role.mentionable,
      role.isDefault,
      role.isManaged
    ).run();
    
    // Audit log
    await this.auditLog.log({
      action: 'ROLE_CREATE',
      actorId: creatorId,
      targetId: role.id,
      waddleId,
      changes: { role }
    });
    
    // Clear permission caches for this waddle
    await this.clearWaddlePermissionCache(waddleId);
    
    return role;
  }
}
```

### 2. Permission Calculation Engine
```typescript
export class PermissionCalculator {
  private readonly permissionHierarchy = new Map<Permission, Permission[]>([
    // Administrator implies all permissions
    [Permission.ADMINISTRATOR, Object.values(Permission).filter(p => p !== Permission.ADMINISTRATOR)],
    
    // Manage messages implies delete messages
    [Permission.MANAGE_MESSAGES, [Permission.SEND_MESSAGES]],
    
    // Manage channels implies view channels
    [Permission.MANAGE_CHANNELS, [Permission.VIEW_CHANNELS]],
    
    // Stage management implies speaking
    [Permission.MANAGE_STAGE, [Permission.REQUEST_TO_SPEAK]],
    
    // Voice moderation implies voice connection
    [Permission.MUTE_MEMBERS, [Permission.CONNECT]],
    [Permission.DEAFEN_MEMBERS, [Permission.CONNECT]],
    [Permission.MOVE_MEMBERS, [Permission.CONNECT]]
  ]);
  
  expandPermissions(permissions: bigint): bigint {
    let expanded = permissions;
    
    // Apply hierarchical implications
    for (const [parent, children] of this.permissionHierarchy) {
      if (permissions & BigInt(parent)) {
        for (const child of children) {
          expanded |= BigInt(child);
        }
      }
    }
    
    return expanded;
  }
  
  async calculateEffectivePermissions(
    member: Member,
    channel?: Channel
  ): Promise<EffectivePermissions> {
    // Start with @everyone role
    const everyoneRole = await this.getEveryoneRole(member.waddleId);
    let base = BigInt(everyoneRole.permissions);
    
    // Add permissions from all member roles
    for (const roleId of member.roles) {
      const role = await this.getRole(roleId);
      base |= BigInt(role.permissions);
    }
    
    // Expand hierarchical permissions
    base = this.expandPermissions(base);
    
    if (!channel) {
      return {
        permissions: base,
        allow: base,
        deny: 0n
      };
    }
    
    // Apply channel overrides
    const overrides = await this.getChannelOverrides(channel.id);
    let allow = base;
    let deny = 0n;
    
    // Process @everyone overrides first
    const everyoneOverride = overrides.find(
      o => o.type === 'role' && o.targetId === everyoneRole.id
    );
    if (everyoneOverride) {
      allow &= ~BigInt(everyoneOverride.deny);
      allow |= BigInt(everyoneOverride.allow);
      deny |= BigInt(everyoneOverride.deny);
    }
    
    // Process role overrides (in order of role position)
    const roleOverrides = overrides
      .filter(o => o.type === 'role' && member.roles.includes(o.targetId))
      .sort((a, b) => {
        const roleA = this.roleCache.get(a.targetId);
        const roleB = this.roleCache.get(b.targetId);
        return (roleA?.position || 0) - (roleB?.position || 0);
      });
    
    for (const override of roleOverrides) {
      allow &= ~BigInt(override.deny);
      allow |= BigInt(override.allow);
      deny |= BigInt(override.deny);
    }
    
    // Process member override (highest priority)
    const memberOverride = overrides.find(
      o => o.type === 'member' && o.targetId === member.userId
    );
    if (memberOverride) {
      allow &= ~BigInt(memberOverride.deny);
      allow |= BigInt(memberOverride.allow);
      deny = BigInt(memberOverride.deny);
    }
    
    return {
      permissions: allow,
      allow,
      deny
    };
  }
}
```

### 3. Role Management Service
```typescript
export class RoleService {
  async updateRole(
    roleId: string,
    updates: UpdateRoleData,
    actorId: string
  ): Promise<Role> {
    const role = await this.getRole(roleId);
    
    // Check permissions
    const canManage = await this.permissionManager.checkPermission(
      actorId,
      role.waddleId,
      Permission.MANAGE_ROLES
    );
    if (!canManage) {
      throw new ForbiddenError('No permission to manage roles');
    }
    
    // Can't edit managed roles
    if (role.isManaged) {
      throw new ForbiddenError('Cannot edit managed roles');
    }
    
    // Track changes for audit log
    const changes: any = {};
    
    // Update role
    const updateFields: string[] = [];
    const updateValues: any[] = [];
    
    if (updates.name !== undefined) {
      updateFields.push('name = ?');
      updateValues.push(updates.name);
      changes.name = { old: role.name, new: updates.name };
    }
    
    if (updates.color !== undefined) {
      updateFields.push('color = ?');
      updateValues.push(updates.color);
      changes.color = { old: role.color, new: updates.color };
    }
    
    if (updates.permissions !== undefined) {
      // Validate actor has all permissions they're granting
      const actorPerms = await this.permissionManager.calculatePermissions(
        actorId,
        role.waddleId
      );
      
      const newPerms = BigInt(updates.permissions);
      if ((newPerms & actorPerms) !== newPerms) {
        throw new ForbiddenError('Cannot grant permissions you do not have');
      }
      
      updateFields.push('permissions = ?');
      updateValues.push(newPerms.toString());
      changes.permissions = { 
        old: role.permissions.toString(), 
        new: newPerms.toString() 
      };
    }
    
    if (updates.hoist !== undefined) {
      updateFields.push('hoist = ?');
      updateValues.push(updates.hoist);
      changes.hoist = { old: role.hoist, new: updates.hoist };
    }
    
    if (updates.mentionable !== undefined) {
      updateFields.push('mentionable = ?');
      updateValues.push(updates.mentionable);
      changes.mentionable = { old: role.mentionable, new: updates.mentionable };
    }
    
    if (updateFields.length > 0) {
      await this.db.prepare(`
        UPDATE roles 
        SET ${updateFields.join(', ')}
        WHERE id = ?
      `).bind(...updateValues, roleId).run();
      
      // Audit log
      await this.auditLog.log({
        action: 'ROLE_UPDATE',
        actorId,
        targetId: roleId,
        waddleId: role.waddleId,
        changes
      });
      
      // Clear permission caches
      await this.clearWaddlePermissionCache(role.waddleId);
    }
    
    return this.getRole(roleId);
  }
  
  async updateRolePositions(
    waddleId: string,
    positions: RolePosition[],
    actorId: string
  ): Promise<void> {
    // Validate permissions
    const canManage = await this.permissionManager.checkPermission(
      actorId,
      waddleId,
      Permission.MANAGE_ROLES
    );
    if (!canManage) {
      throw new ForbiddenError('No permission to manage roles');
    }
    
    // Get actor's highest role
    const actorRoles = await this.getMemberRoles(actorId, waddleId);
    const actorHighestPosition = Math.max(...actorRoles.map(r => r.position));
    
    // Validate all position changes
    for (const pos of positions) {
      const role = await this.getRole(pos.roleId);
      
      // Can't move roles higher than your highest role
      if (pos.position > actorHighestPosition) {
        throw new ForbiddenError('Cannot move roles above your highest role');
      }
      
      // Can't move managed roles
      if (role.isManaged) {
        throw new ForbiddenError('Cannot move managed roles');
      }
    }
    
    // Update positions
    const updates = positions.map(pos => 
      this.db.prepare('UPDATE roles SET position = ? WHERE id = ?')
        .bind(pos.position, pos.roleId)
    );
    
    await this.db.batch(updates);
    
    // Audit log
    await this.auditLog.log({
      action: 'ROLE_POSITIONS_UPDATE',
      actorId,
      waddleId,
      changes: { positions }
    });
  }
  
  async assignRole(
    userId: string,
    roleId: string,
    actorId: string
  ): Promise<void> {
    const role = await this.getRole(roleId);
    
    // Check permissions
    const canManage = await this.permissionManager.checkPermission(
      actorId,
      role.waddleId,
      Permission.MANAGE_ROLES
    );
    if (!canManage) {
      throw new ForbiddenError('No permission to manage roles');
    }
    
    // Check role hierarchy
    const actorRoles = await this.getMemberRoles(actorId, role.waddleId);
    const actorHighestPosition = Math.max(...actorRoles.map(r => r.position));
    
    if (role.position >= actorHighestPosition) {
      throw new ForbiddenError('Cannot assign roles equal or higher than your highest role');
    }
    
    // Assign role
    await this.db.prepare(`
      INSERT OR IGNORE INTO member_roles (user_id, role_id, assigned_at, assigned_by)
      VALUES (?, ?, ?, ?)
    `).bind(userId, roleId, Date.now(), actorId).run();
    
    // Audit log
    await this.auditLog.log({
      action: 'MEMBER_ROLE_ADD',
      actorId,
      targetId: userId,
      waddleId: role.waddleId,
      changes: { roleId }
    });
    
    // Clear permission cache for user
    await this.clearUserPermissionCache(userId, role.waddleId);
    
    // Emit event
    await this.events.emit('member.role.added', {
      userId,
      roleId,
      waddleId: role.waddleId,
      actorId
    });
  }
}
```

### 4. Channel Permission Overrides
```typescript
export interface ChannelPermissionOverride {
  id: string;
  channelId: string;
  type: 'role' | 'member';
  targetId: string; // roleId or userId
  allow: bigint;
  deny: bigint;
}

export class ChannelPermissionService {
  async updateChannelPermissions(
    channelId: string,
    overrides: ChannelOverrideUpdate[],
    actorId: string
  ): Promise<void> {
    const channel = await this.getChannel(channelId);
    
    // Check permissions
    const canManage = await this.permissionManager.checkPermission(
      actorId,
      channel.waddleId,
      Permission.MANAGE_CHANNELS
    );
    if (!canManage) {
      throw new ForbiddenError('No permission to manage channel permissions');
    }
    
    // Process each override
    for (const override of overrides) {
      if (override.remove) {
        await this.removeOverride(channelId, override);
      } else {
        await this.upsertOverride(channelId, override);
      }
    }
    
    // Sync permission to category children if applicable
    if (channel.type === 'category' && overrides.some(o => o.sync)) {
      await this.syncCategoryPermissions(channelId);
    }
    
    // Clear channel permission caches
    await this.clearChannelPermissionCache(channelId);
    
    // Audit log
    await this.auditLog.log({
      action: 'CHANNEL_PERMISSIONS_UPDATE',
      actorId,
      targetId: channelId,
      waddleId: channel.waddleId,
      changes: { overrides }
    });
  }
  
  private async upsertOverride(
    channelId: string,
    override: ChannelOverrideUpdate
  ): Promise<void> {
    const existing = await this.db.prepare(`
      SELECT * FROM channel_permission_overrides
      WHERE channel_id = ? AND type = ? AND target_id = ?
    `).bind(channelId, override.type, override.targetId).first();
    
    const allow = BigInt(override.allow || 0);
    const deny = BigInt(override.deny || 0);
    
    if (existing) {
      // Update existing override
      await this.db.prepare(`
        UPDATE channel_permission_overrides
        SET allow = ?, deny = ?
        WHERE id = ?
      `).bind(allow.toString(), deny.toString(), existing.id).run();
    } else {
      // Create new override
      await this.db.prepare(`
        INSERT INTO channel_permission_overrides (
          id, channel_id, type, target_id, allow, deny
        ) VALUES (?, ?, ?, ?, ?, ?)
      `).bind(
        crypto.randomUUID(),
        channelId,
        override.type,
        override.targetId,
        allow.toString(),
        deny.toString()
      ).run();
    }
  }
  
  async syncCategoryPermissions(categoryId: string): Promise<void> {
    // Get category permissions
    const categoryOverrides = await this.db.prepare(`
      SELECT * FROM channel_permission_overrides
      WHERE channel_id = ?
    `).bind(categoryId).all();
    
    // Get all child channels
    const children = await this.db.prepare(`
      SELECT id FROM channels
      WHERE parent_id = ?
    `).bind(categoryId).all();
    
    // Apply category permissions to each child
    for (const child of children.results) {
      // Remove existing overrides
      await this.db.prepare(`
        DELETE FROM channel_permission_overrides
        WHERE channel_id = ?
      `).bind(child.id).run();
      
      // Copy category overrides
      const inserts = categoryOverrides.results.map(override =>
        this.db.prepare(`
          INSERT INTO channel_permission_overrides (
            id, channel_id, type, target_id, allow, deny
          ) VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
          crypto.randomUUID(),
          child.id,
          override.type,
          override.target_id,
          override.allow,
          override.deny
        )
      );
      
      await this.db.batch(inserts);
    }
  }
}
```

### 5. Permission UI Components
```tsx
export function RoleManager({ waddleId }: { waddleId: string }) {
  const { roles, loading } = useRoles(waddleId);
  const [selectedRole, setSelectedRole] = useState<Role | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  
  return (
    <div className="role-manager">
      <div className="role-sidebar">
        <div className="role-header">
          <h3>Roles</h3>
          <Button
            size="small"
            onClick={() => setShowCreateModal(true)}
            icon={<AddIcon />}
          >
            Create Role
          </Button>
        </div>
        
        <DndContext onDragEnd={handleDragEnd}>
          <SortableContext items={roles.map(r => r.id)}>
            <div className="role-list">
              {roles.map(role => (
                <SortableRole
                  key={role.id}
                  role={role}
                  selected={selectedRole?.id === role.id}
                  onClick={() => setSelectedRole(role)}
                />
              ))}
            </div>
          </SortableContext>
        </DndContext>
      </div>
      
      <div className="role-editor">
        {selectedRole ? (
          <RoleEditor
            role={selectedRole}
            onUpdate={handleRoleUpdate}
            onDelete={handleRoleDelete}
          />
        ) : (
          <div className="no-role-selected">
            Select a role to edit permissions
          </div>
        )}
      </div>
      
      {showCreateModal && (
        <CreateRoleModal
          waddleId={waddleId}
          onClose={() => setShowCreateModal(false)}
          onCreate={handleRoleCreate}
        />
      )}
    </div>
  );
}

function RoleEditor({ role, onUpdate, onDelete }: RoleEditorProps) {
  const [activeTab, setActiveTab] = useState('display');
  const [hasChanges, setHasChanges] = useState(false);
  const [editedRole, setEditedRole] = useState(role);
  
  const handlePermissionToggle = (permission: Permission) => {
    const currentPerms = BigInt(editedRole.permissions);
    const permBit = BigInt(permission);
    
    const newPerms = currentPerms & permBit
      ? currentPerms & ~permBit  // Remove permission
      : currentPerms | permBit;   // Add permission
    
    setEditedRole({
      ...editedRole,
      permissions: newPerms
    });
    setHasChanges(true);
  };
  
  return (
    <div className="role-editor-content">
      <div className="role-editor-header">
        <h2>{role.name}</h2>
        <div className="role-actions">
          {hasChanges && (
            <>
              <Button
                variant="secondary"
                onClick={() => {
                  setEditedRole(role);
                  setHasChanges(false);
                }}
              >
                Reset
              </Button>
              <Button
                variant="primary"
                onClick={() => onUpdate(editedRole)}
              >
                Save Changes
              </Button>
            </>
          )}
        </div>
      </div>
      
      <Tabs value={activeTab} onChange={setActiveTab}>
        <TabList>
          <Tab value="display">Display</Tab>
          <Tab value="permissions">Permissions</Tab>
          <Tab value="members">Members</Tab>
        </TabList>
        
        <TabPanels>
          <TabPanel value="display">
            <RoleDisplaySettings
              role={editedRole}
              onChange={(updates) => {
                setEditedRole({ ...editedRole, ...updates });
                setHasChanges(true);
              }}
            />
          </TabPanel>
          
          <TabPanel value="permissions">
            <PermissionEditor
              permissions={editedRole.permissions}
              onToggle={handlePermissionToggle}
            />
          </TabPanel>
          
          <TabPanel value="members">
            <RoleMembersList roleId={role.id} />
          </TabPanel>
        </TabPanels>
      </Tabs>
      
      {!role.isDefault && !role.isManaged && (
        <div className="role-danger-zone">
          <h3>Danger Zone</h3>
          <Button
            variant="danger"
            onClick={() => onDelete(role.id)}
          >
            Delete Role
          </Button>
        </div>
      )}
    </div>
  );
}

function PermissionEditor({ 
  permissions, 
  onToggle 
}: { 
  permissions: bigint;
  onToggle: (permission: Permission) => void;
}) {
  const permissionGroups = {
    'General Permissions': [
      { perm: Permission.VIEW_CHANNELS, label: 'View Channels', desc: 'Allows members to view channels' },
      { perm: Permission.MANAGE_CHANNELS, label: 'Manage Channels', desc: 'Create, edit, and delete channels' },
      { perm: Permission.MANAGE_ROLES, label: 'Manage Roles', desc: 'Create, edit, and assign roles' },
      { perm: Permission.MANAGE_WADDLE, label: 'Manage Waddle', desc: 'Edit waddle settings' }
    ],
    'Text Permissions': [
      { perm: Permission.SEND_MESSAGES, label: 'Send Messages', desc: 'Send messages in text channels' },
      { perm: Permission.EMBED_LINKS, label: 'Embed Links', desc: 'Links show embedded content' },
      { perm: Permission.ATTACH_FILES, label: 'Attach Files', desc: 'Upload files and images' },
      { perm: Permission.ADD_REACTIONS, label: 'Add Reactions', desc: 'React to messages with emojis' },
      { perm: Permission.MANAGE_MESSAGES, label: 'Manage Messages', desc: 'Delete messages from other members' }
    ],
    'Voice Permissions': [
      { perm: Permission.CONNECT, label: 'Connect', desc: 'Join voice channels' },
      { perm: Permission.SPEAK, label: 'Speak', desc: 'Talk in voice channels' },
      { perm: Permission.VIDEO, label: 'Video', desc: 'Share video in voice channels' },
      { perm: Permission.MUTE_MEMBERS, label: 'Mute Members', desc: 'Mute other members in voice' },
      { perm: Permission.MOVE_MEMBERS, label: 'Move Members', desc: 'Move members between voice channels' }
    ],
    'Membership Permissions': [
      { perm: Permission.CREATE_INVITES, label: 'Create Invites', desc: 'Generate invite links' },
      { perm: Permission.KICK_MEMBERS, label: 'Kick Members', desc: 'Remove members from the waddle' },
      { perm: Permission.BAN_MEMBERS, label: 'Ban Members', desc: 'Permanently ban members' }
    ]
  };
  
  const hasPermission = (perm: Permission): boolean => {
    return (permissions & BigInt(perm)) === BigInt(perm);
  };
  
  return (
    <div className="permission-editor">
      {Object.entries(permissionGroups).map(([groupName, perms]) => (
        <div key={groupName} className="permission-group">
          <h4>{groupName}</h4>
          {perms.map(({ perm, label, desc }) => (
            <div key={perm} className="permission-item">
              <div className="permission-info">
                <label htmlFor={`perm-${perm}`}>{label}</label>
                <span className="permission-desc">{desc}</span>
              </div>
              <Switch
                id={`perm-${perm}`}
                checked={hasPermission(perm)}
                onChange={() => onToggle(perm)}
              />
            </div>
          ))}
        </div>
      ))}
      
      <div className="permission-warning">
        <WarningIcon />
        <p>
          Be careful with permissions! The Administrator permission grants 
          all permissions and cannot be restricted by channel overrides.
        </p>
      </div>
    </div>
  );
}
```

### 6. Permission Checking Middleware
```typescript
export class PermissionMiddleware {
  constructor(private permissionManager: PermissionManager) {}
  
  requirePermission(permission: Permission) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const userId = req.user?.id;
      const waddleId = req.params.waddleId || req.body.waddleId;
      const channelId = req.params.channelId || req.body.channelId;
      
      if (!userId || !waddleId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      try {
        const hasPermission = await this.permissionManager.checkPermission(
          userId,
          waddleId,
          permission,
          channelId
        );
        
        if (!hasPermission) {
          return res.status(403).json({ 
            error: 'Missing required permission',
            required: Permission[permission]
          });
        }
        
        next();
      } catch (error) {
        return res.status(500).json({ error: 'Permission check failed' });
      }
    };
  }
  
  requireAnyPermission(permissions: Permission[]) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const userId = req.user?.id;
      const waddleId = req.params.waddleId || req.body.waddleId;
      const channelId = req.params.channelId || req.body.channelId;
      
      if (!userId || !waddleId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      try {
        const userPerms = await this.permissionManager.calculatePermissions(
          userId,
          waddleId,
          channelId
        );
        
        const hasAny = permissions.some(perm => 
          this.permissionManager.hasPermission(userPerms, perm)
        );
        
        if (!hasAny) {
          return res.status(403).json({ 
            error: 'Missing required permissions',
            requiredAny: permissions.map(p => Permission[p])
          });
        }
        
        req.userPermissions = userPerms;
        next();
      } catch (error) {
        return res.status(500).json({ error: 'Permission check failed' });
      }
    };
  }
}

// Usage in routes
router.post('/waddles/:waddleId/channels',
  permissionMiddleware.requirePermission(Permission.MANAGE_CHANNELS),
  createChannel
);

router.delete('/waddles/:waddleId/messages/:messageId',
  permissionMiddleware.requireAnyPermission([
    Permission.MANAGE_MESSAGES,
    Permission.ADMINISTRATOR
  ]),
  deleteMessage
);
```

## Dependencies
- Database Schema (Issue #05) for role storage
- Audit Log System for tracking changes
- Caching Layer (KV) for performance
- Member Management for role assignment

## Estimated Effort
**6 days**
- 1 day: Core permission system and calculation
- 1 day: Role management service
- 1 day: Channel permission overrides
- 1 day: Permission UI components
- 1 day: Permission middleware and API
- 1 day: Testing and edge cases

## Notes
- Implement permission templates for common role types
- Add permission inheritance visualization
- Consider permission presets for quick setup
- Monitor permission calculation performance
- Add bulk permission operations