# Issue #44: Stream Dashboard

## User Story
As a **stream manager or content creator**, I want to **have a comprehensive dashboard for managing all aspects of my streams** so that **I can monitor performance, manage content, and optimize viewer engagement from a single interface**.

## Description
Create a unified stream management dashboard that provides real-time monitoring, analytics, content management, and configuration tools for voice streams and broadcasts. The dashboard should offer insights into viewer behavior, technical performance, and engagement metrics while providing easy access to stream controls and settings.

## Acceptance Criteria
- [ ] Real-time stream monitoring
- [ ] Comprehensive analytics and metrics
- [ ] Stream schedule management
- [ ] Content moderation tools
- [ ] Multi-stream overview
- [ ] Performance optimization insights
- [ ] Audience engagement tracking
- [ ] Export and reporting features

## Technical Implementation

### 1. Dashboard Core Architecture
```typescript
// Main dashboard controller
export interface DashboardConfig {
  refreshInterval: number;
  metricsRetention: number;
  alertThresholds: AlertThresholds;
  features: DashboardFeatures;
}

export class StreamDashboardController {
  private activeStreams = new Map<string, StreamMonitor>();
  private metricsAggregator: MetricsAggregator;
  private alertManager: AlertManager;
  private dataSync: DataSyncService;
  
  constructor(
    private config: DashboardConfig,
    private analytics: AnalyticsService,
    private storage: DashboardStorage
  ) {
    this.metricsAggregator = new MetricsAggregator();
    this.alertManager = new AlertManager(config.alertThresholds);
    this.dataSync = new DataSyncService();
    
    this.initialize();
  }
  
  private async initialize() {
    // Load saved dashboard state
    const savedState = await this.storage.loadDashboardState();
    if (savedState) {
      await this.restoreState(savedState);
    }
    
    // Start real-time monitoring
    this.startMonitoring();
    
    // Initialize data sync
    this.dataSync.on('update', (data) => this.handleDataUpdate(data));
    await this.dataSync.connect();
  }
  
  async addStreamMonitor(streamId: string): Promise<StreamMonitor> {
    if (this.activeStreams.has(streamId)) {
      return this.activeStreams.get(streamId)!;
    }
    
    const monitor = new StreamMonitor({
      streamId,
      refreshInterval: this.config.refreshInterval,
      metrics: {
        viewers: { current: 0, peak: 0, average: 0 },
        quality: { bitrate: 0, fps: 0, resolution: '' },
        engagement: { messages: 0, reactions: 0, shares: 0 },
        technical: { cpu: 0, bandwidth: 0, latency: 0 }
      }
    });
    
    // Set up monitoring
    monitor.on('metrics', (metrics) => this.handleMetricsUpdate(streamId, metrics));
    monitor.on('alert', (alert) => this.alertManager.handleAlert(streamId, alert));
    monitor.on('error', (error) => this.handleMonitorError(streamId, error));
    
    await monitor.start();
    this.activeStreams.set(streamId, monitor);
    
    return monitor;
  }
  
  private async handleMetricsUpdate(
    streamId: string,
    metrics: StreamMetrics
  ) {
    // Aggregate metrics
    await this.metricsAggregator.addMetrics(streamId, metrics);
    
    // Check for anomalies
    const anomalies = await this.detectAnomalies(streamId, metrics);
    if (anomalies.length > 0) {
      await this.alertManager.handleAnomalies(streamId, anomalies);
    }
    
    // Update dashboard state
    await this.updateDashboardState();
    
    // Broadcast to connected clients
    this.dataSync.broadcast('metrics_update', {
      streamId,
      metrics,
      timestamp: Date.now()
    });
  }
  
  private async detectAnomalies(
    streamId: string,
    metrics: StreamMetrics
  ): Promise<Anomaly[]> {
    const anomalies: Anomaly[] = [];
    const historical = await this.metricsAggregator.getHistoricalMetrics(streamId);
    
    // Sudden viewer drop
    if (historical.viewers.average > 10 && 
        metrics.viewers.current < historical.viewers.average * 0.5) {
      anomalies.push({
        type: 'viewer_drop',
        severity: 'warning',
        message: 'Significant viewer drop detected',
        data: {
          current: metrics.viewers.current,
          average: historical.viewers.average,
          dropPercentage: ((historical.viewers.average - metrics.viewers.current) / 
                          historical.viewers.average) * 100
        }
      });
    }
    
    // Quality degradation
    if (metrics.quality.bitrate < this.config.alertThresholds.minBitrate) {
      anomalies.push({
        type: 'low_bitrate',
        severity: 'error',
        message: 'Stream bitrate below acceptable threshold',
        data: {
          current: metrics.quality.bitrate,
          threshold: this.config.alertThresholds.minBitrate
        }
      });
    }
    
    // High latency
    if (metrics.technical.latency > this.config.alertThresholds.maxLatency) {
      anomalies.push({
        type: 'high_latency',
        severity: 'warning',
        message: 'High latency detected',
        data: {
          current: metrics.technical.latency,
          threshold: this.config.alertThresholds.maxLatency
        }
      });
    }
    
    return anomalies;
  }
  
  async getDashboardData(
    filters: DashboardFilters = {}
  ): Promise<DashboardData> {
    const streams = Array.from(this.activeStreams.values())
      .filter(stream => this.matchesFilters(stream, filters));
    
    const aggregatedMetrics = await this.metricsAggregator.getAggregatedMetrics({
      streams: streams.map(s => s.streamId),
      timeRange: filters.timeRange || 'last_hour'
    });
    
    const alerts = await this.alertManager.getActiveAlerts();
    const insights = await this.generateInsights(aggregatedMetrics);
    
    return {
      summary: {
        totalStreams: streams.length,
        totalViewers: aggregatedMetrics.totalViewers,
        avgQuality: aggregatedMetrics.avgQuality,
        totalBandwidth: aggregatedMetrics.totalBandwidth,
        healthScore: this.calculateHealthScore(aggregatedMetrics)
      },
      streams: streams.map(s => s.getSnapshot()),
      metrics: aggregatedMetrics,
      alerts,
      insights,
      lastUpdated: Date.now()
    };
  }
  
  private calculateHealthScore(metrics: AggregatedMetrics): number {
    let score = 100;
    
    // Deduct points for quality issues
    const avgBitrate = metrics.avgQuality.bitrate;
    if (avgBitrate < 1000000) score -= 20;
    else if (avgBitrate < 2000000) score -= 10;
    
    // Deduct for high error rates
    if (metrics.errorRate > 0.05) score -= 30;
    else if (metrics.errorRate > 0.01) score -= 15;
    
    // Deduct for poor engagement
    const engagementRate = metrics.engagement.total / Math.max(1, metrics.totalViewers);
    if (engagementRate < 0.1) score -= 10;
    
    return Math.max(0, Math.min(100, score));
  }
  
  private async generateInsights(
    metrics: AggregatedMetrics
  ): Promise<DashboardInsight[]> {
    const insights: DashboardInsight[] = [];
    
    // Peak time insight
    if (metrics.peakHour) {
      insights.push({
        id: 'peak_time',
        type: 'optimization',
        title: 'Optimal Streaming Time',
        description: `Your streams get the most viewers at ${formatHour(metrics.peakHour)}`,
        priority: 'medium',
        actionable: true,
        actions: [{
          label: 'Schedule Stream',
          action: 'schedule_stream',
          data: { suggestedTime: metrics.peakHour }
        }]
      });
    }
    
    // Quality optimization
    if (metrics.avgQuality.bitrate < 2000000 && metrics.bandwidth.available > 5000000) {
      insights.push({
        id: 'quality_upgrade',
        type: 'improvement',
        title: 'Stream Quality Can Be Improved',
        description: 'You have bandwidth available to stream at higher quality',
        priority: 'high',
        actionable: true,
        actions: [{
          label: 'Increase Quality',
          action: 'update_quality',
          data: { suggestedBitrate: 3000000 }
        }]
      });
    }
    
    // Engagement insight
    const engagementTrend = await this.calculateEngagementTrend();
    if (engagementTrend.direction === 'down' && engagementTrend.change > 20) {
      insights.push({
        id: 'engagement_drop',
        type: 'alert',
        title: 'Viewer Engagement Declining',
        description: `Engagement has dropped ${engagementTrend.change.toFixed(0)}% this week`,
        priority: 'high',
        actionable: true,
        actions: [{
          label: 'View Engagement Report',
          action: 'view_report',
          data: { reportType: 'engagement' }
        }]
      });
    }
    
    return insights;
  }
}
```

### 2. Real-time Monitoring Components
```tsx
export function StreamDashboard() {
  const [dashboardData, setDashboardData] = useState<DashboardData>();
  const [selectedStream, setSelectedStream] = useState<string | null>(null);
  const [timeRange, setTimeRange] = useState<TimeRange>('last_hour');
  const [view, setView] = useState<'overview' | 'detailed'>('overview');
  const [alerts, setAlerts] = useState<Alert[]>([]);
  
  const dashboardController = useRef<StreamDashboardController>();
  
  useEffect(() => {
    initializeDashboard();
    
    return () => {
      dashboardController.current?.disconnect();
    };
  }, []);
  
  const initializeDashboard = async () => {
    const controller = new StreamDashboardController({
      refreshInterval: 5000,
      metricsRetention: 86400000, // 24 hours
      alertThresholds: {
        minBitrate: 500000,
        maxLatency: 200,
        minViewers: 1,
        maxCPU: 80
      },
      features: {
        realTimeMetrics: true,
        historicalAnalytics: true,
        alerting: true,
        multiStream: true
      }
    });
    
    controller.on('update', (data) => setDashboardData(data));
    controller.on('alert', (alert) => setAlerts(prev => [alert, ...prev]));
    
    await controller.connect();
    dashboardController.current = controller;
    
    // Load initial data
    const initialData = await controller.getDashboardData();
    setDashboardData(initialData);
  };
  
  if (!dashboardData) return <DashboardSkeleton />;
  
  return (
    <div className="stream-dashboard">
      <DashboardHeader
        summary={dashboardData.summary}
        onRefresh={() => dashboardController.current?.refresh()}
      />
      
      {alerts.length > 0 && (
        <AlertBanner
          alerts={alerts}
          onDismiss={(id) => setAlerts(prev => prev.filter(a => a.id !== id))}
          onAction={(alert, action) => handleAlertAction(alert, action)}
        />
      )}
      
      <div className="dashboard-controls">
        <TimeRangeSelector
          value={timeRange}
          onChange={setTimeRange}
          options={['last_hour', 'last_24h', 'last_week', 'last_month']}
        />
        
        <ViewToggle
          value={view}
          onChange={setView}
          options={[
            { value: 'overview', label: 'Overview', icon: <GridIcon /> },
            { value: 'detailed', label: 'Detailed', icon: <ListIcon /> }
          ]}
        />
        
        <Button
          variant="secondary"
          leftIcon={<ExportIcon />}
          onClick={() => exportDashboard()}
        >
          Export Report
        </Button>
      </div>
      
      {dashboardData.insights.length > 0 && (
        <InsightsPanel
          insights={dashboardData.insights}
          onAction={(insight, action) => handleInsightAction(insight, action)}
        />
      )}
      
      {view === 'overview' ? (
        <DashboardOverview
          data={dashboardData}
          onStreamSelect={setSelectedStream}
        />
      ) : (
        <DashboardDetailed
          data={dashboardData}
          selectedStream={selectedStream}
          onStreamSelect={setSelectedStream}
        />
      )}
    </div>
  );
}

export function DashboardOverview({
  data,
  onStreamSelect
}: {
  data: DashboardData;
  onStreamSelect: (streamId: string) => void;
}) {
  return (
    <div className="dashboard-overview">
      <div className="metrics-grid">
        <MetricCard
          title="Total Viewers"
          value={data.summary.totalViewers}
          trend={data.metrics.viewerTrend}
          icon={<UsersIcon />}
          onClick={() => showDetailedMetric('viewers')}
        />
        
        <MetricCard
          title="Avg Quality Score"
          value={`${data.summary.avgQuality.score}/100`}
          trend={data.metrics.qualityTrend}
          icon={<SignalIcon />}
          color={getQualityColor(data.summary.avgQuality.score)}
        />
        
        <MetricCard
          title="Total Bandwidth"
          value={formatBandwidth(data.summary.totalBandwidth)}
          trend={data.metrics.bandwidthTrend}
          icon={<ActivityIcon />}
        />
        
        <MetricCard
          title="Health Score"
          value={`${data.summary.healthScore}%`}
          icon={<HeartIcon />}
          color={getHealthColor(data.summary.healthScore)}
        />
      </div>
      
      <div className="dashboard-grid">
        <StreamGrid
          streams={data.streams}
          onStreamClick={onStreamSelect}
        />
        
        <PerformanceChart
          data={data.metrics.performance}
          timeRange={data.timeRange}
        />
        
        <EngagementHeatmap
          data={data.metrics.engagement}
        />
        
        <TopStreamsTable
          streams={data.streams}
          sortBy="viewers"
          limit={5}
        />
      </div>
    </div>
  );
}

export function StreamGrid({
  streams,
  onStreamClick
}: {
  streams: StreamSnapshot[];
  onStreamClick: (streamId: string) => void;
}) {
  return (
    <div className="stream-grid">
      <h3>Active Streams</h3>
      
      <div className="grid-container">
        {streams.map(stream => (
          <StreamCard
            key={stream.id}
            stream={stream}
            onClick={() => onStreamClick(stream.id)}
          />
        ))}
      </div>
      
      {streams.length === 0 && (
        <EmptyState
          icon={<StreamIcon />}
          title="No Active Streams"
          description="Start a stream to see it here"
          action={{
            label: "Start Streaming",
            onClick: () => navigateToStreamSetup()
          }}
        />
      )}
    </div>
  );
}

export function StreamCard({
  stream,
  onClick
}: {
  stream: StreamSnapshot;
  onClick: () => void;
}) {
  const [isHovered, setIsHovered] = useState(false);
  
  return (
    <div
      className="stream-card"
      onClick={onClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <div className="card-preview">
        {stream.thumbnail ? (
          <img src={stream.thumbnail} alt={stream.title} />
        ) : (
          <div className="preview-placeholder">
            <AudioWaveform active={stream.isLive} />
          </div>
        )}
        
        {stream.isLive && (
          <Badge variant="live" className="live-badge">
            LIVE
          </Badge>
        )}
        
        <div className="viewer-count">
          <UsersIcon size="small" />
          <span>{stream.viewers.current}</span>
        </div>
      </div>
      
      <div className="card-info">
        <h4>{stream.title}</h4>
        <p className="stream-channel">{stream.channelName}</p>
        
        <div className="card-metrics">
          <MetricBadge
            icon={<SignalIcon />}
            value={`${stream.quality.bitrate / 1000}k`}
            status={stream.quality.stable ? 'good' : 'warning'}
          />
          
          <MetricBadge
            icon={<ClockIcon />}
            value={formatDuration(stream.duration)}
          />
          
          <MetricBadge
            icon={<MessageIcon />}
            value={stream.engagement.messages}
          />
        </div>
      </div>
      
      {isHovered && (
        <div className="card-overlay">
          <Button
            variant="primary"
            size="small"
            onClick={(e) => {
              e.stopPropagation();
              navigateToStreamDetail(stream.id);
            }}
          >
            Manage Stream
          </Button>
        </div>
      )}
    </div>
  );
}
```

### 3. Analytics and Insights Engine
```typescript
// Advanced analytics processing
export class StreamAnalyticsEngine {
  private metricsCache = new Map<string, MetricsCache>();
  private mlModels: MLModels;
  
  constructor(
    private storage: AnalyticsStorage,
    private config: AnalyticsConfig
  ) {
    this.mlModels = new MLModels();
    this.initializeModels();
  }
  
  private async initializeModels() {
    // Load pre-trained models for predictions
    await this.mlModels.load({
      viewerPrediction: '/models/viewer-prediction.json',
      qualityOptimization: '/models/quality-optimization.json',
      engagementAnalysis: '/models/engagement-analysis.json'
    });
  }
  
  async analyzeStream(
    streamId: string,
    timeRange: TimeRange
  ): Promise<StreamAnalysis> {
    const metrics = await this.storage.getMetrics(streamId, timeRange);
    const cache = this.getOrCreateCache(streamId);
    
    // Update cache with latest metrics
    cache.update(metrics);
    
    // Perform various analyses
    const [
      viewerAnalysis,
      qualityAnalysis,
      engagementAnalysis,
      performanceAnalysis
    ] = await Promise.all([
      this.analyzeViewerBehavior(cache),
      this.analyzeStreamQuality(cache),
      this.analyzeEngagement(cache),
      this.analyzePerformance(cache)
    ]);
    
    // Generate predictions
    const predictions = await this.generatePredictions(cache);
    
    // Identify optimization opportunities
    const optimizations = await this.identifyOptimizations({
      viewerAnalysis,
      qualityAnalysis,
      engagementAnalysis,
      performanceAnalysis
    });
    
    return {
      streamId,
      timeRange,
      analyses: {
        viewers: viewerAnalysis,
        quality: qualityAnalysis,
        engagement: engagementAnalysis,
        performance: performanceAnalysis
      },
      predictions,
      optimizations,
      score: this.calculateOverallScore({
        viewerAnalysis,
        qualityAnalysis,
        engagementAnalysis,
        performanceAnalysis
      })
    };
  }
  
  private async analyzeViewerBehavior(
    cache: MetricsCache
  ): Promise<ViewerAnalysis> {
    const viewerMetrics = cache.getViewerMetrics();
    
    // Calculate key metrics
    const avgViewDuration = this.calculateAverageViewDuration(viewerMetrics);
    const churnRate = this.calculateChurnRate(viewerMetrics);
    const growthRate = this.calculateGrowthRate(viewerMetrics);
    
    // Identify patterns
    const patterns = await this.identifyViewerPatterns(viewerMetrics);
    
    // Segment viewers
    const segments = await this.segmentViewers(viewerMetrics);
    
    return {
      summary: {
        totalViewers: viewerMetrics.total,
        avgConcurrent: viewerMetrics.avgConcurrent,
        peakViewers: viewerMetrics.peak,
        avgViewDuration,
        churnRate,
        growthRate
      },
      patterns: {
        peakTimes: patterns.peakTimes,
        viewerFlow: patterns.viewerFlow,
        geographicDistribution: patterns.geographic
      },
      segments: {
        loyal: segments.loyal,
        casual: segments.casual,
        new: segments.new
      },
      insights: await this.generateViewerInsights(viewerMetrics, patterns, segments)
    };
  }
  
  private async analyzeStreamQuality(
    cache: MetricsCache
  ): Promise<QualityAnalysis> {
    const qualityMetrics = cache.getQualityMetrics();
    
    // Calculate stability metrics
    const bitrateStability = this.calculateStability(
      qualityMetrics.bitrate.samples
    );
    const frameRateStability = this.calculateStability(
      qualityMetrics.frameRate.samples
    );
    
    // Identify quality issues
    const issues = await this.identifyQualityIssues(qualityMetrics);
    
    // Calculate quality score
    const qualityScore = this.calculateQualityScore({
      bitrate: qualityMetrics.bitrate.average,
      frameRate: qualityMetrics.frameRate.average,
      resolution: qualityMetrics.resolution,
      stability: (bitrateStability + frameRateStability) / 2,
      issues: issues.length
    });
    
    return {
      score: qualityScore,
      metrics: {
        avgBitrate: qualityMetrics.bitrate.average,
        avgFrameRate: qualityMetrics.frameRate.average,
        resolution: qualityMetrics.resolution,
        codec: qualityMetrics.codec
      },
      stability: {
        bitrate: bitrateStability,
        frameRate: frameRateStability,
        overall: (bitrateStability + frameRateStability) / 2
      },
      issues,
      recommendations: await this.generateQualityRecommendations(
        qualityMetrics,
        issues
      )
    };
  }
  
  private async generatePredictions(
    cache: MetricsCache
  ): Promise<StreamPredictions> {
    const historicalData = cache.getHistoricalData();
    
    // Viewer count prediction
    const viewerPrediction = await this.mlModels.predict('viewerPrediction', {
      historical: historicalData.viewers,
      dayOfWeek: new Date().getDay(),
      hour: new Date().getHours(),
      features: cache.getFeatures()
    });
    
    // Engagement prediction
    const engagementPrediction = await this.mlModels.predict('engagementAnalysis', {
      viewerCount: viewerPrediction.value,
      historical: historicalData.engagement,
      contentType: cache.getContentType()
    });
    
    // Quality requirements prediction
    const qualityPrediction = await this.mlModels.predict('qualityOptimization', {
      predictedViewers: viewerPrediction.value,
      networkConditions: cache.getNetworkConditions(),
      historicalQuality: historicalData.quality
    });
    
    return {
      viewers: {
        next1Hour: viewerPrediction.value,
        confidence: viewerPrediction.confidence,
        range: viewerPrediction.range
      },
      engagement: {
        expectedMessages: engagementPrediction.messages,
        expectedReactions: engagementPrediction.reactions,
        confidence: engagementPrediction.confidence
      },
      quality: {
        recommendedBitrate: qualityPrediction.bitrate,
        recommendedResolution: qualityPrediction.resolution,
        bandwidthRequired: qualityPrediction.bandwidth
      }
    };
  }
  
  private async identifyOptimizations(
    analyses: any
  ): Promise<Optimization[]> {
    const optimizations: Optimization[] = [];
    
    // Viewer retention optimization
    if (analyses.viewerAnalysis.summary.churnRate > 0.3) {
      optimizations.push({
        id: 'reduce_churn',
        category: 'retention',
        title: 'High Viewer Churn Detected',
        description: `${(analyses.viewerAnalysis.summary.churnRate * 100).toFixed(0)}% of viewers leave within 5 minutes`,
        impact: 'high',
        effort: 'medium',
        recommendations: [
          'Improve stream introduction',
          'Enhance audio quality in first minute',
          'Add welcome message for new viewers'
        ],
        estimatedImprovement: {
          metric: 'avgViewDuration',
          increase: '25%'
        }
      });
    }
    
    // Quality optimization
    if (analyses.qualityAnalysis.stability.overall < 0.8) {
      optimizations.push({
        id: 'improve_stability',
        category: 'quality',
        title: 'Stream Stability Can Be Improved',
        description: 'Frequent bitrate fluctuations detected',
        impact: 'high',
        effort: 'low',
        recommendations: [
          'Use CBR instead of VBR encoding',
          'Reduce keyframe interval',
          'Check network stability'
        ],
        estimatedImprovement: {
          metric: 'qualityScore',
          increase: '15%'
        }
      });
    }
    
    // Engagement optimization
    const engagementRate = analyses.engagementAnalysis.summary.totalEngagements / 
                          analyses.viewerAnalysis.summary.totalViewers;
    
    if (engagementRate < 0.2) {
      optimizations.push({
        id: 'boost_engagement',
        category: 'engagement',
        title: 'Low Viewer Engagement',
        description: 'Most viewers are passive',
        impact: 'medium',
        effort: 'low',
        recommendations: [
          'Ask questions to audience',
          'Run interactive polls',
          'Acknowledge active chatters',
          'Create engagement incentives'
        ],
        estimatedImprovement: {
          metric: 'engagementRate',
          increase: '40%'
        }
      });
    }
    
    return optimizations;
  }
}
```

### 4. Stream Management Controls
```tsx
export function StreamManagementPanel({
  streamId
}: {
  streamId: string;
}) {
  const [stream, setStream] = useState<StreamDetails>();
  const [activeTab, setActiveTab] = useState<'overview' | 'settings' | 'moderation' | 'analytics'>('overview');
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    loadStreamDetails();
  }, [streamId]);
  
  const loadStreamDetails = async () => {
    setIsLoading(true);
    try {
      const details = await api.getStreamDetails(streamId);
      setStream(details);
    } finally {
      setIsLoading(false);
    }
  };
  
  if (isLoading || !stream) return <LoadingSpinner />;
  
  return (
    <div className="stream-management-panel">
      <div className="panel-header">
        <div className="stream-info">
          <h2>{stream.title}</h2>
          <div className="stream-status">
            {stream.isLive ? (
              <Badge variant="live">LIVE</Badge>
            ) : (
              <Badge variant="offline">OFFLINE</Badge>
            )}
            <span className="viewer-count">
              <UsersIcon /> {stream.viewers.current} viewers
            </span>
          </div>
        </div>
        
        <div className="panel-actions">
          {stream.isLive ? (
            <>
              <Button
                variant="secondary"
                leftIcon={<PauseIcon />}
                onClick={() => pauseStream(streamId)}
              >
                Pause
              </Button>
              <Button
                variant="danger"
                leftIcon={<StopIcon />}
                onClick={() => stopStream(streamId)}
              >
                End Stream
              </Button>
            </>
          ) : (
            <Button
              variant="primary"
              leftIcon={<PlayIcon />}
              onClick={() => startStream(streamId)}
            >
              Go Live
            </Button>
          )}
        </div>
      </div>
      
      <TabBar
        value={activeTab}
        onChange={setActiveTab}
        tabs={[
          { value: 'overview', label: 'Overview', icon: <DashboardIcon /> },
          { value: 'settings', label: 'Settings', icon: <SettingsIcon /> },
          { value: 'moderation', label: 'Moderation', icon: <ShieldIcon /> },
          { value: 'analytics', label: 'Analytics', icon: <ChartIcon /> }
        ]}
      />
      
      <div className="panel-content">
        {activeTab === 'overview' && (
          <StreamOverviewTab stream={stream} />
        )}
        
        {activeTab === 'settings' && (
          <StreamSettingsTab
            stream={stream}
            onUpdate={loadStreamDetails}
          />
        )}
        
        {activeTab === 'moderation' && (
          <StreamModerationTab stream={stream} />
        )}
        
        {activeTab === 'analytics' && (
          <StreamAnalyticsTab stream={stream} />
        )}
      </div>
    </div>
  );
}

export function StreamOverviewTab({
  stream
}: {
  stream: StreamDetails;
}) {
  const [realtimeMetrics, setRealtimeMetrics] = useState<RealtimeMetrics>();
  
  useEffect(() => {
    const subscription = subscribeToMetrics(stream.id, (metrics) => {
      setRealtimeMetrics(metrics);
    });
    
    return () => subscription.unsubscribe();
  }, [stream.id]);
  
  return (
    <div className="stream-overview">
      <div className="overview-grid">
        <HealthMonitor
          health={stream.health}
          alerts={stream.activeAlerts}
        />
        
        <RealtimeMetricsDisplay
          metrics={realtimeMetrics}
          baseline={stream.baseline}
        />
        
        <ViewerMap
          viewers={stream.viewers.geographic}
          heatmap={true}
        />
        
        <EngagementFeed
          activities={stream.recentActivities}
          limit={10}
        />
      </div>
      
      <div className="quick-actions">
        <h3>Quick Actions</h3>
        
        <div className="actions-grid">
          <ActionCard
            icon={<MicIcon />}
            title="Audio Settings"
            description="Adjust audio levels and quality"
            onClick={() => openAudioSettings(stream.id)}
          />
          
          <ActionCard
            icon={<UsersIcon />}
            title="Viewer List"
            description="See who's watching"
            onClick={() => openViewerList(stream.id)}
          />
          
          <ActionCard
            icon={<MessageIcon />}
            title="Send Announcement"
            description="Broadcast a message"
            onClick={() => openAnnouncementDialog(stream.id)}
          />
          
          <ActionCard
            icon={<RecordIcon />}
            title="Recording"
            description={stream.isRecording ? 'Stop recording' : 'Start recording'}
            onClick={() => toggleRecording(stream.id)}
            active={stream.isRecording}
          />
        </div>
      </div>
    </div>
  );
}

export function StreamModerationTab({
  stream
}: {
  stream: StreamDetails;
}) {
  const [moderationQueue, setModerationQueue] = useState<ModerationItem[]>([]);
  const [autoModSettings, setAutoModSettings] = useState<AutoModSettings>();
  const [blockedUsers, setBlockedUsers] = useState<BlockedUser[]>([]);
  
  useEffect(() => {
    loadModerationData();
  }, [stream.id]);
  
  const loadModerationData = async () => {
    const [queue, settings, blocked] = await Promise.all([
      api.getModerationQueue(stream.id),
      api.getAutoModSettings(stream.id),
      api.getBlockedUsers(stream.id)
    ]);
    
    setModerationQueue(queue);
    setAutoModSettings(settings);
    setBlockedUsers(blocked);
  };
  
  const handleModerationAction = async (
    item: ModerationItem,
    action: 'approve' | 'reject' | 'timeout' | 'ban'
  ) => {
    await api.moderateItem(item.id, action);
    await loadModerationData();
    
    toast.success(`Action completed: ${action}`);
  };
  
  return (
    <div className="stream-moderation">
      <div className="moderation-header">
        <h3>Content Moderation</h3>
        <Button
          variant="secondary"
          leftIcon={<SettingsIcon />}
          onClick={() => openAutoModSettings()}
        >
          AutoMod Settings
        </Button>
      </div>
      
      {moderationQueue.length > 0 ? (
        <div className="moderation-queue">
          <h4>Pending Review ({moderationQueue.length})</h4>
          
          {moderationQueue.map(item => (
            <ModerationCard
              key={item.id}
              item={item}
              onAction={(action) => handleModerationAction(item, action)}
            />
          ))}
        </div>
      ) : (
        <EmptyState
          icon={<CheckIcon />}
          title="All Clear"
          description="No items pending moderation"
        />
      )}
      
      <div className="moderation-settings">
        <h4>AutoMod Configuration</h4>
        
        <AutoModControls
          settings={autoModSettings}
          onChange={async (newSettings) => {
            await api.updateAutoModSettings(stream.id, newSettings);
            setAutoModSettings(newSettings);
          }}
        />
      </div>
      
      <div className="blocked-users">
        <h4>Blocked Users ({blockedUsers.length})</h4>
        
        <BlockedUsersList
          users={blockedUsers}
          onUnblock={async (userId) => {
            await api.unblockUser(stream.id, userId);
            await loadModerationData();
          }}
        />
      </div>
    </div>
  );
}
```

### 5. Performance Monitoring
```typescript
// Performance and health monitoring
export class StreamPerformanceMonitor {
  private metrics = new Map<string, PerformanceMetrics>();
  private healthChecks = new Map<string, HealthCheck>();
  private alertThresholds: AlertThresholds;
  
  constructor(
    private config: MonitorConfig,
    private alerting: AlertingService
  ) {
    this.alertThresholds = config.alertThresholds;
    this.startMonitoring();
  }
  
  private startMonitoring() {
    // CPU monitoring
    setInterval(() => this.checkCPUUsage(), 5000);
    
    // Memory monitoring
    setInterval(() => this.checkMemoryUsage(), 10000);
    
    // Network monitoring
    setInterval(() => this.checkNetworkHealth(), 3000);
    
    // Stream health checks
    setInterval(() => this.performHealthChecks(), 15000);
  }
  
  async addStream(streamId: string, config: StreamConfig) {
    const metrics: PerformanceMetrics = {
      streamId,
      cpu: { current: 0, average: 0, peak: 0 },
      memory: { used: 0, available: 0, percentage: 0 },
      network: {
        bandwidth: { in: 0, out: 0 },
        latency: { current: 0, average: 0 },
        packetLoss: 0,
        jitter: 0
      },
      encoding: {
        fps: { current: 0, target: config.targetFPS },
        bitrate: { current: 0, target: config.targetBitrate },
        droppedFrames: 0,
        keyframeInterval: config.keyframeInterval
      },
      errors: [],
      warnings: []
    };
    
    this.metrics.set(streamId, metrics);
    
    // Initialize health check
    this.healthChecks.set(streamId, {
      status: 'healthy',
      lastCheck: Date.now(),
      issues: []
    });
  }
  
  private async checkCPUUsage() {
    for (const [streamId, metrics] of this.metrics) {
      const usage = await this.getCPUUsage(streamId);
      
      metrics.cpu.current = usage;
      metrics.cpu.average = this.updateMovingAverage(
        metrics.cpu.average,
        usage,
        0.1
      );
      metrics.cpu.peak = Math.max(metrics.cpu.peak, usage);
      
      // Check threshold
      if (usage > this.alertThresholds.maxCPU) {
        await this.alerting.sendAlert({
          streamId,
          type: 'performance',
          severity: 'warning',
          message: `High CPU usage: ${usage.toFixed(1)}%`,
          data: { cpu: usage, threshold: this.alertThresholds.maxCPU }
        });
      }
    }
  }
  
  private async checkNetworkHealth() {
    for (const [streamId, metrics] of this.metrics) {
      const networkStats = await this.getNetworkStats(streamId);
      
      // Update metrics
      metrics.network.bandwidth = networkStats.bandwidth;
      metrics.network.latency.current = networkStats.latency;
      metrics.network.latency.average = this.updateMovingAverage(
        metrics.network.latency.average,
        networkStats.latency,
        0.2
      );
      metrics.network.packetLoss = networkStats.packetLoss;
      metrics.network.jitter = networkStats.jitter;
      
      // Check for issues
      if (networkStats.packetLoss > this.alertThresholds.maxPacketLoss) {
        metrics.warnings.push({
          type: 'network',
          message: `High packet loss: ${networkStats.packetLoss.toFixed(1)}%`,
          timestamp: Date.now()
        });
      }
      
      if (networkStats.latency > this.alertThresholds.maxLatency) {
        metrics.warnings.push({
          type: 'network',
          message: `High latency: ${networkStats.latency}ms`,
          timestamp: Date.now()
        });
      }
    }
  }
  
  private async performHealthChecks() {
    for (const [streamId, healthCheck] of this.healthChecks) {
      const metrics = this.metrics.get(streamId);
      if (!metrics) continue;
      
      const issues: HealthIssue[] = [];
      
      // Check encoding health
      if (metrics.encoding.fps.current < metrics.encoding.fps.target * 0.8) {
        issues.push({
          type: 'encoding',
          severity: 'warning',
          message: 'Frame rate below target',
          data: {
            current: metrics.encoding.fps.current,
            target: metrics.encoding.fps.target
          }
        });
      }
      
      // Check for dropped frames
      if (metrics.encoding.droppedFrames > 100) {
        issues.push({
          type: 'encoding',
          severity: 'error',
          message: `${metrics.encoding.droppedFrames} frames dropped`,
          impact: 'Viewers may experience stuttering'
        });
      }
      
      // Check bitrate stability
      const bitrateVariance = this.calculateVariance(
        metrics.encoding.bitrate.current,
        metrics.encoding.bitrate.target
      );
      
      if (bitrateVariance > 0.2) {
        issues.push({
          type: 'quality',
          severity: 'warning',
          message: 'Unstable bitrate detected',
          data: {
            variance: bitrateVariance,
            current: metrics.encoding.bitrate.current,
            target: metrics.encoding.bitrate.target
          }
        });
      }
      
      // Update health status
      healthCheck.status = issues.length === 0 ? 'healthy' :
                          issues.some(i => i.severity === 'error') ? 'critical' :
                          'warning';
      healthCheck.issues = issues;
      healthCheck.lastCheck = Date.now();
      
      // Send alerts for critical issues
      if (healthCheck.status === 'critical') {
        await this.alerting.sendAlert({
          streamId,
          type: 'health',
          severity: 'error',
          message: 'Stream health critical',
          data: { issues }
        });
      }
    }
  }
  
  getStreamHealth(streamId: string): StreamHealth {
    const metrics = this.metrics.get(streamId);
    const healthCheck = this.healthChecks.get(streamId);
    
    if (!metrics || !healthCheck) {
      return { status: 'unknown', score: 0 };
    }
    
    // Calculate health score
    let score = 100;
    
    // CPU impact
    if (metrics.cpu.average > 80) score -= 15;
    else if (metrics.cpu.average > 60) score -= 5;
    
    // Network impact
    if (metrics.network.packetLoss > 1) score -= 20;
    else if (metrics.network.packetLoss > 0.1) score -= 10;
    
    if (metrics.network.latency.average > 100) score -= 10;
    else if (metrics.network.latency.average > 50) score -= 5;
    
    // Encoding impact
    const fpsRatio = metrics.encoding.fps.current / metrics.encoding.fps.target;
    if (fpsRatio < 0.9) score -= 15;
    else if (fpsRatio < 0.95) score -= 5;
    
    // Issue impact
    score -= healthCheck.issues.length * 5;
    
    return {
      status: healthCheck.status,
      score: Math.max(0, Math.min(100, score)),
      metrics,
      issues: healthCheck.issues,
      lastCheck: healthCheck.lastCheck
    };
  }
}
```

### 6. Dashboard Reports and Export
```typescript
// Report generation and export functionality
export class DashboardReportGenerator {
  constructor(
    private analytics: AnalyticsService,
    private storage: ReportStorage,
    private pdf: PDFService
  ) {}
  
  async generateReport(
    params: ReportParams
  ): Promise<Report> {
    const reportId = crypto.randomUUID();
    
    // Gather data
    const data = await this.gatherReportData(params);
    
    // Generate sections
    const sections = await this.generateSections(data, params);
    
    // Create report
    const report: Report = {
      id: reportId,
      title: params.title || `Stream Report - ${formatDate(Date.now())}`,
      period: params.period,
      generatedAt: Date.now(),
      generatedBy: params.userId,
      sections,
      format: params.format,
      data
    };
    
    // Generate file
    const file = await this.generateFile(report, params.format);
    report.file = file;
    
    // Store report
    await this.storage.saveReport(report);
    
    return report;
  }
  
  private async gatherReportData(
    params: ReportParams
  ): Promise<ReportData> {
    const { streamIds, period, metrics } = params;
    
    const data: ReportData = {
      streams: [],
      aggregated: {},
      comparisons: {},
      insights: []
    };
    
    // Gather stream data
    for (const streamId of streamIds) {
      const streamData = await this.analytics.getStreamData(streamId, period);
      data.streams.push(streamData);
    }
    
    // Aggregate metrics
    if (metrics.includes('viewers')) {
      data.aggregated.viewers = await this.aggregateViewerMetrics(data.streams);
    }
    
    if (metrics.includes('quality')) {
      data.aggregated.quality = await this.aggregateQualityMetrics(data.streams);
    }
    
    if (metrics.includes('engagement')) {
      data.aggregated.engagement = await this.aggregateEngagementMetrics(data.streams);
    }
    
    // Generate comparisons
    if (streamIds.length > 1) {
      data.comparisons = await this.generateComparisons(data.streams);
    }
    
    // Generate insights
    data.insights = await this.generateInsights(data);
    
    return data;
  }
  
  private async generateSections(
    data: ReportData,
    params: ReportParams
  ): Promise<ReportSection[]> {
    const sections: ReportSection[] = [];
    
    // Executive Summary
    sections.push({
      id: 'summary',
      title: 'Executive Summary',
      content: await this.generateSummary(data),
      charts: await this.generateSummaryCharts(data)
    });
    
    // Stream Performance
    if (params.metrics.includes('performance')) {
      sections.push({
        id: 'performance',
        title: 'Stream Performance',
        content: await this.generatePerformanceSection(data),
        charts: await this.generatePerformanceCharts(data),
        tables: await this.generatePerformanceTables(data)
      });
    }
    
    // Viewer Analytics
    if (params.metrics.includes('viewers')) {
      sections.push({
        id: 'viewers',
        title: 'Viewer Analytics',
        content: await this.generateViewerSection(data),
        charts: await this.generateViewerCharts(data),
        insights: data.insights.filter(i => i.category === 'viewers')
      });
    }
    
    // Quality Metrics
    if (params.metrics.includes('quality')) {
      sections.push({
        id: 'quality',
        title: 'Quality Metrics',
        content: await this.generateQualitySection(data),
        charts: await this.generateQualityCharts(data),
        recommendations: await this.generateQualityRecommendations(data)
      });
    }
    
    // Engagement Analysis
    if (params.metrics.includes('engagement')) {
      sections.push({
        id: 'engagement',
        title: 'Engagement Analysis',
        content: await this.generateEngagementSection(data),
        charts: await this.generateEngagementCharts(data),
        topContent: await this.identifyTopContent(data)
      });
    }
    
    // Recommendations
    sections.push({
      id: 'recommendations',
      title: 'Recommendations',
      content: await this.generateRecommendations(data),
      actionItems: await this.generateActionItems(data)
    });
    
    return sections;
  }
  
  private async generateFile(
    report: Report,
    format: 'pdf' | 'csv' | 'json'
  ): Promise<ReportFile> {
    switch (format) {
      case 'pdf':
        return this.generatePDF(report);
      case 'csv':
        return this.generateCSV(report);
      case 'json':
        return this.generateJSON(report);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  
  private async generatePDF(report: Report): Promise<ReportFile> {
    const doc = await this.pdf.createDocument({
      title: report.title,
      author: 'Waddle Stream Dashboard',
      subject: 'Stream Analytics Report'
    });
    
    // Add cover page
    await this.pdf.addCoverPage(doc, {
      title: report.title,
      subtitle: `Generated on ${formatDate(report.generatedAt)}`,
      logo: '/assets/logo.png'
    });
    
    // Add sections
    for (const section of report.sections) {
      await this.pdf.addSection(doc, {
        title: section.title,
        content: section.content,
        charts: section.charts,
        tables: section.tables
      });
    }
    
    // Generate file
    const pdfBuffer = await doc.save();
    
    return {
      name: `${report.title.replace(/\s+/g, '_')}.pdf`,
      size: pdfBuffer.length,
      type: 'application/pdf',
      data: pdfBuffer,
      url: await this.storage.uploadFile(pdfBuffer, 'pdf')
    };
  }
  
  async scheduleReport(
    schedule: ReportSchedule
  ): Promise<string> {
    const scheduleId = crypto.randomUUID();
    
    await this.storage.saveSchedule({
      id: scheduleId,
      ...schedule,
      nextRun: this.calculateNextRun(schedule.frequency),
      active: true
    });
    
    return scheduleId;
  }
}

// Report UI Component
export function ReportGenerator({
  streamIds,
  onGenerate
}: {
  streamIds: string[];
  onGenerate: (report: Report) => void;
}) {
  const [config, setConfig] = useState<ReportConfig>({
    title: '',
    period: 'last_week',
    metrics: ['viewers', 'quality', 'engagement', 'performance'],
    format: 'pdf',
    includeComparisons: streamIds.length > 1,
    includeRecommendations: true
  });
  
  const [generating, setGenerating] = useState(false);
  
  const generateReport = async () => {
    setGenerating(true);
    
    try {
      const report = await api.generateReport({
        streamIds,
        ...config
      });
      
      onGenerate(report);
      toast.success('Report generated successfully');
    } catch (error) {
      toast.error('Failed to generate report');
    } finally {
      setGenerating(false);
    }
  };
  
  return (
    <div className="report-generator">
      <h3>Generate Report</h3>
      
      <div className="report-config">
        <FormField label="Report Title">
          <Input
            value={config.title}
            onChange={(e) => setConfig({ ...config, title: e.target.value })}
            placeholder="Enter report title..."
          />
        </FormField>
        
        <FormField label="Time Period">
          <Select
            value={config.period}
            onChange={(e) => setConfig({ ...config, period: e.target.value })}
          >
            <option value="last_day">Last 24 Hours</option>
            <option value="last_week">Last 7 Days</option>
            <option value="last_month">Last 30 Days</option>
            <option value="custom">Custom Range</option>
          </Select>
        </FormField>
        
        <FormField label="Include Metrics">
          <CheckboxGroup
            value={config.metrics}
            onChange={(metrics) => setConfig({ ...config, metrics })}
            options={[
              { value: 'viewers', label: 'Viewer Analytics' },
              { value: 'quality', label: 'Quality Metrics' },
              { value: 'engagement', label: 'Engagement Data' },
              { value: 'performance', label: 'Performance Stats' }
            ]}
          />
        </FormField>
        
        <FormField label="Export Format">
          <RadioGroup
            value={config.format}
            onChange={(format) => setConfig({ ...config, format })}
          >
            <Radio value="pdf">PDF Report</Radio>
            <Radio value="csv">CSV Data</Radio>
            <Radio value="json">JSON Export</Radio>
          </RadioGroup>
        </FormField>
        
        <div className="report-options">
          <Toggle
            checked={config.includeComparisons}
            onChange={(includeComparisons) => 
              setConfig({ ...config, includeComparisons })
            }
            label="Include Stream Comparisons"
            disabled={streamIds.length <= 1}
          />
          
          <Toggle
            checked={config.includeRecommendations}
            onChange={(includeRecommendations) => 
              setConfig({ ...config, includeRecommendations })
            }
            label="Include Recommendations"
          />
        </div>
      </div>
      
      <div className="generator-actions">
        <Button
          variant="primary"
          onClick={generateReport}
          disabled={generating}
          leftIcon={generating ? <LoadingSpinner size="small" /> : <FileIcon />}
        >
          {generating ? 'Generating...' : 'Generate Report'}
        </Button>
      </div>
    </div>
  );
}
```

## Dependencies
- Real-time data synchronization
- Analytics processing engine
- Alert management system
- Performance monitoring tools
- Report generation service
- Data visualization libraries

## Estimated Effort
**8 days**
- 2 days: Dashboard architecture and real-time monitoring
- 1 day: Analytics engine and insights
- 1 day: Stream management controls
- 1 day: Performance monitoring
- 1 day: Moderation tools
- 1 day: Report generation
- 1 day: UI components and integration

## Notes
- Implement caching for performance
- Support multiple concurrent streams
- Add predictive analytics
- Enable custom dashboard layouts
- Consider mobile dashboard view
- Add webhook integrations
- Plan for dashboard customization