# Issue #50: TestFlight

## User Story
As a **product manager**, I want to **deploy the iOS app to TestFlight** so that **beta testers can validate the app before public release**.

## Description
Set up and configure TestFlight deployment for the Waddle iOS app, including build automation, beta testing groups, crash reporting, and feedback collection. This establishes the beta testing workflow for pre-release validation.

## Acceptance Criteria
- [ ] App Store Connect configuration
- [ ] Automated build and upload pipeline
- [ ] Beta tester group management
- [ ] Crash reporting integration
- [ ] In-app feedback mechanism
- [ ] Build versioning strategy
- [ ] Release notes automation
- [ ] Analytics and metrics setup

## Technical Implementation

### 1. App Store Connect Configuration
```swift
// Build configuration for TestFlight
struct AppConfiguration {
    static let bundleIdentifier = "com.waddle.ios"
    static let appStoreTeamId = "XXXXXXXXXX"
    static let appStoreConnectKeyId = "XXXXXXXXXX"
    
    // Environment-specific settings
    enum Environment {
        case debug
        case testflight
        case appstore
        
        static var current: Environment {
            #if DEBUG
            return .debug
            #elseif TESTFLIGHT
            return .testflight
            #else
            return .appstore
            #endif
        }
        
        var apiEndpoint: String {
            switch self {
            case .debug:
                return "http://localhost:3000/api"
            case .testflight:
                return "https://beta-api.waddle.chat/api"
            case .appstore:
                return "https://api.waddle.chat/api"
            }
        }
        
        var analyticsEnabled: Bool {
            switch self {
            case .debug:
                return false
            case .testflight, .appstore:
                return true
            }
        }
        
        var crashReportingEnabled: Bool {
            switch self {
            case .debug:
                return false
            case .testflight, .appstore:
                return true
            }
        }
    }
}

// Info.plist configuration
/*
<key>CFBundleShortVersionString</key>
<string>$(MARKETING_VERSION)</string>
<key>CFBundleVersion</key>
<string>$(CURRENT_PROJECT_VERSION)</string>
<key>ITSAppUsesNonExemptEncryption</key>
<false/>
<key>UIRequiredDeviceCapabilities</key>
<array>
    <string>arm64</string>
    <string>microphone</string>
</array>
<key>NSMicrophoneUsageDescription</key>
<string>Waddle needs access to your microphone for voice chat</string>
<key>NSCameraUsageDescription</key>
<string>Waddle needs access to your camera for video calls</string>
<key>NSPhotoLibraryUsageDescription</key>
<string>Waddle needs access to your photos to share images</string>
*/

// TestFlight detection
extension Bundle {
    var isTestFlight: Bool {
        guard let receiptURL = appStoreReceiptURL else { return false }
        
        let receiptPath = receiptURL.path
        return receiptPath.contains("sandboxReceipt")
    }
    
    var isAppStore: Bool {
        guard let receiptURL = appStoreReceiptURL else { return false }
        
        let receiptPath = receiptURL.path
        return !receiptPath.contains("sandboxReceipt") && FileManager.default.fileExists(atPath: receiptPath)
    }
}
```

### 2. Build Automation with Fastlane
```ruby
# Fastfile
default_platform(:ios)

platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do
    # Ensure we're on a clean branch
    ensure_git_status_clean
    
    # Increment build number
    increment_build_number(
      build_number: latest_testflight_build_number + 1
    )
    
    # Update version if needed
    if ENV["BUMP_VERSION"]
      increment_version_number(
        bump_type: ENV["BUMP_VERSION"] # patch, minor, major
      )
    end
    
    # Sync certificates and profiles
    sync_code_signing(
      type: "appstore",
      app_identifier: "com.waddle.ios",
      readonly: is_ci
    )
    
    # Build the app
    build_app(
      scheme: "Waddle",
      configuration: "Release",
      export_method: "app-store",
      include_bitcode: true,
      include_symbols: true,
      export_options: {
        compileBitcode: true,
        uploadBitcode: true,
        uploadSymbols: true
      }
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      app_identifier: "com.waddle.ios",
      skip_waiting_for_build_processing: true,
      distribute_external: true,
      groups: ["Beta Testers", "Internal Team"],
      changelog: generate_changelog,
      beta_app_description: "Join the Waddle beta program!",
      beta_app_feedback_email: "beta@waddle.chat",
      notify_external_testers: true
    )
    
    # Post to Slack
    slack(
      message: "New TestFlight build uploaded! ðŸš€",
      channel: "#ios-releases",
      success: true,
      payload: {
        "Build Number": get_build_number,
        "Version": get_version_number
      }
    )
    
    # Commit version bump
    commit_version_bump
    push_to_git_remote
    
    # Create git tag
    add_git_tag(
      tag: "v#{get_version_number}-#{get_build_number}"
    )
    push_git_tags
  end
  
  desc "Generate changelog from git commits"
  private_lane :generate_changelog do
    changelog = changelog_from_git_commits(
      between: [last_git_tag, "HEAD"],
      pretty: "- %s",
      merge_commit_filtering: "exclude_merges"
    )
    
    # Add TestFlight specific notes
    notes = "What's New in This Beta:\n\n"
    notes += changelog
    notes += "\n\nPlease test the following areas:\n"
    notes += "- Voice chat quality\n"
    notes += "- Message syncing\n"
    notes += "- Push notifications\n"
    notes += "\nReport issues at beta@waddle.chat"
    
    notes
  end
  
  desc "Download dSYMs and upload to crash reporting"
  lane :refresh_dsyms do
    download_dsyms(
      app_identifier: "com.waddle.ios",
      version: "latest"
    )
    
    upload_symbols_to_crashlytics(
      dsym_path: "./Waddle.app.dSYM.zip"
    )
    
    upload_symbols_to_sentry(
      dsym_path: "./Waddle.app.dSYM.zip",
      api_key: ENV["SENTRY_API_KEY"],
      org_slug: "waddle",
      project_slug: "ios"
    )
    
    clean_build_artifacts
  end
end

# Appfile
app_identifier("com.waddle.ios")
apple_id(ENV["APPLE_ID"])
itc_team_id(ENV["ITC_TEAM_ID"])
team_id(ENV["TEAM_ID"])

# .env.default
FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=xxxx
MATCH_PASSWORD=xxxx
SLACK_URL=https://hooks.slack.com/services/xxx
SENTRY_API_KEY=xxxx
```

### 3. Beta Testing Framework
```swift
// Beta testing utilities
class BetaTestingManager {
    static let shared = BetaTestingManager()
    
    private let testFlightFeedback = TestFlightFeedback()
    private let analytics = AnalyticsManager.shared
    
    init() {
        if Bundle.main.isTestFlight {
            setupBetaEnvironment()
        }
    }
    
    private func setupBetaEnvironment() {
        // Enable verbose logging
        Logger.setLogLevel(.verbose)
        
        // Show build information
        showBuildInfo()
        
        // Setup shake gesture for feedback
        ShakeGestureManager.shared.onShake = { [weak self] in
            self?.showFeedbackDialog()
        }
        
        // Track beta session
        analytics.track("beta_session_start", properties: [
            "build_number": Bundle.main.buildNumber,
            "version": Bundle.main.versionNumber,
            "device_model": UIDevice.current.model,
            "ios_version": UIDevice.current.systemVersion
        ])
    }
    
    private func showBuildInfo() {
        let buildInfo = """
        Beta Build
        Version: \(Bundle.main.versionNumber)
        Build: \(Bundle.main.buildNumber)
        """
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            Toast.show(buildInfo, duration: 5.0)
        }
    }
    
    func showFeedbackDialog() {
        let feedbackVC = FeedbackViewController()
        feedbackVC.onSubmit = { [weak self] feedback in
            self?.submitFeedback(feedback)
        }
        
        UIApplication.shared.topViewController?.present(feedbackVC, animated: true)
    }
    
    private func submitFeedback(_ feedback: BetaFeedback) {
        Task {
            do {
                // Capture additional context
                let context = FeedbackContext(
                    deviceInfo: DeviceInfo.current,
                    appState: AppStateCapture.current,
                    logs: Logger.getRecentLogs(lines: 100)
                )
                
                // Submit to backend
                try await APIClient.shared.submitBetaFeedback(feedback, context: context)
                
                // Track in analytics
                analytics.track("beta_feedback_submitted", properties: [
                    "type": feedback.type.rawValue,
                    "has_screenshot": feedback.screenshot != nil
                ])
                
                Toast.show("Thank you for your feedback!", style: .success)
            } catch {
                Toast.show("Failed to submit feedback", style: .error)
            }
        }
    }
}

// Feedback UI
struct FeedbackViewController: UIViewController {
    var onSubmit: ((BetaFeedback) -> Void)?
    
    private let feedbackTextView = UITextView()
    private let typeSelector = UISegmentedControl(items: ["Bug", "Feature", "Other"])
    private let screenshotSwitch = UISwitch()
    private var screenshot: UIImage?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        
        // Capture screenshot if enabled
        if UserDefaults.standard.bool(forKey: "auto_capture_screenshot") {
            screenshot = UIApplication.shared.captureScreenshot()
        }
    }
    
    private func setupUI() {
        view.backgroundColor = .systemBackground
        
        // Navigation bar
        navigationItem.title = "Beta Feedback"
        navigationItem.leftBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .cancel,
            target: self,
            action: #selector(cancelTapped)
        )
        navigationItem.rightBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .done,
            target: self,
            action: #selector(submitTapped)
        )
        
        // Layout feedback form
        let stackView = UIStackView()
        stackView.axis = .vertical
        stackView.spacing = 16
        stackView.translatesAutoresizingMaskIntoConstraints = false
        
        // Type selector
        let typeLabel = UILabel()
        typeLabel.text = "Feedback Type"
        stackView.addArrangedSubview(typeLabel)
        stackView.addArrangedSubview(typeSelector)
        
        // Feedback text
        let textLabel = UILabel()
        textLabel.text = "Description"
        stackView.addArrangedSubview(textLabel)
        
        feedbackTextView.layer.borderColor = UIColor.separator.cgColor
        feedbackTextView.layer.borderWidth = 1
        feedbackTextView.layer.cornerRadius = 8
        feedbackTextView.font = .preferredFont(forTextStyle: .body)
        feedbackTextView.heightAnchor.constraint(equalToConstant: 200).isActive = true
        stackView.addArrangedSubview(feedbackTextView)
        
        // Screenshot option
        let screenshotStack = UIStackView()
        screenshotStack.axis = .horizontal
        let screenshotLabel = UILabel()
        screenshotLabel.text = "Include Screenshot"
        screenshotStack.addArrangedSubview(screenshotLabel)
        screenshotStack.addArrangedSubview(screenshotSwitch)
        stackView.addArrangedSubview(screenshotStack)
        
        view.addSubview(stackView)
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),
            stackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            stackView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20)
        ])
    }
    
    @objc private func submitTapped() {
        let feedback = BetaFeedback(
            type: FeedbackType(rawValue: typeSelector.selectedSegmentIndex) ?? .other,
            message: feedbackTextView.text,
            screenshot: screenshotSwitch.isOn ? screenshot : nil,
            timestamp: Date(),
            buildNumber: Bundle.main.buildNumber
        )
        
        onSubmit?(feedback)
        dismiss(animated: true)
    }
}
```

### 4. Crash Reporting Integration
```swift
// Crash reporting setup
import Sentry
import FirebaseCrashlytics

class CrashReportingManager {
    static let shared = CrashReportingManager()
    
    func initialize() {
        guard AppConfiguration.Environment.current.crashReportingEnabled else {
            print("Crash reporting disabled in debug")
            return
        }
        
        // Initialize Sentry
        SentrySDK.start { options in
            options.dsn = "https://xxxx@sentry.io/xxxx"
            options.environment = Bundle.main.isTestFlight ? "testflight" : "production"
            options.tracesSampleRate = Bundle.main.isTestFlight ? 1.0 : 0.1
            options.attachScreenshot = Bundle.main.isTestFlight
            options.attachViewHierarchy = Bundle.main.isTestFlight
            
            // Set user context
            if let userId = AuthManager.shared.currentUserId {
                options.setUser(User(userId: userId))
            }
            
            // Before send hook
            options.beforeSend = { event in
                // Filter out non-critical errors in production
                if !Bundle.main.isTestFlight {
                    if let error = event.error as NSError?,
                       error.domain == NSURLErrorDomain {
                        return nil // Don't report network errors
                    }
                }
                
                // Add additional context
                event.extra?["app_state"] = AppStateManager.shared.currentState
                event.extra?["memory_usage"] = ProcessInfo.processInfo.physicalMemory
                
                return event
            }
        }
        
        // Initialize Crashlytics
        Crashlytics.crashlytics().setCrashlyticsCollectionEnabled(true)
        
        // Set custom keys
        updateCrashReportingContext()
    }
    
    func updateCrashReportingContext() {
        // Update Sentry
        SentrySDK.configureScope { scope in
            scope.setTag(value: Bundle.main.versionNumber, key: "version")
            scope.setTag(value: Bundle.main.buildNumber, key: "build")
            scope.setTag(value: Bundle.main.isTestFlight ? "testflight" : "appstore", key: "distribution")
            
            if let userId = AuthManager.shared.currentUserId {
                scope.setUser(User(userId: userId))
            }
        }
        
        // Update Crashlytics
        Crashlytics.crashlytics().setCustomValue(Bundle.main.versionNumber, forKey: "version")
        Crashlytics.crashlytics().setCustomValue(Bundle.main.buildNumber, forKey: "build")
        
        if let userId = AuthManager.shared.currentUserId {
            Crashlytics.crashlytics().setUserID(userId)
        }
    }
    
    func logBreadcrumb(_ message: String, category: String? = nil, level: SentryLevel = .info) {
        let crumb = Breadcrumb()
        crumb.message = message
        crumb.category = category
        crumb.level = level
        crumb.timestamp = Date()
        
        SentrySDK.addBreadcrumb(crumb)
        
        // Also log to Crashlytics
        Crashlytics.crashlytics().log(message)
    }
    
    func reportError(_ error: Error, context: [String: Any]? = nil) {
        // Sentry
        SentrySDK.capture(error: error) { scope in
            if let context = context {
                scope.setContext(value: context, key: "error_context")
            }
        }
        
        // Crashlytics
        Crashlytics.crashlytics().record(error: error)
    }
}

// Non-fatal error tracking
extension Logger {
    static func error(_ message: String, error: Error? = nil, file: String = #file, function: String = #function, line: Int = #line) {
        let logMessage = "[\(file.split(separator: "/").last ?? ""):\(line)] \(function) - \(message)"
        
        // Log normally
        os_log(.error, "%{public}@", logMessage)
        
        // Report to crash services
        CrashReportingManager.shared.logBreadcrumb(logMessage, category: "error", level: .error)
        
        if let error = error {
            CrashReportingManager.shared.reportError(error, context: [
                "message": message,
                "file": file,
                "function": function,
                "line": line
            ])
        }
    }
}
```

### 5. Analytics and Metrics
```swift
// TestFlight analytics
class TestFlightAnalytics {
    private let mixpanel: Mixpanel
    private let amplitude: Amplitude
    
    init() {
        // Initialize analytics SDKs
        Mixpanel.initialize(token: Config.mixpanelToken, trackAutomaticEvents: true)
        mixpanel = Mixpanel.mainInstance()
        
        amplitude = Amplitude.instance()
        amplitude.initializeApiKey(Config.amplitudeApiKey)
        
        // Set super properties
        let superProperties: [String: Any] = [
            "platform": "iOS",
            "distribution": "TestFlight",
            "version": Bundle.main.versionNumber,
            "build": Bundle.main.buildNumber,
            "device_model": UIDevice.current.model,
            "ios_version": UIDevice.current.systemVersion
        ]
        
        mixpanel.registerSuperProperties(superProperties)
        amplitude.setUserProperties(superProperties)
    }
    
    func trackTestFlightEvent(_ event: String, properties: [String: Any]? = nil) {
        var props = properties ?? [:]
        props["is_testflight"] = true
        props["timestamp"] = ISO8601DateFormatter().string(from: Date())
        
        // Track in both services
        mixpanel.track(event: event, properties: props)
        amplitude.logEvent(event, withEventProperties: props)
        
        // Log for debugging
        Logger.debug("TestFlight Event: \(event) - \(props)")
    }
    
    func trackFeatureUsage(feature: String, context: [String: Any]? = nil) {
        trackTestFlightEvent("feature_used", properties: [
            "feature_name": feature,
            "context": context ?? [:]
        ])
    }
    
    func trackPerformanceMetric(metric: String, value: Double, unit: String) {
        trackTestFlightEvent("performance_metric", properties: [
            "metric_name": metric,
            "value": value,
            "unit": unit
        ])
    }
}

// Performance monitoring
class PerformanceMonitor {
    static let shared = PerformanceMonitor()
    
    private var startTimes: [String: CFAbsoluteTime] = [:]
    
    func startMeasuring(_ operation: String) {
        startTimes[operation] = CFAbsoluteTimeGetCurrent()
    }
    
    func endMeasuring(_ operation: String) {
        guard let startTime = startTimes[operation] else { return }
        
        let duration = CFAbsoluteTimeGetCurrent() - startTime
        startTimes.removeValue(forKey: operation)
        
        // Track metric
        TestFlightAnalytics().trackPerformanceMetric(
            metric: operation,
            value: duration * 1000, // Convert to milliseconds
            unit: "ms"
        )
        
        // Log if slow
        if duration > 1.0 {
            Logger.warning("\(operation) took \(duration)s")
        }
    }
}
```

### 6. Release Management
```swift
// Version management
struct VersionManager {
    static func checkForUpdates() {
        guard Bundle.main.isTestFlight else { return }
        
        Task {
            do {
                let response = try await APIClient.shared.getLatestVersion()
                
                if response.buildNumber > Bundle.main.buildNumber {
                    showUpdatePrompt(version: response)
                }
            } catch {
                Logger.error("Failed to check for updates", error: error)
            }
        }
    }
    
    private static func showUpdatePrompt(version: VersionInfo) {
        let alert = UIAlertController(
            title: "New Beta Available",
            message: "Version \(version.versionNumber) (Build \(version.buildNumber)) is available. Would you like to update?",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Update", style: .default) { _ in
            // Open TestFlight
            if let url = URL(string: "itms-beta://") {
                UIApplication.shared.open(url)
            }
        })
        
        alert.addAction(UIAlertAction(title: "Later", style: .cancel))
        
        UIApplication.shared.topViewController?.present(alert, animated: true)
    }
}

// Release notes
struct ReleaseNotesManager {
    static func showReleaseNotesIfNeeded() {
        let lastShownVersion = UserDefaults.standard.string(forKey: "last_shown_release_notes") ?? ""
        let currentVersion = Bundle.main.versionNumber
        
        if lastShownVersion != currentVersion {
            showReleaseNotes()
            UserDefaults.standard.set(currentVersion, forKey: "last_shown_release_notes")
        }
    }
    
    private static func showReleaseNotes() {
        Task {
            do {
                let notes = try await APIClient.shared.getReleaseNotes(
                    version: Bundle.main.versionNumber,
                    build: Bundle.main.buildNumber
                )
                
                let notesVC = ReleaseNotesViewController(notes: notes)
                UIApplication.shared.topViewController?.present(notesVC, animated: true)
            } catch {
                // Fallback to bundled release notes
                if let path = Bundle.main.path(forResource: "ReleaseNotes", ofType: "md"),
                   let content = try? String(contentsOfFile: path) {
                    let notesVC = ReleaseNotesViewController(markdown: content)
                    UIApplication.shared.topViewController?.present(notesVC, animated: true)
                }
            }
        }
    }
}

// CI/CD integration
struct CIIntegration {
    static func uploadBuildMetadata() {
        let metadata = BuildMetadata(
            version: Bundle.main.versionNumber,
            build: Bundle.main.buildNumber,
            commit: gitCommitHash(),
            branch: gitBranch(),
            buildDate: Date(),
            configuration: AppConfiguration.Environment.current
        )
        
        Task {
            try? await APIClient.shared.uploadBuildMetadata(metadata)
        }
    }
    
    private static func gitCommitHash() -> String {
        // This would be injected during build time
        return ProcessInfo.processInfo.environment["GIT_COMMIT_HASH"] ?? "unknown"
    }
    
    private static func gitBranch() -> String {
        // This would be injected during build time
        return ProcessInfo.processInfo.environment["GIT_BRANCH"] ?? "unknown"
    }
}
```

## Dependencies
- Fastlane for automation
- App Store Connect API
- Sentry for crash reporting
- Firebase Crashlytics
- Analytics SDKs (Mixpanel, Amplitude)

## Estimated Effort
**5 days**
- 1 day: App Store Connect setup
- 1 day: Fastlane automation
- 1 day: Beta testing framework
- 1 day: Crash reporting integration
- 1 day: Analytics and release management

## Notes
- Set up proper code signing
- Configure push notification certificates
- Implement proper versioning strategy
- Plan beta testing groups
- Document feedback process for testers