# Issue #24: User Profile & Settings

## User Story
As a **user**, I want to **customize my profile and manage my settings** so that **I can personalize my experience and control my privacy**.

## Description
Implement comprehensive user profiles with customization options, privacy settings, notification preferences, and account management. This includes profile banners, about sections, status messages, and cross-waddle identity management.

## Acceptance Criteria
- [ ] Customizable user profiles
- [ ] Avatar and banner upload
- [ ] About me and status sections
- [ ] Privacy settings management
- [ ] Notification preferences
- [ ] Account security settings
- [ ] Profile themes and appearance
- [ ] Cross-waddle profile consistency

## Technical Implementation

### 1. User Profile System
```typescript
export interface UserProfile {
  userId: string;
  username: string;
  displayName?: string;
  avatarUrl?: string;
  bannerUrl?: string;
  bio?: string;
  status?: {
    text: string;
    emoji?: string;
    expiresAt?: number;
    type?: 'online' | 'idle' | 'dnd' | 'invisible';
  };
  pronouns?: string;
  location?: string;
  website?: string;
  social?: {
    twitter?: string;
    github?: string;
    linkedin?: string;
    discord?: string;
  };
  badges: Badge[];
  customization: {
    theme?: 'light' | 'dark' | 'auto';
    accentColor?: string;
    fontSize?: 'small' | 'medium' | 'large';
    compactMode?: boolean;
    animationsEnabled?: boolean;
  };
  privacy: {
    profileVisibility: 'public' | 'friends' | 'private';
    showActivity: boolean;
    showWaddles: boolean;
    allowDMs: 'everyone' | 'friends' | 'none';
    allowFriendRequests: boolean;
  };
  createdAt: number;
  updatedAt: number;
}

export class UserProfileService {
  constructor(
    private db: D1Database,
    private storage: R2Bucket,
    private imageProcessor: ImageProcessor,
    private cache: KVNamespace
  ) {}
  
  async updateProfile(
    userId: string,
    updates: UpdateProfileRequest
  ): Promise<UserProfile> {
    const currentProfile = await this.getProfile(userId);
    
    // Validate updates
    const validation = await this.validateProfileUpdates(updates);
    if (!validation.valid) {
      throw new ValidationError(validation.errors);
    }
    
    // Process avatar if provided
    if (updates.avatar) {
      const avatarUrl = await this.processAvatar(userId, updates.avatar);
      updates.avatarUrl = avatarUrl;
    }
    
    // Process banner if provided
    if (updates.banner) {
      const bannerUrl = await this.processBanner(userId, updates.banner);
      updates.bannerUrl = bannerUrl;
    }
    
    // Update profile
    const updatedProfile = {
      ...currentProfile,
      ...updates,
      updatedAt: Date.now()
    };
    
    // Save to database
    await this.saveProfile(updatedProfile);
    
    // Clear caches
    await this.clearProfileCache(userId);
    
    // Emit update event
    await this.events.emit('profile.updated', {
      userId,
      changes: this.getChanges(currentProfile, updatedProfile)
    });
    
    return updatedProfile;
  }
  
  private async processAvatar(
    userId: string,
    imageData: string | Buffer
  ): Promise<string> {
    // Process image
    const processed = await this.imageProcessor.process(imageData, {
      width: 256,
      height: 256,
      format: 'webp',
      quality: 90,
      fit: 'cover'
    });
    
    // Generate variants
    const variants = await Promise.all([
      this.imageProcessor.process(imageData, {
        width: 128,
        height: 128,
        format: 'webp',
        quality: 85,
        fit: 'cover'
      }),
      this.imageProcessor.process(imageData, {
        width: 64,
        height: 64,
        format: 'webp',
        quality: 80,
        fit: 'cover'
      })
    ]);
    
    // Upload to R2
    const key = `avatars/${userId}/${Date.now()}`;
    await Promise.all([
      this.storage.put(`${key}/256.webp`, processed, {
        httpMetadata: { contentType: 'image/webp' }
      }),
      this.storage.put(`${key}/128.webp`, variants[0], {
        httpMetadata: { contentType: 'image/webp' }
      }),
      this.storage.put(`${key}/64.webp`, variants[1], {
        httpMetadata: { contentType: 'image/webp' }
      })
    ]);
    
    // Delete old avatar
    if (currentProfile.avatarUrl) {
      await this.deleteOldAsset(currentProfile.avatarUrl);
    }
    
    return `${process.env.CDN_URL}/${key}/256.webp`;
  }
  
  private async processBanner(
    userId: string,
    imageData: string | Buffer
  ): Promise<string> {
    // Process banner
    const processed = await this.imageProcessor.process(imageData, {
      width: 1200,
      height: 400,
      format: 'webp',
      quality: 85,
      fit: 'cover'
    });
    
    // Upload to R2
    const key = `banners/${userId}/${Date.now()}.webp`;
    await this.storage.put(key, processed, {
      httpMetadata: { contentType: 'image/webp' }
    });
    
    // Delete old banner
    if (currentProfile.bannerUrl) {
      await this.deleteOldAsset(currentProfile.bannerUrl);
    }
    
    return `${process.env.CDN_URL}/${key}`;
  }
  
  private validateProfileUpdates(updates: UpdateProfileRequest): ValidationResult {
    const errors: string[] = [];
    
    if (updates.username) {
      if (!/^[a-zA-Z0-9_]{3,32}$/.test(updates.username)) {
        errors.push('Username must be 3-32 characters, alphanumeric and underscores only');
      }
    }
    
    if (updates.displayName && updates.displayName.length > 32) {
      errors.push('Display name must be 32 characters or less');
    }
    
    if (updates.bio && updates.bio.length > 500) {
      errors.push('Bio must be 500 characters or less');
    }
    
    if (updates.status?.text && updates.status.text.length > 128) {
      errors.push('Status must be 128 characters or less');
    }
    
    if (updates.website && !this.isValidUrl(updates.website)) {
      errors.push('Invalid website URL');
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
}
```

### 2. Settings Management
```typescript
export interface UserSettings {
  userId: string;
  notifications: NotificationSettings;
  privacy: PrivacySettings;
  security: SecuritySettings;
  appearance: AppearanceSettings;
  accessibility: AccessibilitySettings;
  voice: VoiceSettings;
  advanced: AdvancedSettings;
}

export interface NotificationSettings {
  // Global
  enableDesktopNotifications: boolean;
  enablePushNotifications: boolean;
  enableEmailNotifications: boolean;
  
  // Message notifications
  directMessages: 'all' | 'friends' | 'none';
  mentions: boolean;
  replies: boolean;
  
  // Voice notifications
  voiceJoinLeave: boolean;
  voiceStateChanges: boolean;
  
  // Waddle notifications
  waddleInvites: boolean;
  waddleUpdates: boolean;
  eventReminders: boolean;
  
  // Quiet hours
  quietHours: {
    enabled: boolean;
    start: string; // "22:00"
    end: string;   // "08:00"
    timezone: string;
  };
  
  // Per-waddle overrides
  waddleOverrides: Map<string, WaddleNotificationSettings>;
}

export class SettingsService {
  async updateSettings(
    userId: string,
    category: keyof UserSettings,
    updates: any
  ): Promise<UserSettings> {
    const currentSettings = await this.getSettings(userId);
    
    // Validate settings
    const validation = this.validateSettings(category, updates);
    if (!validation.valid) {
      throw new ValidationError(validation.errors);
    }
    
    // Apply updates
    const newSettings = {
      ...currentSettings,
      [category]: {
        ...currentSettings[category],
        ...updates
      },
      updatedAt: Date.now()
    };
    
    // Handle special cases
    if (category === 'security') {
      await this.handleSecurityUpdates(userId, updates);
    }
    
    if (category === 'notifications') {
      await this.updateNotificationSubscriptions(userId, newSettings.notifications);
    }
    
    // Save settings
    await this.saveSettings(userId, newSettings);
    
    // Apply immediate effects
    await this.applySettingsEffects(userId, category, updates);
    
    return newSettings;
  }
  
  private async handleSecurityUpdates(
    userId: string,
    updates: Partial<SecuritySettings>
  ): Promise<void> {
    if (updates.twoFactorEnabled !== undefined) {
      if (updates.twoFactorEnabled) {
        // Generate 2FA secret
        const secret = this.generate2FASecret();
        await this.save2FASecret(userId, secret);
        
        // Return QR code in response
        updates.twoFactorQR = await this.generate2FAQR(userId, secret);
      } else {
        // Verify current password before disabling
        if (!updates.currentPassword) {
          throw new ValidationError(['Current password required to disable 2FA']);
        }
        
        await this.disable2FA(userId);
      }
    }
    
    if (updates.password) {
      // Verify current password
      if (!await this.verifyPassword(userId, updates.currentPassword)) {
        throw new ValidationError(['Current password is incorrect']);
      }
      
      // Update password
      await this.updatePassword(userId, updates.password);
      
      // Revoke other sessions if requested
      if (updates.revokeOtherSessions) {
        await this.revokeAllSessions(userId, updates.currentSessionId);
      }
    }
  }
}
```

### 3. Profile UI Components
```tsx
export function UserProfilePage({ userId }: { userId: string }) {
  const { profile, loading } = useUserProfile(userId);
  const { currentUser } = useAuth();
  const isOwnProfile = currentUser?.id === userId;
  
  if (loading) return <ProfileSkeleton />;
  if (!profile) return <ProfileNotFound />;
  
  return (
    <div className="profile-page">
      <ProfileBanner
        bannerUrl={profile.bannerUrl}
        editable={isOwnProfile}
        onUpdate={(banner) => updateProfileBanner(banner)}
      />
      
      <div className="profile-container">
        <div className="profile-header">
          <ProfileAvatar
            user={profile}
            size="large"
            editable={isOwnProfile}
            onUpdate={(avatar) => updateProfileAvatar(avatar)}
          />
          
          <div className="profile-info">
            <h1>
              {profile.displayName || profile.username}
              {profile.badges.map(badge => (
                <Badge key={badge.id} badge={badge} />
              ))}
            </h1>
            <span className="username">@{profile.username}</span>
            
            {profile.pronouns && (
              <span className="pronouns">{profile.pronouns}</span>
            )}
            
            {profile.status && (
              <ProfileStatus status={profile.status} />
            )}
          </div>
          
          <div className="profile-actions">
            {isOwnProfile ? (
              <Button
                onClick={() => navigate('/settings/profile')}
                icon={<EditIcon />}
              >
                Edit Profile
              </Button>
            ) : (
              <>
                <Button
                  variant="primary"
                  onClick={() => sendFriendRequest(userId)}
                  icon={<PersonAddIcon />}
                >
                  Add Friend
                </Button>
                <Button
                  variant="secondary"
                  onClick={() => openDirectMessage(userId)}
                  icon={<MessageIcon />}
                >
                  Message
                </Button>
              </>
            )}
          </div>
        </div>
        
        <div className="profile-content">
          <div className="profile-main">
            <ProfileSection title="About Me">
              {profile.bio ? (
                <p className="bio">{profile.bio}</p>
              ) : (
                <p className="empty-state">No bio yet</p>
              )}
              
              <div className="profile-details">
                {profile.location && (
                  <div className="detail">
                    <LocationIcon />
                    <span>{profile.location}</span>
                  </div>
                )}
                
                {profile.website && (
                  <div className="detail">
                    <LinkIcon />
                    <a href={profile.website} target="_blank" rel="noopener">
                      {new URL(profile.website).hostname}
                    </a>
                  </div>
                )}
                
                <div className="detail">
                  <CalendarIcon />
                  <span>Joined {formatDate(profile.createdAt)}</span>
                </div>
              </div>
              
              {Object.keys(profile.social || {}).length > 0 && (
                <div className="social-links">
                  {profile.social?.twitter && (
                    <SocialLink platform="twitter" handle={profile.social.twitter} />
                  )}
                  {profile.social?.github && (
                    <SocialLink platform="github" handle={profile.social.github} />
                  )}
                  {profile.social?.linkedin && (
                    <SocialLink platform="linkedin" handle={profile.social.linkedin} />
                  )}
                </div>
              )}
            </ProfileSection>
            
            {profile.privacy.showWaddles && (
              <ProfileSection title="Waddles">
                <MutualWaddles userId={userId} />
              </ProfileSection>
            )}
            
            {profile.privacy.showActivity && (
              <ProfileSection title="Recent Activity">
                <UserActivity userId={userId} />
              </ProfileSection>
            )}
          </div>
          
          <div className="profile-sidebar">
            <MutualFriends userId={userId} />
            <ProfileStats userId={userId} />
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 4. Settings UI
```tsx
export function SettingsPage() {
  const [activeCategory, setActiveCategory] = useState('profile');
  const { settings, updateSettings } = useSettings();
  
  const categories = [
    { id: 'profile', label: 'Profile', icon: <PersonIcon /> },
    { id: 'account', label: 'Account', icon: <AccountIcon /> },
    { id: 'privacy', label: 'Privacy & Safety', icon: <LockIcon /> },
    { id: 'notifications', label: 'Notifications', icon: <NotificationIcon /> },
    { id: 'appearance', label: 'Appearance', icon: <PaletteIcon /> },
    { id: 'voice', label: 'Voice & Video', icon: <MicIcon /> },
    { id: 'accessibility', label: 'Accessibility', icon: <AccessibilityIcon /> },
    { id: 'advanced', label: 'Advanced', icon: <SettingsIcon /> }
  ];
  
  return (
    <div className="settings-page">
      <div className="settings-sidebar">
        <h2>Settings</h2>
        <nav className="settings-nav">
          {categories.map(category => (
            <button
              key={category.id}
              className={`settings-nav-item ${activeCategory === category.id ? 'active' : ''}`}
              onClick={() => setActiveCategory(category.id)}
            >
              {category.icon}
              <span>{category.label}</span>
            </button>
          ))}
        </nav>
      </div>
      
      <div className="settings-content">
        <SettingsPanel
          category={activeCategory}
          settings={settings}
          onUpdate={updateSettings}
        />
      </div>
    </div>
  );
}

function NotificationSettings({ 
  settings, 
  onUpdate 
}: SettingsPanelProps) {
  return (
    <div className="settings-panel">
      <h2>Notification Settings</h2>
      
      <SettingsSection title="Desktop Notifications">
        <SettingRow>
          <div>
            <label>Enable Desktop Notifications</label>
            <span className="setting-description">
              Show notifications on your desktop when Waddle is in the background
            </span>
          </div>
          <Switch
            checked={settings.enableDesktopNotifications}
            onChange={(checked) => onUpdate({ enableDesktopNotifications: checked })}
          />
        </SettingRow>
        
        {settings.enableDesktopNotifications && (
          <Button
            variant="secondary"
            onClick={requestNotificationPermission}
          >
            Test Notification
          </Button>
        )}
      </SettingsSection>
      
      <SettingsSection title="Message Notifications">
        <SettingRow>
          <div>
            <label>Direct Messages</label>
            <span className="setting-description">
              Control who can send you direct message notifications
            </span>
          </div>
          <Select
            value={settings.directMessages}
            onChange={(value) => onUpdate({ directMessages: value })}
            options={[
              { value: 'all', label: 'Everyone' },
              { value: 'friends', label: 'Friends Only' },
              { value: 'none', label: 'Disabled' }
            ]}
          />
        </SettingRow>
        
        <SettingRow>
          <div>
            <label>Mentions</label>
            <span className="setting-description">
              Notify when someone mentions you
            </span>
          </div>
          <Switch
            checked={settings.mentions}
            onChange={(checked) => onUpdate({ mentions: checked })}
          />
        </SettingRow>
      </SettingsSection>
      
      <SettingsSection title="Quiet Hours">
        <SettingRow>
          <div>
            <label>Enable Quiet Hours</label>
            <span className="setting-description">
              Automatically mute notifications during specified hours
            </span>
          </div>
          <Switch
            checked={settings.quietHours.enabled}
            onChange={(checked) => onUpdate({ 
              quietHours: { ...settings.quietHours, enabled: checked } 
            })}
          />
        </SettingRow>
        
        {settings.quietHours.enabled && (
          <>
            <SettingRow>
              <label>Start Time</label>
              <TimeInput
                value={settings.quietHours.start}
                onChange={(time) => onUpdate({
                  quietHours: { ...settings.quietHours, start: time }
                })}
              />
            </SettingRow>
            
            <SettingRow>
              <label>End Time</label>
              <TimeInput
                value={settings.quietHours.end}
                onChange={(time) => onUpdate({
                  quietHours: { ...settings.quietHours, end: time }
                })}
              />
            </SettingRow>
          </>
        )}
      </SettingsSection>
    </div>
  );
}
```

### 5. Privacy Controls
```typescript
export class PrivacyService {
  async updatePrivacySettings(
    userId: string,
    settings: PrivacySettings
  ): Promise<void> {
    // Validate settings
    this.validatePrivacySettings(settings);
    
    // Update settings
    await this.db.prepare(`
      UPDATE user_settings
      SET privacy = ?, updated_at = ?
      WHERE user_id = ?
    `).bind(JSON.stringify(settings), Date.now(), userId).run();
    
    // Apply privacy changes
    if (settings.profileVisibility === 'private') {
      await this.makeProfilePrivate(userId);
    }
    
    if (!settings.allowDMs || settings.allowDMs === 'none') {
      await this.disableDirectMessages(userId);
    }
    
    // Update friend request settings
    await this.updateFriendRequestSettings(userId, settings.allowFriendRequests);
  }
  
  async blockUser(
    userId: string,
    targetId: string
  ): Promise<void> {
    // Add to block list
    await this.db.prepare(`
      INSERT INTO user_blocks (user_id, blocked_id, blocked_at)
      VALUES (?, ?, ?)
    `).bind(userId, targetId, Date.now()).run();
    
    // Remove friendship if exists
    await this.removeFriendship(userId, targetId);
    
    // Remove from all shared waddles DMs
    await this.removeSharedDMs(userId, targetId);
    
    // Clear mutual data from cache
    await this.clearMutualDataCache(userId, targetId);
  }
  
  async getBlockedUsers(userId: string): Promise<BlockedUser[]> {
    const blocks = await this.db.prepare(`
      SELECT 
        b.blocked_id,
        b.blocked_at,
        u.username,
        u.avatar_url
      FROM user_blocks b
      JOIN users u ON b.blocked_id = u.id
      WHERE b.user_id = ?
      ORDER BY b.blocked_at DESC
    `).bind(userId).all();
    
    return blocks.results.map(block => ({
      userId: block.blocked_id,
      username: block.username,
      avatarUrl: block.avatar_url,
      blockedAt: block.blocked_at
    }));
  }
  
  async checkPrivacy(
    viewerId: string,
    targetId: string,
    action: PrivacyAction
  ): Promise<boolean> {
    // Check if blocked
    const isBlocked = await this.isBlocked(viewerId, targetId);
    if (isBlocked) return false;
    
    // Get target's privacy settings
    const privacy = await this.getPrivacySettings(targetId);
    
    switch (action) {
      case 'view_profile':
        if (privacy.profileVisibility === 'public') return true;
        if (privacy.profileVisibility === 'friends') {
          return this.areFriends(viewerId, targetId);
        }
        return viewerId === targetId;
        
      case 'send_dm':
        if (privacy.allowDMs === 'everyone') return true;
        if (privacy.allowDMs === 'friends') {
          return this.areFriends(viewerId, targetId);
        }
        return false;
        
      case 'send_friend_request':
        return privacy.allowFriendRequests;
        
      case 'view_activity':
        return privacy.showActivity && (
          privacy.profileVisibility === 'public' ||
          (privacy.profileVisibility === 'friends' && await this.areFriends(viewerId, targetId))
        );
        
      default:
        return false;
    }
  }
}
```

### 6. Status System
```typescript
export class StatusService {
  async setStatus(
    userId: string,
    status: StatusUpdate
  ): Promise<void> {
    // Validate status
    if (status.text && status.text.length > 128) {
      throw new ValidationError('Status text too long');
    }
    
    // Set expiration if duration provided
    let expiresAt = null;
    if (status.duration) {
      expiresAt = Date.now() + status.duration;
    }
    
    // Update status
    await this.db.prepare(`
      UPDATE user_profiles
      SET 
        status_text = ?,
        status_emoji = ?,
        status_type = ?,
        status_expires_at = ?,
        updated_at = ?
      WHERE user_id = ?
    `).bind(
      status.text,
      status.emoji,
      status.type || 'online',
      expiresAt,
      Date.now(),
      userId
    ).run();
    
    // Broadcast status update
    await this.broadcastStatusUpdate(userId, status);
    
    // Schedule expiration if needed
    if (expiresAt) {
      await this.scheduleStatusExpiration(userId, expiresAt);
    }
  }
  
  async getPresence(userIds: string[]): Promise<Map<string, Presence>> {
    const presence = new Map<string, Presence>();
    
    // Get from cache first
    const cached = await this.cache.getMultiple(
      userIds.map(id => `presence:${id}`)
    );
    
    // Fetch missing from database
    const missing = userIds.filter(id => !cached.has(`presence:${id}`));
    if (missing.length > 0) {
      const dbPresence = await this.db.prepare(`
        SELECT 
          user_id,
          status_type,
          status_text,
          status_emoji,
          last_seen_at,
          current_waddle_id,
          current_channel_id
        FROM user_presence
        WHERE user_id IN (${missing.map(() => '?').join(',')})
      `).bind(...missing).all();
      
      // Update cache and map
      for (const p of dbPresence.results) {
        const presenceData = {
          status: p.status_type,
          statusText: p.status_text,
          statusEmoji: p.status_emoji,
          lastSeenAt: p.last_seen_at,
          currentWaddle: p.current_waddle_id,
          currentChannel: p.current_channel_id
        };
        
        presence.set(p.user_id, presenceData);
        await this.cache.put(
          `presence:${p.user_id}`,
          JSON.stringify(presenceData),
          { expirationTtl: 300 }
        );
      }
    }
    
    return presence;
  }
}
```

### 7. Profile Customization
```tsx
export function ProfileEditor() {
  const { profile, updateProfile } = useProfile();
  const [edited, setEdited] = useState(profile);
  const [saving, setSaving] = useState(false);
  
  const handleSave = async () => {
    setSaving(true);
    try {
      await updateProfile(edited);
      toast.success('Profile updated successfully');
    } catch (error) {
      toast.error('Failed to update profile');
    } finally {
      setSaving(false);
    }
  };
  
  return (
    <div className="profile-editor">
      <h2>Edit Profile</h2>
      
      <div className="editor-section">
        <h3>Profile Picture</h3>
        <div className="avatar-editor">
          <Avatar user={edited} size="xlarge" />
          <div className="avatar-actions">
            <Button
              variant="secondary"
              onClick={() => openImagePicker('avatar')}
            >
              Change Avatar
            </Button>
            <Button
              variant="text"
              onClick={() => setEdited({ ...edited, avatarUrl: null })}
              disabled={!edited.avatarUrl}
            >
              Remove
            </Button>
          </div>
        </div>
      </div>
      
      <div className="editor-section">
        <h3>Profile Banner</h3>
        <div className="banner-editor">
          <BannerPreview url={edited.bannerUrl} />
          <Button
            variant="secondary"
            onClick={() => openImagePicker('banner')}
          >
            Change Banner
          </Button>
        </div>
      </div>
      
      <div className="editor-section">
        <FormField label="Display Name">
          <Input
            value={edited.displayName || ''}
            onChange={(e) => setEdited({ ...edited, displayName: e.target.value })}
            placeholder={edited.username}
            maxLength={32}
          />
        </FormField>
        
        <FormField label="About Me">
          <TextArea
            value={edited.bio || ''}
            onChange={(e) => setEdited({ ...edited, bio: e.target.value })}
            placeholder="Tell us about yourself..."
            maxLength={500}
            rows={4}
          />
          <CharacterCount current={edited.bio?.length || 0} max={500} />
        </FormField>
        
        <FormField label="Pronouns">
          <Input
            value={edited.pronouns || ''}
            onChange={(e) => setEdited({ ...edited, pronouns: e.target.value })}
            placeholder="they/them"
            maxLength={20}
          />
        </FormField>
        
        <FormField label="Location">
          <Input
            value={edited.location || ''}
            onChange={(e) => setEdited({ ...edited, location: e.target.value })}
            placeholder="San Francisco, CA"
            maxLength={50}
          />
        </FormField>
        
        <FormField label="Website">
          <Input
            type="url"
            value={edited.website || ''}
            onChange={(e) => setEdited({ ...edited, website: e.target.value })}
            placeholder="https://example.com"
          />
        </FormField>
      </div>
      
      <div className="editor-section">
        <h3>Social Links</h3>
        <FormField label="Twitter">
          <Input
            value={edited.social?.twitter || ''}
            onChange={(e) => setEdited({
              ...edited,
              social: { ...edited.social, twitter: e.target.value }
            })}
            placeholder="username"
            prefix="@"
          />
        </FormField>
        
        <FormField label="GitHub">
          <Input
            value={edited.social?.github || ''}
            onChange={(e) => setEdited({
              ...edited,
              social: { ...edited.social, github: e.target.value }
            })}
            placeholder="username"
          />
        </FormField>
      </div>
      
      <div className="editor-actions">
        <Button
          variant="secondary"
          onClick={() => setEdited(profile)}
          disabled={saving}
        >
          Reset
        </Button>
        <Button
          variant="primary"
          onClick={handleSave}
          disabled={saving || JSON.stringify(edited) === JSON.stringify(profile)}
        >
          {saving ? 'Saving...' : 'Save Changes'}
        </Button>
      </div>
    </div>
  );
}
```

## Dependencies
- Authentication System (Issue #03) for user identity
- Image Processing Service for avatars/banners
- R2 Storage for media assets
- Notification Service for preferences

## Estimated Effort
**5 days**
- 1 day: Core profile system and data model
- 1 day: Settings management service
- 1 day: Profile UI components
- 1 day: Settings UI and preferences
- 1 day: Privacy controls and status system

## Notes
- Implement profile import from other platforms
- Add profile verification system
- Consider profile analytics/insights
- Add profile templates for quick setup
- Monitor storage usage for media assets