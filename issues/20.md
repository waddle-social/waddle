# Issue #20: Waddle Creation with Voice Pre-configured

## User Story
As a **user**, I want to **create my own waddle with voice channels ready** so that **my community can start communicating immediately without complex setup**.

## Description
Implement a streamlined waddle creation flow that automatically provisions all necessary infrastructure including D1 database, Durable Objects, default channels, and RealTimeKit configuration. This should be a simple, guided process with sensible defaults.

## Acceptance Criteria
- [ ] Simple waddle creation wizard
- [ ] Automatic D1 database provisioning
- [ ] Default channel structure created
- [ ] Voice channels pre-configured with RTK
- [ ] Customizable waddle templates
- [ ] Icon and banner upload during creation
- [ ] Invitation link generated
- [ ] Creation progress tracking

## Technical Implementation

### 1. Waddle Creation Service
```typescript
export interface WaddleTemplate {
  id: string;
  name: string;
  description: string;
  icon: string;
  categories: CategoryTemplate[];
  defaultChannels: ChannelTemplate[];
  defaultRoles: RoleTemplate[];
  settings: WaddleSettings;
}

export class WaddleCreationService {
  private templates: Map<string, WaddleTemplate> = new Map([
    ['gaming', {
      id: 'gaming',
      name: 'Gaming Community',
      description: 'Perfect for gaming groups and clans',
      icon: 'üéÆ',
      categories: [
        { name: 'Text Channels', position: 0 },
        { name: 'Voice Channels', position: 1 },
        { name: 'Admin', position: 2 }
      ],
      defaultChannels: [
        { name: 'welcome', type: 'text', categoryIndex: 0, position: 0 },
        { name: 'general', type: 'text', categoryIndex: 0, position: 1 },
        { name: 'memes', type: 'text', categoryIndex: 0, position: 2 },
        { name: 'General Voice', type: 'voice', categoryIndex: 1, position: 0 },
        { name: 'Gaming 1', type: 'voice', categoryIndex: 1, position: 1 },
        { name: 'Gaming 2', type: 'voice', categoryIndex: 1, position: 2 },
        { name: 'announcements', type: 'announcement', categoryIndex: 2, position: 0 }
      ],
      defaultRoles: [
        { name: 'Admin', permissions: ALL_PERMISSIONS, color: '#E74C3C' },
        { name: 'Moderator', permissions: MODERATOR_PERMISSIONS, color: '#E67E22' },
        { name: 'Member', permissions: MEMBER_PERMISSIONS, color: '#95A5A6' }
      ],
      settings: {
        defaultNotifications: 'mentions',
        verificationLevel: 'medium'
      }
    }],
    ['study', {
      id: 'study',
      name: 'Study Group',
      description: 'Ideal for study groups and educational communities',
      icon: 'üìö',
      categories: [
        { name: 'General', position: 0 },
        { name: 'Study Rooms', position: 1 },
        { name: 'Resources', position: 2 }
      ],
      defaultChannels: [
        { name: 'welcome', type: 'text', categoryIndex: 0, position: 0 },
        { name: 'general', type: 'text', categoryIndex: 0, position: 1 },
        { name: 'Study Room 1', type: 'voice', categoryIndex: 1, position: 0, voiceConfig: { userLimit: 5 } },
        { name: 'Study Room 2', type: 'voice', categoryIndex: 1, position: 1, voiceConfig: { userLimit: 5 } },
        { name: 'Focus Zone', type: 'voice', categoryIndex: 1, position: 2, voiceConfig: { userLimit: 10 } },
        { name: 'resources', type: 'text', categoryIndex: 2, position: 0 },
        { name: 'announcements', type: 'announcement', categoryIndex: 2, position: 1 }
      ],
      defaultRoles: [
        { name: 'Teacher', permissions: MODERATOR_PERMISSIONS, color: '#3498DB' },
        { name: 'Student', permissions: MEMBER_PERMISSIONS, color: '#95A5A6' }
      ],
      settings: {
        defaultNotifications: 'all',
        verificationLevel: 'low'
      }
    }],
    ['friends', {
      id: 'friends',
      name: 'Friends & Family',
      description: 'Private space for close friends or family',
      icon: 'üë•',
      categories: [],
      defaultChannels: [
        { name: 'general', type: 'text', position: 0 },
        { name: 'photos', type: 'text', position: 1 },
        { name: 'Voice Chat', type: 'voice', position: 2 }
      ],
      defaultRoles: [
        { name: 'Family', permissions: ALL_PERMISSIONS, color: '#E91E63' }
      ],
      settings: {
        defaultNotifications: 'all',
        verificationLevel: 'none',
        isPrivate: true
      }
    }]
  ]);
  
  async createWaddle(
    request: CreateWaddleRequest,
    userId: string
  ): Promise<CreateWaddleResult> {
    try {
      // Start creation process
      const creationId = crypto.randomUUID();
      await this.updateProgress(creationId, 'starting', 0);
      
      // Step 1: Create waddle entity
      const waddle = await this.createWaddleEntity(request, userId);
      await this.updateProgress(creationId, 'entity_created', 20);
      
      // Step 2: Provision D1 database
      const database = await this.provisionDatabase(waddle.id);
      await this.updateProgress(creationId, 'database_provisioned', 40);
      
      // Step 3: Initialize database schema
      await this.initializeDatabase(database, waddle.id);
      await this.updateProgress(creationId, 'schema_initialized', 50);
      
      // Step 4: Create Durable Objects
      await this.createDurableObjects(waddle.id);
      await this.updateProgress(creationId, 'durable_objects_created', 60);
      
      // Step 5: Apply template
      if (request.templateId) {
        await this.applyTemplate(waddle.id, request.templateId, database);
      }
      await this.updateProgress(creationId, 'template_applied', 80);
      
      // Step 6: Configure voice channels
      await this.configureVoiceChannels(waddle.id, database);
      await this.updateProgress(creationId, 'voice_configured', 90);
      
      // Step 7: Generate invitation
      const inviteCode = await this.generateInviteCode(waddle.id, userId);
      await this.updateProgress(creationId, 'completed', 100);
      
      return {
        success: true,
        waddle,
        inviteCode,
        inviteUrl: `${process.env.APP_URL}/invite/${inviteCode}`
      };
      
    } catch (error) {
      console.error('Waddle creation failed:', error);
      throw new Error('Failed to create waddle');
    }
  }
  
  private async provisionDatabase(waddleId: string): Promise<D1Database> {
    // Call Cloudflare API to create D1 database
    const response = await fetch(`https://api.cloudflare.com/client/v4/accounts/${this.accountId}/d1/database`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: `waddle_${waddleId}`,
        location: 'eu', // EU data residency
        primary_location_hint: 'Western Europe'
      })
    });
    
    if (!response.ok) {
      throw new Error('Failed to provision D1 database');
    }
    
    const { result } = await response.json();
    
    // Store database ID in central registry
    await this.centralDb.prepare(`
      UPDATE waddles 
      SET d1_database_id = ?
      WHERE id = ?
    `).bind(result.id, waddleId).run();
    
    // Create binding in wrangler.toml dynamically
    await this.updateWranglerConfig(waddleId, result.id);
    
    return result;
  }
  
  private async applyTemplate(
    waddleId: string,
    templateId: string,
    db: D1Database
  ): Promise<void> {
    const template = this.templates.get(templateId);
    if (!template) {
      throw new Error('Template not found');
    }
    
    // Create categories
    const categoryMap = new Map<number, string>();
    for (const [index, category] of template.categories.entries()) {
      const categoryId = crypto.randomUUID();
      await db.prepare(`
        INSERT INTO categories (id, name, position)
        VALUES (?, ?, ?)
      `).bind(categoryId, category.name, category.position).run();
      
      categoryMap.set(index, categoryId);
    }
    
    // Create channels
    for (const channel of template.defaultChannels) {
      const channelId = crypto.randomUUID();
      const categoryId = categoryMap.get(channel.categoryIndex);
      
      await db.prepare(`
        INSERT INTO channels (
          id, name, type, category_id, position, voice_config
        ) VALUES (?, ?, ?, ?, ?, ?)
      `).bind(
        channelId,
        channel.name,
        channel.type,
        categoryId || null,
        channel.position,
        channel.voiceConfig ? JSON.stringify(channel.voiceConfig) : null
      ).run();
      
      // Set default channel if it's the first text channel
      if (channel.type === 'text' && !template.settings.defaultChannelId) {
        template.settings.defaultChannelId = channelId;
      }
    }
    
    // Create roles
    for (const role of template.defaultRoles) {
      await db.prepare(`
        INSERT INTO roles (id, name, permissions, color, position)
        VALUES (?, ?, ?, ?, ?)
      `).bind(
        crypto.randomUUID(),
        role.name,
        role.permissions,
        role.color,
        template.defaultRoles.indexOf(role)
      ).run();
    }
  }
}
```

### 2. Creation Wizard UI
```tsx
export function WaddleCreationWizard() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState<CreateWaddleData>({
    name: '',
    description: '',
    templateId: null,
    icon: null,
    banner: null,
    isPublic: false
  });
  const [creating, setCreating] = useState(false);
  const [progress, setProgress] = useState<CreationProgress | null>(null);
  
  const steps = [
    { id: 1, title: 'Basic Info', component: BasicInfoStep },
    { id: 2, title: 'Choose Template', component: TemplateStep },
    { id: 3, title: 'Customize', component: CustomizeStep },
    { id: 4, title: 'Review', component: ReviewStep }
  ];
  
  const CurrentStep = steps[step - 1].component;
  
  const handleCreate = async () => {
    setCreating(true);
    
    try {
      // Subscribe to progress updates
      const progressStream = await api.createWaddleWithProgress(formData);
      
      progressStream.on('progress', (update) => {
        setProgress(update);
      });
      
      const result = await progressStream.completion;
      
      // Redirect to new waddle
      router.push(`/waddle/${result.waddle.id}`);
      
    } catch (error) {
      toast.error('Failed to create waddle');
      setCreating(false);
    }
  };
  
  if (creating && progress) {
    return <CreationProgress progress={progress} />;
  }
  
  return (
    <div className="waddle-creation-wizard">
      <WizardHeader 
        steps={steps} 
        currentStep={step}
        onStepClick={(s) => s < step && setStep(s)}
      />
      
      <div className="wizard-content">
        <CurrentStep
          data={formData}
          onChange={(updates) => setFormData({ ...formData, ...updates })}
          onNext={() => setStep(step + 1)}
          onBack={() => setStep(step - 1)}
        />
      </div>
      
      <div className="wizard-footer">
        {step > 1 && (
          <Button
            variant="secondary"
            onClick={() => setStep(step - 1)}
          >
            Back
          </Button>
        )}
        
        {step < steps.length ? (
          <Button
            variant="primary"
            onClick={() => setStep(step + 1)}
            disabled={!isStepValid(step, formData)}
          >
            Next
          </Button>
        ) : (
          <Button
            variant="primary"
            onClick={handleCreate}
            disabled={!isFormValid(formData)}
          >
            Create Waddle
          </Button>
        )}
      </div>
    </div>
  );
}

function BasicInfoStep({ 
  data, 
  onChange 
}: StepProps) {
  return (
    <div className="basic-info-step">
      <h2>Let's create your waddle</h2>
      <p>A waddle is your community's home. Start with the basics.</p>
      
      <FormField label="Waddle Name" required>
        <Input
          value={data.name}
          onChange={(e) => onChange({ name: e.target.value })}
          placeholder="My Awesome Community"
          maxLength={100}
        />
        <FieldHint>This is your waddle's display name</FieldHint>
      </FormField>
      
      <FormField label="Description">
        <TextArea
          value={data.description}
          onChange={(e) => onChange({ description: e.target.value })}
          placeholder="What's your waddle about?"
          maxLength={1000}
          rows={3}
        />
      </FormField>
      
      <FormField label="Icon">
        <ImageUpload
          value={data.icon}
          onChange={(file) => onChange({ icon: file })}
          accept="image/*"
          maxSize={10 * 1024 * 1024}
          aspectRatio={1}
        />
        <FieldHint>Recommended: 512x512px</FieldHint>
      </FormField>
      
      <FormField>
        <label>
          <input
            type="checkbox"
            checked={data.isPublic}
            onChange={(e) => onChange({ isPublic: e.target.checked })}
          />
          <span>Make this waddle discoverable</span>
        </label>
        <FieldHint>
          Public waddles appear in search and can be joined by anyone with the link
        </FieldHint>
      </FormField>
    </div>
  );
}

function TemplateStep({ 
  data, 
  onChange 
}: StepProps) {
  const templates = [
    {
      id: 'gaming',
      name: 'Gaming Community',
      description: 'Voice channels for gaming, text chat for coordination',
      icon: 'üéÆ',
      preview: '/templates/gaming.png'
    },
    {
      id: 'study',
      name: 'Study Group',
      description: 'Focused study rooms with limited capacity',
      icon: 'üìö',
      preview: '/templates/study.png'
    },
    {
      id: 'friends',
      name: 'Friends & Family',
      description: 'Simple setup for small groups',
      icon: 'üë•',
      preview: '/templates/friends.png'
    },
    {
      id: 'custom',
      name: 'Start from Scratch',
      description: 'Create your own channel structure',
      icon: 'üõ†Ô∏è',
      preview: '/templates/custom.png'
    }
  ];
  
  return (
    <div className="template-step">
      <h2>Choose a template</h2>
      <p>Templates help you get started quickly. You can customize everything later.</p>
      
      <div className="template-grid">
        {templates.map(template => (
          <TemplateCard
            key={template.id}
            template={template}
            selected={data.templateId === template.id}
            onSelect={() => onChange({ templateId: template.id })}
          />
        ))}
      </div>
      
      {data.templateId && data.templateId !== 'custom' && (
        <TemplatePreview templateId={data.templateId} />
      )}
    </div>
  );
}
```

### 3. Voice Channel Auto-Configuration
```typescript
export class VoiceChannelConfigurator {
  async configureVoiceChannels(
    waddleId: string,
    db: D1Database
  ): Promise<void> {
    // Get all voice channels
    const channels = await db.prepare(`
      SELECT id, name, voice_config
      FROM channels
      WHERE type IN ('voice', 'stage')
    `).all();
    
    for (const channel of channels.results) {
      // Pre-allocate RTK resources
      await this.preAllocateRTKSession(waddleId, channel.id, channel.voice_config);
      
      // Create voice state Durable Object
      await this.createVoiceStateDO(waddleId, channel.id);
      
      // Set up monitoring
      await this.setupVoiceMonitoring(waddleId, channel.id);
    }
  }
  
  private async preAllocateRTKSession(
    waddleId: string,
    channelId: string,
    config: any
  ): Promise<void> {
    const sessionConfig = {
      sessionId: `${waddleId}_${channelId}_standby`,
      maxParticipants: config?.userLimit || 99,
      features: {
        recording: false,
        transcription: false,
        noiseSupression: true
      },
      standby: true // Special flag for pre-allocated sessions
    };
    
    // Create standby session that can be activated quickly
    await this.rtkManager.createStandbySession(sessionConfig);
  }
  
  private async createVoiceStateDO(
    waddleId: string,
    channelId: string
  ): Promise<void> {
    const doId = this.env.VOICE_STATE_DO.idFromName(`${waddleId}_${channelId}`);
    const stub = this.env.VOICE_STATE_DO.get(doId);
    
    // Initialize DO with channel config
    await stub.initialize({
      waddleId,
      channelId,
      createdAt: Date.now()
    });
  }
}
```

### 4. Progress Tracking
```typescript
export class CreationProgressTracker {
  private progressMap = new Map<string, ProgressUpdate>();
  private subscribers = new Map<string, Set<(update: ProgressUpdate) => void>>();
  
  async updateProgress(
    creationId: string,
    stage: CreationStage,
    percentage: number,
    details?: string
  ): Promise<void> {
    const update: ProgressUpdate = {
      creationId,
      stage,
      percentage,
      details,
      timestamp: Date.now()
    };
    
    this.progressMap.set(creationId, update);
    
    // Notify subscribers
    const subs = this.subscribers.get(creationId);
    if (subs) {
      subs.forEach(callback => callback(update));
    }
    
    // Store in KV for persistence
    await this.env.PROGRESS_KV.put(
      `creation:${creationId}`,
      JSON.stringify(update),
      { expirationTtl: 3600 } // 1 hour
    );
  }
  
  subscribe(
    creationId: string,
    callback: (update: ProgressUpdate) => void
  ): () => void {
    if (!this.subscribers.has(creationId)) {
      this.subscribers.set(creationId, new Set());
    }
    
    this.subscribers.get(creationId)!.add(callback);
    
    // Send current progress immediately
    const current = this.progressMap.get(creationId);
    if (current) {
      callback(current);
    }
    
    // Return unsubscribe function
    return () => {
      const subs = this.subscribers.get(creationId);
      if (subs) {
        subs.delete(callback);
        if (subs.size === 0) {
          this.subscribers.delete(creationId);
        }
      }
    };
  }
}

// Progress UI component
export function CreationProgress({ 
  progress 
}: { 
  progress: ProgressUpdate;
}) {
  const stages = [
    { id: 'starting', label: 'Starting', icon: <PlayIcon /> },
    { id: 'entity_created', label: 'Creating waddle', icon: <AddIcon /> },
    { id: 'database_provisioned', label: 'Setting up database', icon: <DatabaseIcon /> },
    { id: 'schema_initialized', label: 'Initializing', icon: <BuildIcon /> },
    { id: 'durable_objects_created', label: 'Creating infrastructure', icon: <CloudIcon /> },
    { id: 'template_applied', label: 'Applying template', icon: <TemplateIcon /> },
    { id: 'voice_configured', label: 'Configuring voice', icon: <MicIcon /> },
    { id: 'completed', label: 'Complete!', icon: <CheckIcon /> }
  ];
  
  const currentStageIndex = stages.findIndex(s => s.id === progress.stage);
  
  return (
    <div className="creation-progress">
      <div className="progress-header">
        <h2>Creating your waddle</h2>
        <p>This usually takes about 30 seconds</p>
      </div>
      
      <div className="progress-bar">
        <div 
          className="progress-fill"
          style={{ width: `${progress.percentage}%` }}
        />
      </div>
      
      <div className="progress-stages">
        {stages.map((stage, index) => (
          <div 
            key={stage.id}
            className={`progress-stage ${
              index <= currentStageIndex ? 'completed' : ''
            } ${stage.id === progress.stage ? 'current' : ''}`}
          >
            <div className="stage-icon">{stage.icon}</div>
            <div className="stage-label">{stage.label}</div>
          </div>
        ))}
      </div>
      
      {progress.details && (
        <div className="progress-details">
          {progress.details}
        </div>
      )}
      
      <LoadingAnimation />
    </div>
  );
}
```

### 5. Invitation System
```typescript
export class InvitationManager {
  async generateInviteCode(
    waddleId: string,
    creatorId: string,
    options: InviteOptions = {}
  ): Promise<string> {
    const code = this.generateUniqueCode();
    
    const invite = {
      code,
      waddleId,
      createdBy: creatorId,
      createdAt: Date.now(),
      expiresAt: options.expiresIn 
        ? Date.now() + options.expiresIn 
        : null,
      maxUses: options.maxUses || null,
      uses: 0,
      targetRole: options.targetRole || 'member'
    };
    
    // Store in central database
    await this.db.prepare(`
      INSERT INTO invites (
        code, waddle_id, created_by, created_at, 
        expires_at, max_uses, uses, target_role
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(...Object.values(invite)).run();
    
    return code;
  }
  
  private generateUniqueCode(): string {
    // Generate readable code like "waddle-happy-penguin-123"
    const adjectives = ['happy', 'cool', 'swift', 'brave', 'clever'];
    const nouns = ['penguin', 'waddle', 'splash', 'slide', 'dive'];
    const number = Math.floor(Math.random() * 999);
    
    const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    
    return `${adj}-${noun}-${number}`;
  }
  
  async createInviteLink(
    waddleId: string,
    options: InviteLinkOptions
  ): Promise<InviteLink> {
    const code = await this.generateInviteCode(waddleId, options.userId, {
      expiresIn: options.temporary ? 24 * 60 * 60 * 1000 : null, // 24 hours
      maxUses: options.maxUses
    });
    
    return {
      code,
      url: `${this.baseUrl}/invite/${code}`,
      expiresAt: options.temporary 
        ? new Date(Date.now() + 24 * 60 * 60 * 1000) 
        : null
    };
  }
}
```

### 6. Default Channel Structure
```typescript
export const DEFAULT_CHANNEL_STRUCTURES = {
  minimal: {
    channels: [
      { name: 'general', type: 'text' },
      { name: 'voice', type: 'voice' }
    ]
  },
  
  standard: {
    categories: [
      {
        name: 'Text Channels',
        channels: [
          { name: 'welcome', type: 'text', permissions: { write: ['admin', 'moderator'] } },
          { name: 'general', type: 'text' },
          { name: 'off-topic', type: 'text' }
        ]
      },
      {
        name: 'Voice Channels',
        channels: [
          { name: 'General Voice', type: 'voice' },
          { name: 'Music', type: 'voice', voiceConfig: { bitrate: 96000 } }
        ]
      }
    ]
  },
  
  professional: {
    categories: [
      {
        name: 'Announcements',
        channels: [
          { name: 'news', type: 'announcement' },
          { name: 'updates', type: 'announcement' }
        ]
      },
      {
        name: 'Teams',
        channels: [
          { name: 'general', type: 'text' },
          { name: 'dev-team', type: 'text' },
          { name: 'design-team', type: 'text' }
        ]
      },
      {
        name: 'Meetings',
        channels: [
          { name: 'Meeting Room 1', type: 'voice', voiceConfig: { userLimit: 10 } },
          { name: 'Meeting Room 2', type: 'voice', voiceConfig: { userLimit: 10 } },
          { name: 'All Hands', type: 'stage' }
        ]
      }
    ]
  }
};
```

### 7. Error Recovery
```typescript
export class WaddleCreationRecovery {
  async recoverFailedCreation(
    creationId: string,
    lastStage: CreationStage
  ): Promise<void> {
    // Get creation data
    const data = await this.getCreationData(creationId);
    if (!data) {
      throw new Error('Creation data not found');
    }
    
    // Determine recovery point
    const recoveryStages = this.getRecoveryStages(lastStage);
    
    for (const stage of recoveryStages) {
      try {
        await this.executeStage(stage, data);
        await this.updateProgress(creationId, stage, this.getStageProgress(stage));
      } catch (error) {
        console.error(`Recovery failed at stage ${stage}:`, error);
        throw error;
      }
    }
  }
  
  private getRecoveryStages(fromStage: CreationStage): CreationStage[] {
    const allStages = [
      'entity_created',
      'database_provisioned',
      'schema_initialized',
      'durable_objects_created',
      'template_applied',
      'voice_configured',
      'completed'
    ];
    
    const startIndex = allStages.indexOf(fromStage);
    return allStages.slice(startIndex + 1);
  }
  
  async cleanupPartialCreation(waddleId: string): Promise<void> {
    try {
      // Remove from central database
      await this.db.prepare('DELETE FROM waddles WHERE id = ?').bind(waddleId).run();
      
      // Delete D1 database if created
      const dbId = await this.getDatabaseId(waddleId);
      if (dbId) {
        await this.deleteD1Database(dbId);
      }
      
      // Clean up Durable Objects
      await this.cleanupDurableObjects(waddleId);
      
    } catch (error) {
      console.error('Cleanup failed:', error);
    }
  }
}
```

## Dependencies
- Database Schema (Issue #05) for waddle structure
- Voice Channel Model (Issue #13) for voice setup
- RealTimeKit Setup (Issue #02) for voice configuration
- Authentication (Issue #03) for ownership

## Estimated Effort
**5 days**
- 1 day: Creation service and database provisioning
- 1 day: Creation wizard UI
- 1 day: Template system
- 1 day: Voice channel configuration
- 1 day: Progress tracking and error recovery

## Notes
- Consider adding custom templates that users can save
- Implement cost estimation before creation
- Add waddle cloning feature
- Monitor D1 database creation quotas