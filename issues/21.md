# Issue #21: Discovery System (Public Directory)

## User Story
As a **new user**, I want to **discover and join public waddles that match my interests** so that **I can find communities without needing an invitation link**.

## Description
Implement a comprehensive discovery system that allows users to browse, search, and filter public waddles. This includes categorization, trending algorithms, featured waddles, and smart recommendations based on user interests and activity.

## Acceptance Criteria
- [ ] Public waddle directory with categories
- [ ] Search functionality with filters
- [ ] Trending waddles algorithm
- [ ] Featured waddles curation
- [ ] Preview mode for public waddles
- [ ] Join restrictions and verification
- [ ] Discovery privacy settings
- [ ] Mobile-optimized browsing

## Technical Implementation

### 1. Discovery Service Architecture
```typescript
export class DiscoveryService {
  constructor(
    private db: D1Database,
    private search: SearchService,
    private analytics: AnalyticsService,
    private cache: KVNamespace
  ) {}
  
  async getDiscoverableWaddles(
    request: DiscoveryRequest
  ): Promise<DiscoveryResponse> {
    const cacheKey = this.generateCacheKey(request);
    
    // Check cache first
    const cached = await this.cache.get(cacheKey);
    if (cached && !request.fresh) {
      return JSON.parse(cached);
    }
    
    // Build query
    const query = this.buildDiscoveryQuery(request);
    
    // Execute search
    const results = await this.executeSearch(query);
    
    // Enhance with trending data
    const enhanced = await this.enhanceWithTrending(results);
    
    // Apply personalization
    const personalized = await this.personalizeResults(enhanced, request.userId);
    
    // Format response
    const response = {
      waddles: personalized,
      facets: await this.calculateFacets(results),
      totalCount: results.totalCount,
      hasMore: results.hasMore,
      cursor: results.cursor
    };
    
    // Cache results
    await this.cache.put(cacheKey, JSON.stringify(response), {
      expirationTtl: 300 // 5 minutes
    });
    
    return response;
  }
  
  private buildDiscoveryQuery(request: DiscoveryRequest): SearchQuery {
    const query = new SearchQueryBuilder();
    
    // Text search
    if (request.searchTerm) {
      query.addTextSearch(request.searchTerm, {
        fields: ['name', 'description', 'tags'],
        boost: { name: 2.0, tags: 1.5, description: 1.0 }
      });
    }
    
    // Category filter
    if (request.category) {
      query.addFilter('category', request.category);
    }
    
    // Size filter
    if (request.sizeRange) {
      query.addRangeFilter('member_count', 
        request.sizeRange.min, 
        request.sizeRange.max
      );
    }
    
    // Language filter
    if (request.languages?.length) {
      query.addFilter('primary_language', request.languages);
    }
    
    // Activity filter
    if (request.activityLevel) {
      const thresholds = {
        high: 100,    // 100+ messages/day
        medium: 20,   // 20-100 messages/day
        low: 1        // 1-20 messages/day
      };
      query.addRangeFilter('daily_message_count', 
        thresholds[request.activityLevel],
        request.activityLevel === 'high' ? null : thresholds[request.activityLevel] * 5
      );
    }
    
    // Exclude adult content by default
    if (!request.includeAdult) {
      query.addFilter('is_adult', false);
    }
    
    // Sort order
    switch (request.sortBy) {
      case 'trending':
        query.addSort('trending_score', 'desc');
        break;
      case 'members':
        query.addSort('member_count', 'desc');
        break;
      case 'activity':
        query.addSort('daily_message_count', 'desc');
        break;
      case 'newest':
        query.addSort('created_at', 'desc');
        break;
      default:
        // Relevance sort (default)
        query.addSort('_score', 'desc');
    }
    
    // Pagination
    query.setLimit(request.limit || 20);
    query.setOffset(request.offset || 0);
    
    return query.build();
  }
}
```

### 2. Trending Algorithm
```typescript
export class TrendingCalculator {
  private readonly TRENDING_WINDOW = 7 * 24 * 60 * 60 * 1000; // 7 days
  private readonly DECAY_FACTOR = 0.95;
  
  async calculateTrendingScores(): Promise<void> {
    const waddles = await this.getPublicWaddles();
    
    for (const waddle of waddles) {
      const score = await this.calculateWaddleScore(waddle);
      await this.updateTrendingScore(waddle.id, score);
    }
    
    // Update trending ranks
    await this.updateTrendingRanks();
  }
  
  private async calculateWaddleScore(waddle: Waddle): Promise<number> {
    const now = Date.now();
    const metrics = await this.getWaddleMetrics(waddle.id);
    
    // Base score components
    const components = {
      // New members (heavily weighted for growth)
      newMembers: metrics.newMembersLastWeek * 10,
      
      // Message activity
      messageActivity: Math.log10(metrics.messagesLastWeek + 1) * 5,
      
      // Voice activity (minutes)
      voiceActivity: Math.log10(metrics.voiceMinutesLastWeek + 1) * 3,
      
      // Unique active users
      uniqueUsers: Math.sqrt(metrics.uniqueActiveUsers) * 8,
      
      // Retention rate
      retention: metrics.weeklyRetentionRate * 20,
      
      // Age penalty (newer waddles get boost)
      agePenalty: this.calculateAgePenalty(waddle.created_at)
    };
    
    // Calculate weighted score
    let score = 0;
    for (const [component, value] of Object.entries(components)) {
      score += value;
    }
    
    // Apply time decay to prevent stale trending
    const hoursSinceLastActivity = (now - metrics.lastActivityAt) / (1000 * 60 * 60);
    const timeDecay = Math.pow(this.DECAY_FACTOR, hoursSinceLastActivity / 24);
    
    score *= timeDecay;
    
    // Boost for featured waddles
    if (waddle.isFeatured) {
      score *= 1.5;
    }
    
    // Penalty for adult content
    if (waddle.isAdult) {
      score *= 0.5;
    }
    
    return Math.max(0, score);
  }
  
  private calculateAgePenalty(createdAt: number): number {
    const ageInDays = (Date.now() - createdAt) / (1000 * 60 * 60 * 24);
    
    if (ageInDays < 7) return 1.5;    // New waddle boost
    if (ageInDays < 30) return 1.2;   // Month-old boost
    if (ageInDays < 90) return 1.0;   // Neutral
    return 0.8;                        // Older waddle penalty
  }
}
```

### 3. Category System
```typescript
export const WADDLE_CATEGORIES = {
  gaming: {
    id: 'gaming',
    name: 'Gaming',
    icon: 'ðŸŽ®',
    subcategories: ['fps', 'moba', 'rpg', 'strategy', 'casual'],
    keywords: ['game', 'gaming', 'esports', 'clan', 'guild']
  },
  education: {
    id: 'education', 
    name: 'Education',
    icon: 'ðŸ“š',
    subcategories: ['study', 'language', 'programming', 'science', 'math'],
    keywords: ['learn', 'study', 'education', 'course', 'tutorial']
  },
  technology: {
    id: 'technology',
    name: 'Technology', 
    icon: 'ðŸ’»',
    subcategories: ['programming', 'crypto', 'ai', 'hardware', 'opensource'],
    keywords: ['tech', 'code', 'dev', 'programming', 'software']
  },
  creative: {
    id: 'creative',
    name: 'Creative',
    icon: 'ðŸŽ¨',
    subcategories: ['art', 'music', 'writing', 'design', 'photography'],
    keywords: ['art', 'creative', 'design', 'music', 'artist']
  },
  community: {
    id: 'community',
    name: 'Community',
    icon: 'ðŸ‘¥',
    subcategories: ['local', 'hobbies', 'support', 'social', 'events'],
    keywords: ['community', 'social', 'friends', 'chat', 'hangout']
  },
  entertainment: {
    id: 'entertainment',
    name: 'Entertainment',
    icon: 'ðŸŽ¬',
    subcategories: ['movies', 'tv', 'anime', 'books', 'podcasts'],
    keywords: ['entertainment', 'fun', 'media', 'content', 'streaming']
  }
};

export class CategoryMatcher {
  async suggestCategories(waddle: Waddle): Promise<string[]> {
    const text = `${waddle.name} ${waddle.description} ${waddle.tags?.join(' ')}`.toLowerCase();
    const scores = new Map<string, number>();
    
    for (const [categoryId, category] of Object.entries(WADDLE_CATEGORIES)) {
      let score = 0;
      
      // Check keywords
      for (const keyword of category.keywords) {
        if (text.includes(keyword)) {
          score += 10;
        }
      }
      
      // Check subcategory names
      for (const sub of category.subcategories) {
        if (text.includes(sub)) {
          score += 15;
        }
      }
      
      // Boost exact category name match
      if (text.includes(category.name.toLowerCase())) {
        score += 20;
      }
      
      if (score > 0) {
        scores.set(categoryId, score);
      }
    }
    
    // Return top 3 categories
    return Array.from(scores.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([categoryId]) => categoryId);
  }
}
```

### 4. Discovery UI Components
```tsx
export function DiscoveryPage() {
  const [filters, setFilters] = useState<DiscoveryFilters>({
    category: null,
    searchTerm: '',
    sortBy: 'trending',
    sizeRange: null,
    languages: [],
    activityLevel: null
  });
  
  const { waddles, loading, hasMore, loadMore } = useDiscovery(filters);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  
  return (
    <div className="discovery-page">
      <DiscoveryHeader />
      
      <div className="discovery-container">
        <aside className="discovery-sidebar">
          <DiscoveryFilters 
            filters={filters}
            onChange={setFilters}
          />
          
          <TrendingTags />
          <FeaturedWaddles />
        </aside>
        
        <main className="discovery-content">
          <div className="discovery-controls">
            <SearchBar 
              value={filters.searchTerm}
              onChange={(term) => setFilters({ ...filters, searchTerm: term })}
              placeholder="Search waddles..."
            />
            
            <div className="view-controls">
              <SortDropdown 
                value={filters.sortBy}
                onChange={(sortBy) => setFilters({ ...filters, sortBy })}
              />
              
              <ViewModeToggle 
                mode={viewMode}
                onChange={setViewMode}
              />
            </div>
          </div>
          
          {loading && waddles.length === 0 ? (
            <DiscoverySkeleton />
          ) : (
            <InfiniteScroll
              loadMore={loadMore}
              hasMore={hasMore}
              loader={<LoadingSpinner />}
            >
              <WaddleGrid 
                waddles={waddles}
                viewMode={viewMode}
              />
            </InfiniteScroll>
          )}
        </main>
      </div>
    </div>
  );
}

function WaddleCard({ waddle }: { waddle: DiscoverableWaddle }) {
  const [preview, setPreview] = useState<WaddlePreview | null>(null);
  const [showPreview, setShowPreview] = useState(false);
  
  const handlePreview = async () => {
    const data = await api.getWaddlePreview(waddle.id);
    setPreview(data);
    setShowPreview(true);
  };
  
  return (
    <>
      <div className="waddle-card">
        <div className="waddle-banner">
          <img src={waddle.bannerUrl || '/default-banner.png'} alt="" />
          {waddle.verified && <VerifiedBadge />}
        </div>
        
        <div className="waddle-info">
          <div className="waddle-header">
            <img 
              src={waddle.iconUrl || '/default-icon.png'} 
              alt={waddle.name}
              className="waddle-icon"
            />
            <div>
              <h3>{waddle.name}</h3>
              <span className="member-count">
                {formatNumber(waddle.memberCount)} members
              </span>
            </div>
          </div>
          
          <p className="waddle-description">
            {truncate(waddle.description, 120)}
          </p>
          
          <div className="waddle-stats">
            <Stat icon={<MessageIcon />} value={waddle.dailyMessages} label="msgs/day" />
            <Stat icon={<VoiceIcon />} value={waddle.activeVoiceUsers} label="in voice" />
            <Stat icon={<TrendingIcon />} value={waddle.trendingRank} label="trending" />
          </div>
          
          <div className="waddle-tags">
            <CategoryBadge category={waddle.category} />
            {waddle.tags.slice(0, 3).map(tag => (
              <Tag key={tag} text={tag} />
            ))}
          </div>
          
          <div className="waddle-actions">
            <Button
              variant="secondary"
              size="small"
              onClick={handlePreview}
            >
              Preview
            </Button>
            <Button
              variant="primary"
              size="small"
              onClick={() => joinWaddle(waddle.id)}
            >
              Join
            </Button>
          </div>
        </div>
      </div>
      
      {showPreview && preview && (
        <WaddlePreviewModal
          waddle={waddle}
          preview={preview}
          onClose={() => setShowPreview(false)}
        />
      )}
    </>
  );
}
```

### 5. Waddle Preview System
```typescript
export class WaddlePreviewService {
  async generatePreview(waddleId: string): Promise<WaddlePreview> {
    const waddle = await this.getWaddle(waddleId);
    
    if (!waddle.isPublic) {
      throw new Error('Waddle is not public');
    }
    
    // Get preview data
    const [channels, recentMessages, activeUsers, rules] = await Promise.all([
      this.getPreviewChannels(waddleId),
      this.getRecentMessages(waddleId, 10),
      this.getActiveUsers(waddleId, 20),
      this.getWaddleRules(waddleId)
    ]);
    
    return {
      waddle: {
        id: waddle.id,
        name: waddle.name,
        description: waddle.description,
        memberCount: waddle.memberCount,
        createdAt: waddle.createdAt,
        category: waddle.category,
        tags: waddle.tags,
        iconUrl: waddle.iconUrl,
        bannerUrl: waddle.bannerUrl,
        primaryLanguage: waddle.primaryLanguage
      },
      channels: channels.map(ch => ({
        name: ch.name,
        type: ch.type,
        description: ch.description,
        isLocked: ch.requiresPermission
      })),
      recentActivity: {
        messages: recentMessages.map(msg => ({
          channelName: msg.channelName,
          timestamp: msg.timestamp,
          isVoiceActivity: msg.type === 'voice_join'
        })),
        activeVoiceChannels: channels
          .filter(ch => ch.type === 'voice' && ch.activeUsers > 0)
          .length
      },
      activeUsers: {
        total: activeUsers.length,
        inVoice: activeUsers.filter(u => u.inVoice).length,
        preview: activeUsers.slice(0, 10).map(u => ({
          username: u.username,
          avatarUrl: u.avatarUrl,
          isInVoice: u.inVoice
        }))
      },
      rules: rules?.content || null,
      features: {
        hasVoiceChannels: channels.some(ch => ch.type === 'voice'),
        hasStageChannels: channels.some(ch => ch.type === 'stage'),
        hasForumChannels: channels.some(ch => ch.type === 'forum'),
        hasVerification: waddle.verificationLevel !== 'none',
        has2FA: waddle.requires2FA
      }
    };
  }
  
  async canJoinWaddle(userId: string, waddleId: string): Promise<JoinCheck> {
    const waddle = await this.getWaddle(waddleId);
    const user = await this.getUser(userId);
    
    // Check if already member
    if (await this.isMember(userId, waddleId)) {
      return { canJoin: false, reason: 'already_member' };
    }
    
    // Check if banned
    if (await this.isBanned(userId, waddleId)) {
      return { canJoin: false, reason: 'banned' };
    }
    
    // Check member limit
    if (waddle.memberLimit && waddle.memberCount >= waddle.memberLimit) {
      return { canJoin: false, reason: 'full' };
    }
    
    // Check verification requirements
    if (waddle.verificationLevel === 'high' && !user.emailVerified) {
      return { canJoin: false, reason: 'email_verification_required' };
    }
    
    if (waddle.requires2FA && !user.has2FA) {
      return { canJoin: false, reason: '2fa_required' };
    }
    
    // Check age restrictions
    if (waddle.minimumAge && user.age < waddle.minimumAge) {
      return { canJoin: false, reason: 'age_restriction' };
    }
    
    return { canJoin: true };
  }
}
```

### 6. Search and Filtering
```typescript
export class WaddleSearchService {
  private searchClient: SearchClient;
  
  constructor() {
    this.searchClient = new SearchClient({
      apiKey: process.env.SEARCH_API_KEY,
      index: 'waddles'
    });
  }
  
  async indexWaddle(waddle: Waddle): Promise<void> {
    if (!waddle.isPublic) {
      // Remove from index if exists
      await this.searchClient.delete(waddle.id);
      return;
    }
    
    const searchDocument = {
      objectID: waddle.id,
      name: waddle.name,
      description: waddle.description,
      category: waddle.category,
      subcategories: waddle.subcategories,
      tags: waddle.tags,
      memberCount: waddle.memberCount,
      dailyMessages: await this.getDailyMessageCount(waddle.id),
      weeklyActiveUsers: await this.getWeeklyActiveUsers(waddle.id),
      primaryLanguage: waddle.primaryLanguage,
      languages: waddle.supportedLanguages,
      createdAt: waddle.createdAt,
      trendingScore: waddle.trendingScore,
      isVerified: waddle.isVerified,
      isAdult: waddle.isAdult,
      features: waddle.features,
      _geoloc: waddle.location ? {
        lat: waddle.location.lat,
        lng: waddle.location.lng
      } : undefined
    };
    
    await this.searchClient.saveObject(searchDocument);
  }
  
  async search(query: SearchQuery): Promise<SearchResults> {
    const searchParams = {
      query: query.text,
      filters: this.buildFilters(query.filters),
      facets: ['category', 'primaryLanguage', 'features'],
      maxFacetHits: 10,
      page: query.page || 0,
      hitsPerPage: query.limit || 20,
      attributesToRetrieve: [
        'name', 'description', 'category', 'memberCount',
        'iconUrl', 'bannerUrl', 'tags', 'isVerified'
      ],
      attributesToHighlight: ['name', 'description'],
      highlightPreTag: '<mark>',
      highlightPostTag: '</mark>'
    };
    
    // Add geo search if location provided
    if (query.location) {
      searchParams.aroundLatLng = `${query.location.lat},${query.location.lng}`;
      searchParams.aroundRadius = query.location.radius || 50000; // 50km default
    }
    
    const results = await this.searchClient.search(searchParams);
    
    return {
      hits: results.hits.map(hit => this.formatHit(hit)),
      totalHits: results.nbHits,
      page: results.page,
      totalPages: results.nbPages,
      facets: results.facets,
      processingTime: results.processingTimeMS
    };
  }
}
```

### 7. Privacy and Safety
```typescript
export class DiscoveryPrivacyManager {
  async enforcePrivacyRules(
    waddles: DiscoverableWaddle[], 
    userId: string
  ): Promise<DiscoverableWaddle[]> {
    const user = await this.getUser(userId);
    
    return waddles.filter(waddle => {
      // Hide adult content from minors
      if (waddle.isAdult && user.age < 18) {
        return false;
      }
      
      // Hide blocked waddles
      if (user.blockedWaddles?.includes(waddle.id)) {
        return false;
      }
      
      // Hide waddles from blocked users
      if (waddle.ownerId && user.blockedUsers?.includes(waddle.ownerId)) {
        return false;
      }
      
      // Apply region restrictions
      if (waddle.regionRestrictions?.length > 0) {
        if (!waddle.regionRestrictions.includes(user.country)) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  async reportWaddle(
    waddleId: string, 
    reporterId: string, 
    reason: ReportReason,
    details?: string
  ): Promise<void> {
    const report = {
      id: crypto.randomUUID(),
      waddleId,
      reporterId,
      reason,
      details,
      createdAt: Date.now(),
      status: 'pending'
    };
    
    await this.db.prepare(`
      INSERT INTO waddle_reports 
      (id, waddle_id, reporter_id, reason, details, created_at, status)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(...Object.values(report)).run();
    
    // Notify moderation team
    await this.notifyModerators(report);
    
    // Auto-hide if threshold reached
    await this.checkReportThreshold(waddleId);
  }
}
```

## Dependencies
- Database Schema (Issue #05) for waddle data
- Search Infrastructure (Issue #59) for full-text search
- Analytics Service (Issue #61) for trending data
- Permission System (Issue #23) for access control

## Estimated Effort
**6 days**
- 1 day: Core discovery service and trending algorithm
- 1 day: Search and filtering implementation
- 1 day: Category system and auto-categorization
- 1 day: Preview system and join flow
- 1 day: Discovery UI components
- 1 day: Privacy, safety, and testing

## Notes
- Consider implementing recommendation engine
- Add A/B testing for trending algorithm
- Monitor search performance and optimize indices
- Implement gradual rollout for algorithm changes
- Add content moderation for public waddles