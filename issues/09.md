# Issue #09: Media Uploads (R2 Integration)

## User Story
As a **user**, I want to **share images, videos, and files** so that **I can communicate more effectively with visual content and documents**.

## Description
Implement secure media upload functionality using Cloudflare R2 for storage. This includes direct uploads, thumbnail generation, virus scanning, and proper access control with signed URLs.

## Acceptance Criteria
- [ ] Users can upload images, videos, and documents up to 100MB
- [ ] Images are automatically resized for thumbnails
- [ ] Videos show preview thumbnails
- [ ] Files are scanned for malware before storage
- [ ] Access controlled via signed URLs (expire after 7 days)
- [ ] Progress indication during upload
- [ ] Drag-and-drop support in web UI
- [ ] Paste images from clipboard

## Technical Implementation

### 1. R2 Bucket Configuration
```javascript
// Worker configuration for R2
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    
    if (url.pathname.startsWith('/upload')) {
      return handleUpload(request, env);
    } else if (url.pathname.startsWith('/media')) {
      return handleMediaAccess(request, env);
    }
    
    return new Response('Not found', { status: 404 });
  }
};

// R2 bucket structure
const BUCKET_STRUCTURE = {
  avatars: 'avatars/{userId}/{hash}.{ext}',
  waddle_icons: 'waddles/{waddleId}/icon.{ext}',
  message_attachments: 'messages/{waddleId}/{channelId}/{messageId}/{filename}',
  thumbnails: 'thumbnails/{size}/{path}'
};

// Wrangler.toml configuration
/*
[[r2_buckets]]
binding = "MEDIA_BUCKET"
bucket_name = "waddle-media"
preview_bucket_name = "waddle-media-preview"

[[r2_buckets]]
binding = "TEMP_BUCKET"
bucket_name = "waddle-temp"
preview_bucket_name = "waddle-temp-preview"
*/
```

### 2. Direct Upload Implementation
```javascript
export async function handleUpload(request, env) {
  // Verify authentication
  const user = await verifyAuth(request, env);
  if (!user) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  // Parse multipart form data
  const formData = await request.formData();
  const file = formData.get('file');
  const context = formData.get('context'); // 'message', 'avatar', 'waddle_icon'
  
  // Validate file
  const validation = await validateFile(file, context);
  if (!validation.valid) {
    return new Response(JSON.stringify({ error: validation.error }), { 
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  // Generate unique key
  const key = generateFileKey(file, context, user);
  
  // Upload to temporary bucket first
  const uploadId = crypto.randomUUID();
  const tempKey = `uploads/${uploadId}/${file.name}`;
  
  try {
    // Stream upload to R2
    await env.TEMP_BUCKET.put(tempKey, file.stream(), {
      httpMetadata: {
        contentType: file.type,
      },
      customMetadata: {
        userId: user.id,
        uploadId,
        originalName: file.name,
        context,
        timestamp: new Date().toISOString()
      }
    });
    
    // Queue for processing (virus scan, thumbnails)
    await env.MEDIA_QUEUE.send({
      type: 'process_upload',
      uploadId,
      tempKey,
      finalKey: key,
      userId: user.id,
      context
    });
    
    // Return upload info
    return new Response(JSON.stringify({
      uploadId,
      status: 'processing',
      checkUrl: `/upload/status/${uploadId}`
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
    
  } catch (error) {
    console.error('Upload error:', error);
    return new Response('Upload failed', { status: 500 });
  }
}

async function validateFile(file, context) {
  const MAX_SIZES = {
    message: 100 * 1024 * 1024, // 100MB
    avatar: 10 * 1024 * 1024,   // 10MB
    waddle_icon: 10 * 1024 * 1024 // 10MB
  };
  
  const ALLOWED_TYPES = {
    message: ['image/*', 'video/*', 'application/*', 'text/*'],
    avatar: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    waddle_icon: ['image/jpeg', 'image/png', 'image/svg+xml']
  };
  
  // Check size
  if (file.size > MAX_SIZES[context]) {
    return {
      valid: false,
      error: `File too large. Maximum size: ${MAX_SIZES[context] / 1024 / 1024}MB`
    };
  }
  
  // Check type
  const allowed = ALLOWED_TYPES[context];
  const isAllowed = allowed.some(pattern => {
    if (pattern.endsWith('/*')) {
      return file.type.startsWith(pattern.slice(0, -2));
    }
    return file.type === pattern;
  });
  
  if (!isAllowed) {
    return {
      valid: false,
      error: `File type not allowed: ${file.type}`
    };
  }
  
  return { valid: true };
}
```

### 3. Media Processing Queue
```javascript
export class MediaProcessor {
  async queue(batch, env) {
    for (const message of batch.messages) {
      await this.processUpload(message.body, env);
    }
  }
  
  async processUpload(data, env) {
    const { uploadId, tempKey, finalKey, userId, context } = data;
    
    try {
      // Get file from temp bucket
      const tempFile = await env.TEMP_BUCKET.get(tempKey);
      if (!tempFile) {
        throw new Error('Temp file not found');
      }
      
      // Virus scan
      const scanResult = await this.scanFile(tempFile, env);
      if (!scanResult.clean) {
        await this.handleMaliciousFile(uploadId, userId, scanResult, env);
        return;
      }
      
      // Process based on file type
      const contentType = tempFile.httpMetadata.contentType;
      const processedFiles = [];
      
      if (contentType.startsWith('image/')) {
        // Generate thumbnails
        const thumbnails = await this.generateImageThumbnails(tempFile, finalKey, env);
        processedFiles.push(...thumbnails);
      } else if (contentType.startsWith('video/')) {
        // Extract video thumbnail
        const thumbnail = await this.generateVideoThumbnail(tempFile, finalKey, env);
        processedFiles.push(thumbnail);
      }
      
      // Move to final bucket
      await env.MEDIA_BUCKET.put(finalKey, tempFile.body, {
        httpMetadata: tempFile.httpMetadata,
        customMetadata: {
          ...tempFile.customMetadata,
          processed: 'true',
          processedAt: new Date().toISOString()
        }
      });
      processedFiles.push({ key: finalKey, type: 'original' });
      
      // Clean up temp file
      await env.TEMP_BUCKET.delete(tempKey);
      
      // Update upload status
      await this.updateUploadStatus(uploadId, 'complete', processedFiles, env);
      
    } catch (error) {
      console.error('Processing error:', error);
      await this.updateUploadStatus(uploadId, 'failed', null, env);
    }
  }
  
  async generateImageThumbnails(file, baseKey, env) {
    const thumbnails = [];
    const sizes = [
      { name: 'small', width: 150, height: 150 },
      { name: 'medium', width: 300, height: 300 },
      { name: 'large', width: 800, height: 800 }
    ];
    
    for (const size of sizes) {
      try {
        // Use Cloudflare Image Resizing
        const resizedImage = await fetch(`${env.IMAGE_RESIZING_URL}`, {
          method: 'POST',
          headers: {
            'Content-Type': file.httpMetadata.contentType
          },
          body: file.body,
          cf: {
            image: {
              width: size.width,
              height: size.height,
              fit: 'cover',
              quality: 85
            }
          }
        });
        
        const thumbnailKey = `thumbnails/${size.name}/${baseKey}`;
        await env.MEDIA_BUCKET.put(thumbnailKey, resizedImage.body, {
          httpMetadata: {
            contentType: 'image/webp'
          }
        });
        
        thumbnails.push({
          key: thumbnailKey,
          type: `thumbnail_${size.name}`,
          width: size.width,
          height: size.height
        });
      } catch (error) {
        console.error(`Failed to generate ${size.name} thumbnail:`, error);
      }
    }
    
    return thumbnails;
  }
}
```

### 4. Signed URL Generation
```javascript
export class MediaAccess {
  static async generateSignedUrl(key, permissions, expiresIn = 604800, env) {
    // Default 7 days expiry
    const expires = Math.floor(Date.now() / 1000) + expiresIn;
    
    const policy = {
      key,
      expires,
      permissions,
      userId: permissions.userId,
      waddleId: permissions.waddleId
    };
    
    // Sign the policy
    const signature = await this.signPolicy(policy, env.MEDIA_SECRET);
    
    // Create signed URL
    const params = new URLSearchParams({
      expires: expires.toString(),
      signature,
      userId: permissions.userId
    });
    
    return `${env.MEDIA_CDN_URL}/media/${key}?${params}`;
  }
  
  static async verifySignedUrl(request, env) {
    const url = new URL(request.url);
    const key = url.pathname.replace('/media/', '');
    const expires = parseInt(url.searchParams.get('expires'));
    const signature = url.searchParams.get('signature');
    const userId = url.searchParams.get('userId');
    
    // Check expiry
    if (Date.now() / 1000 > expires) {
      return { valid: false, error: 'URL expired' };
    }
    
    // Verify signature
    const policy = { key, expires, userId };
    const expectedSignature = await this.signPolicy(policy, env.MEDIA_SECRET);
    
    if (signature !== expectedSignature) {
      return { valid: false, error: 'Invalid signature' };
    }
    
    // Additional permission checks
    const hasAccess = await this.checkUserAccess(userId, key, env);
    if (!hasAccess) {
      return { valid: false, error: 'Access denied' };
    }
    
    return { valid: true };
  }
  
  static async signPolicy(policy, secret) {
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(policy));
    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(secret),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );
    
    const signature = await crypto.subtle.sign('HMAC', key, data);
    return btoa(String.fromCharCode(...new Uint8Array(signature)));
  }
}
```

### 5. Client Upload Implementation
```typescript
// React upload hook
export function useFileUpload() {
  const [uploads, setUploads] = useState<Map<string, UploadProgress>>(new Map());
  
  const uploadFile = useCallback(async (
    file: File,
    context: UploadContext
  ): Promise<UploadResult> => {
    const uploadId = crypto.randomUUID();
    
    // Add to tracking
    setUploads(prev => new Map(prev).set(uploadId, {
      id: uploadId,
      file,
      progress: 0,
      status: 'uploading'
    }));
    
    try {
      // Create form data
      const formData = new FormData();
      formData.append('file', file);
      formData.append('context', context.type);
      if (context.messageId) {
        formData.append('messageId', context.messageId);
      }
      
      // Upload with progress tracking
      const response = await uploadWithProgress(
        '/api/upload',
        formData,
        (progress) => {
          setUploads(prev => {
            const updated = new Map(prev);
            const upload = updated.get(uploadId);
            if (upload) {
              upload.progress = progress;
            }
            return updated;
          });
        }
      );
      
      const result = await response.json();
      
      // Poll for processing completion
      const processed = await pollProcessingStatus(result.uploadId);
      
      // Update status
      setUploads(prev => {
        const updated = new Map(prev);
        updated.delete(uploadId);
        return updated;
      });
      
      return processed;
      
    } catch (error) {
      setUploads(prev => {
        const updated = new Map(prev);
        const upload = updated.get(uploadId);
        if (upload) {
          upload.status = 'failed';
          upload.error = error.message;
        }
        return updated;
      });
      throw error;
    }
  }, []);
  
  return {
    uploadFile,
    uploads: Array.from(uploads.values()),
    cancelUpload: (id: string) => {
      // Implementation for cancel
    }
  };
}

// Drag and drop handler
export function useDropZone(onDrop: (files: File[]) => void) {
  const [isDragging, setIsDragging] = useState(false);
  
  const handlers = useMemo(() => ({
    onDragEnter: (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(true);
    },
    onDragLeave: (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);
    },
    onDragOver: (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
    },
    onDrop: (e: DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);
      
      const files = Array.from(e.dataTransfer?.files || []);
      if (files.length > 0) {
        onDrop(files);
      }
    }
  }), [onDrop]);
  
  return {
    isDragging,
    dropZoneProps: handlers
  };
}
```

### 6. Message Attachment UI
```tsx
// File attachment component
export function MessageAttachments({ 
  attachments 
}: { 
  attachments: Attachment[] 
}) {
  return (
    <div className="message-attachments">
      {attachments.map(attachment => (
        <AttachmentItem 
          key={attachment.id} 
          attachment={attachment} 
        />
      ))}
    </div>
  );
}

function AttachmentItem({ attachment }: { attachment: Attachment }) {
  const [signedUrl, setSignedUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Get signed URL
    getSignedUrl(attachment.key).then(url => {
      setSignedUrl(url);
      setLoading(false);
    });
  }, [attachment.key]);
  
  if (loading) {
    return <AttachmentSkeleton />;
  }
  
  if (attachment.type.startsWith('image/')) {
    return (
      <ImageAttachment 
        src={signedUrl}
        alt={attachment.filename}
        thumbnail={attachment.thumbnails?.medium}
        onClick={() => openLightbox(signedUrl)}
      />
    );
  }
  
  if (attachment.type.startsWith('video/')) {
    return (
      <VideoAttachment
        src={signedUrl}
        poster={attachment.thumbnail}
        controls
      />
    );
  }
  
  return (
    <FileAttachment
      href={signedUrl}
      filename={attachment.filename}
      size={attachment.size}
      icon={getFileIcon(attachment.type)}
    />
  );
}
```

### 7. Paste from Clipboard
```typescript
export function usePasteHandler(onPaste: (files: File[]) => void) {
  useEffect(() => {
    const handlePaste = async (e: ClipboardEvent) => {
      const items = Array.from(e.clipboardData?.items || []);
      const files: File[] = [];
      
      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            // Rename file with timestamp
            const renamed = new File(
              [file],
              `paste-${Date.now()}.${file.type.split('/')[1]}`,
              { type: file.type }
            );
            files.push(renamed);
          }
        }
      }
      
      if (files.length > 0) {
        e.preventDefault();
        onPaste(files);
      }
    };
    
    document.addEventListener('paste', handlePaste);
    return () => document.removeEventListener('paste', handlePaste);
  }, [onPaste]);
}
```

## Dependencies
- Authentication System (Issue #03) for secure uploads
- Message Flow (Issue #06) for attaching to messages
- Database Schema (Issue #05) for storing metadata

## Estimated Effort
**5 days**
- 1 day: R2 setup and upload endpoint
- 1 day: Media processing queue and thumbnails
- 1 day: Signed URL system and access control
- 1 day: Client upload UI and progress
- 1 day: Testing with various file types

## Notes
- Consider CDN integration for faster delivery
- Implement virus scanning with third-party API
- Add EXIF data stripping for privacy
- Plan storage quotas per waddle/user