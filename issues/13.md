# Issue #13: Voice Channel Data Model

## User Story
As a **platform architect**, I want to **design the voice channel data structure** so that **we can support scalable voice communication with proper state management**.

## Description
Design and implement the data model for voice channels, including channel types, participant state, and integration with RealTimeKit sessions. This foundation will support voice calls, screen sharing, and future video features.

## Acceptance Criteria
- [ ] Voice channels are distinct from text channels
- [ ] Support for different voice channel types (voice, stage, broadcast)
- [ ] Participant limits enforced (99 for voice, 1000 for stage)
- [ ] Voice state tracked per participant
- [ ] Integration points for RealTimeKit sessions
- [ ] Permission model for speaking/listening
- [ ] Voice channel categories and organization

## Technical Implementation

### 1. Voice Channel Schema
```sql
-- Update channels table (add to existing)
ALTER TABLE channels ADD COLUMN voice_config JSON;

-- Voice-specific configuration
-- voice_config JSON structure:
-- {
--   "bitrate": 64000,
--   "userLimit": 99,
--   "type": "voice" | "stage" | "broadcast",
--   "stageConfig": {
--     "requestToSpeakEnabled": true,
--     "moderatorLimit": 5
--   },
--   "recordingEnabled": false,
--   "rtkSessionConfig": {}
-- }

-- Voice sessions table
CREATE TABLE voice_sessions (
  id TEXT PRIMARY KEY,
  channel_id TEXT NOT NULL,
  rtk_session_id TEXT UNIQUE,
  started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  ended_at DATETIME,
  is_active BOOLEAN DEFAULT TRUE,
  host_user_id TEXT,
  participant_count INTEGER DEFAULT 0,
  peak_participant_count INTEGER DEFAULT 0,
  recording_url TEXT,
  metadata JSON,
  
  INDEX idx_active_sessions (channel_id, is_active),
  INDEX idx_rtk_session (rtk_session_id),
  FOREIGN KEY (channel_id) REFERENCES channels(id)
);

-- Voice participants table
CREATE TABLE voice_participants (
  session_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  left_at DATETIME,
  is_active BOOLEAN DEFAULT TRUE,
  is_speaking BOOLEAN DEFAULT FALSE,
  is_muted BOOLEAN DEFAULT FALSE,
  is_deafened BOOLEAN DEFAULT FALSE,
  is_video_enabled BOOLEAN DEFAULT FALSE,
  is_screen_sharing BOOLEAN DEFAULT FALSE,
  volume INTEGER DEFAULT 100,
  connection_quality TEXT, -- 'excellent', 'good', 'poor'
  metadata JSON, -- RTK-specific data
  
  PRIMARY KEY (session_id, user_id),
  INDEX idx_active_participants (session_id, is_active),
  FOREIGN KEY (session_id) REFERENCES voice_sessions(id)
);

-- Stage channel speakers queue
CREATE TABLE stage_requests (
  id TEXT PRIMARY KEY,
  channel_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  requested_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  approved_at DATETIME,
  approved_by TEXT,
  denied_at DATETIME,
  denied_by TEXT,
  status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'denied', 'expired'
  
  INDEX idx_pending_requests (channel_id, status, requested_at),
  FOREIGN KEY (channel_id) REFERENCES channels(id)
);
```

### 2. Voice Channel Types
```typescript
enum VoiceChannelType {
  VOICE = 'voice',      // Traditional voice channel
  STAGE = 'stage',      // Stage channel with speakers/audience
  BROADCAST = 'broadcast' // One-way broadcast
}

interface VoiceChannelConfig {
  type: VoiceChannelType;
  bitrate: number;        // 8000-384000 bps
  userLimit: number;      // 0 = unlimited (capped by type)
  region?: string;        // Auto-selected by RTK
  rtcConfig?: {
    echoCancellation: boolean;
    noiseSuppression: boolean;
    automaticGainControl: boolean;
  };
}

interface StageChannelConfig extends VoiceChannelConfig {
  type: VoiceChannelType.STAGE;
  requestToSpeakEnabled: boolean;
  moderatorLimit: number;
  audienceLimit: number;
  autoPromoteModerators: boolean;
}

interface BroadcastChannelConfig extends VoiceChannelConfig {
  type: VoiceChannelType.BROADCAST;
  broadcasterLimit: number;
  streamKey?: string;
  webhookUrl?: string;
}
```

### 3. Voice State Management
```javascript
export class VoiceStateManager {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.sessions = new Map(); // channelId -> VoiceSession
    this.participants = new Map(); // userId -> VoiceState
  }
  
  async createVoiceSession(channelId, hostUserId) {
    // Check if session already exists
    if (this.sessions.has(channelId)) {
      return this.sessions.get(channelId);
    }
    
    // Get channel configuration
    const channel = await this.getChannelConfig(channelId);
    if (!channel || channel.type !== 'voice') {
      throw new Error('Invalid voice channel');
    }
    
    // Create session
    const session = {
      id: crypto.randomUUID(),
      channelId,
      rtkSessionId: null, // Will be set when RTK session created
      startedAt: Date.now(),
      hostUserId,
      participants: new Map(),
      config: channel.voice_config,
      state: 'initializing'
    };
    
    // Store in database
    const db = this.getWaddleDb(channelId);
    await db.prepare(`
      INSERT INTO voice_sessions (
        id, channel_id, host_user_id, metadata
      ) VALUES (?, ?, ?, ?)
    `).bind(
      session.id,
      channelId,
      hostUserId,
      JSON.stringify(session.config)
    ).run();
    
    // Cache session
    this.sessions.set(channelId, session);
    
    // Initialize RTK session
    await this.initializeRTKSession(session);
    
    return session;
  }
  
  async joinVoiceChannel(channelId, userId, initialState = {}) {
    let session = this.sessions.get(channelId);
    
    // Create session if first participant
    if (!session) {
      session = await this.createVoiceSession(channelId, userId);
    }
    
    // Check user limit
    if (session.config.userLimit > 0 && 
        session.participants.size >= session.config.userLimit) {
      throw new Error('Voice channel is full');
    }
    
    // Check permissions
    const permissions = await this.checkVoicePermissions(userId, channelId);
    if (!permissions.canConnect) {
      throw new Error('No permission to connect');
    }
    
    // Create participant state
    const participantState = {
      userId,
      sessionId: session.id,
      joinedAt: Date.now(),
      isMuted: initialState.muted || false,
      isDeafened: initialState.deafened || false,
      isSelfMuted: initialState.muted || false,
      isSelfDeafened: initialState.deafened || false,
      isVideoEnabled: false,
      isScreenSharing: false,
      isSpeaking: false,
      volume: 100,
      permissions,
      connectionState: 'connecting'
    };
    
    // Store participant
    await this.storeParticipant(session.id, participantState);
    
    // Add to session
    session.participants.set(userId, participantState);
    this.participants.set(userId, participantState);
    
    // Generate RTK token
    const rtkToken = await this.generateRTKToken(session, userId, permissions);
    
    // Broadcast join event
    await this.broadcastVoiceStateUpdate(channelId, userId, 'joined');
    
    return {
      sessionId: session.id,
      rtkSessionId: session.rtkSessionId,
      token: rtkToken,
      participants: Array.from(session.participants.values())
    };
  }
  
  async updateVoiceState(channelId, userId, updates) {
    const session = this.sessions.get(channelId);
    if (!session) {
      throw new Error('No active voice session');
    }
    
    const participant = session.participants.get(userId);
    if (!participant) {
      throw new Error('User not in voice channel');
    }
    
    // Apply updates
    const allowedUpdates = [
      'isMuted', 'isDeafened', 'isSelfMuted', 'isSelfDeafened',
      'isVideoEnabled', 'isScreenSharing', 'volume'
    ];
    
    for (const [key, value] of Object.entries(updates)) {
      if (allowedUpdates.includes(key)) {
        participant[key] = value;
      }
    }
    
    // Update database
    await this.updateParticipantState(session.id, userId, participant);
    
    // Broadcast update
    await this.broadcastVoiceStateUpdate(channelId, userId, 'updated', updates);
    
    return participant;
  }
  
  async handleSpeakingUpdate(channelId, userId, isSpeaking) {
    const participant = this.participants.get(userId);
    if (!participant) return;
    
    participant.isSpeaking = isSpeaking;
    
    // Broadcast speaking indicator
    await this.broadcastVoiceStateUpdate(
      channelId, 
      userId, 
      'speaking', 
      { isSpeaking }
    );
  }
}
```

### 4. Stage Channel Management
```javascript
export class StageChannelManager extends VoiceStateManager {
  async requestToSpeak(channelId, userId) {
    const channel = await this.getChannelConfig(channelId);
    if (channel.type !== 'stage') {
      throw new Error('Not a stage channel');
    }
    
    // Check if already has request
    const existingRequest = await this.getPendingRequest(channelId, userId);
    if (existingRequest) {
      return existingRequest;
    }
    
    // Create request
    const request = {
      id: crypto.randomUUID(),
      channelId,
      userId,
      requestedAt: Date.now(),
      status: 'pending'
    };
    
    // Store request
    const db = this.getWaddleDb(channelId);
    await db.prepare(`
      INSERT INTO stage_requests (id, channel_id, user_id)
      VALUES (?, ?, ?)
    `).bind(request.id, channelId, userId).run();
    
    // Notify moderators
    await this.notifyModerators(channelId, request);
    
    return request;
  }
  
  async approveSpeaker(channelId, requestId, moderatorId) {
    const db = this.getWaddleDb(channelId);
    
    // Update request
    const request = await db.prepare(`
      UPDATE stage_requests
      SET status = 'approved',
          approved_at = CURRENT_TIMESTAMP,
          approved_by = ?
      WHERE id = ? AND status = 'pending'
      RETURNING user_id
    `).bind(moderatorId, requestId).first();
    
    if (!request) {
      throw new Error('Request not found or already processed');
    }
    
    // Update participant to speaker
    await this.promoteToSpeaker(channelId, request.user_id);
    
    // Notify user
    await this.notifyUser(request.user_id, 'speaker_approved', { channelId });
    
    return { success: true };
  }
  
  async promoteToSpeaker(channelId, userId) {
    const session = this.sessions.get(channelId);
    if (!session) {
      throw new Error('No active stage session');
    }
    
    const participant = session.participants.get(userId);
    if (!participant) {
      throw new Error('User not in stage channel');
    }
    
    // Update permissions
    participant.permissions.canSpeak = true;
    participant.permissions.isSpeaker = true;
    
    // Update RTK permissions
    await this.updateRTKPermissions(session.rtkSessionId, userId, {
      canPublish: true,
      canSubscribe: true
    });
    
    // Broadcast role change
    await this.broadcastVoiceStateUpdate(
      channelId,
      userId,
      'role_changed',
      { role: 'speaker' }
    );
  }
  
  async demoteToAudience(channelId, userId, moderatorId) {
    const session = this.sessions.get(channelId);
    if (!session) {
      throw new Error('No active stage session');
    }
    
    const participant = session.participants.get(userId);
    if (!participant) {
      throw new Error('User not in stage channel');
    }
    
    // Update permissions
    participant.permissions.canSpeak = false;
    participant.permissions.isSpeaker = false;
    participant.isMuted = true;
    
    // Update RTK permissions
    await this.updateRTKPermissions(session.rtkSessionId, userId, {
      canPublish: false,
      canSubscribe: true
    });
    
    // Broadcast role change
    await this.broadcastVoiceStateUpdate(
      channelId,
      userId,
      'role_changed',
      { role: 'audience' }
    );
  }
}
```

### 5. Voice Permissions
```javascript
export class VoicePermissions {
  static readonly FLAGS = {
    CONNECT: 1 << 0,
    SPEAK: 1 << 1,
    MUTE_MEMBERS: 1 << 2,
    DEAFEN_MEMBERS: 1 << 3,
    MOVE_MEMBERS: 1 << 4,
    USE_VAD: 1 << 5, // Voice Activity Detection
    PRIORITY_SPEAKER: 1 << 6,
    STREAM: 1 << 7,
    USE_VIDEO: 1 << 8,
    REQUEST_TO_SPEAK: 1 << 9,
    MANAGE_STAGE: 1 << 10
  };
  
  static async getVoicePermissions(userId, channelId, env) {
    // Get user's roles in waddle
    const roles = await this.getUserRoles(userId, channelId, env);
    
    // Calculate permissions
    let permissions = 0;
    for (const role of roles) {
      permissions |= role.permissions;
    }
    
    // Check channel-specific overrides
    const overrides = await this.getChannelOverrides(userId, channelId, env);
    permissions = this.applyOverrides(permissions, overrides);
    
    return {
      canConnect: this.hasPermission(permissions, this.FLAGS.CONNECT),
      canSpeak: this.hasPermission(permissions, this.FLAGS.SPEAK),
      canMuteMembers: this.hasPermission(permissions, this.FLAGS.MUTE_MEMBERS),
      canDeafenMembers: this.hasPermission(permissions, this.FLAGS.DEAFEN_MEMBERS),
      canMoveMembers: this.hasPermission(permissions, this.FLAGS.MOVE_MEMBERS),
      canUseVAD: this.hasPermission(permissions, this.FLAGS.USE_VAD),
      isPrioritySpeaker: this.hasPermission(permissions, this.FLAGS.PRIORITY_SPEAKER),
      canStream: this.hasPermission(permissions, this.FLAGS.STREAM),
      canUseVideo: this.hasPermission(permissions, this.FLAGS.USE_VIDEO),
      canRequestToSpeak: this.hasPermission(permissions, this.FLAGS.REQUEST_TO_SPEAK),
      canManageStage: this.hasPermission(permissions, this.FLAGS.MANAGE_STAGE)
    };
  }
  
  static hasPermission(permissions, flag) {
    return (permissions & flag) === flag;
  }
}
```

### 6. Voice Channel Categories
```javascript
export class VoiceChannelOrganizer {
  static async createVoiceCategory(waddleId, name, position, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    const category = {
      id: crypto.randomUUID(),
      name,
      position,
      collapsedByDefault: false
    };
    
    await db.prepare(`
      INSERT INTO categories (id, name, position, collapsed_by_default)
      VALUES (?, ?, ?, ?)
    `).bind(category.id, name, position, false).run();
    
    return category;
  }
  
  static async organizeVoiceChannels(waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Get all voice channels
    const channels = await db.prepare(`
      SELECT 
        c.*,
        cat.name as category_name,
        COUNT(vp.user_id) as active_users
      FROM channels c
      LEFT JOIN categories cat ON c.category_id = cat.id
      LEFT JOIN voice_sessions vs ON c.id = vs.channel_id AND vs.is_active = true
      LEFT JOIN voice_participants vp ON vs.id = vp.session_id AND vp.is_active = true
      WHERE c.type IN ('voice', 'stage', 'broadcast')
      GROUP BY c.id
      ORDER BY cat.position, c.position
    `).all();
    
    return this.groupByCategory(channels.results);
  }
  
  static groupByCategory(channels) {
    const grouped = {
      uncategorized: []
    };
    
    for (const channel of channels) {
      const category = channel.category_name || 'uncategorized';
      if (!grouped[category]) {
        grouped[category] = [];
      }
      grouped[category].push(channel);
    }
    
    return grouped;
  }
}
```

### 7. Voice Analytics
```javascript
export class VoiceAnalytics {
  static async trackVoiceSession(session, env) {
    const db = env.ANALYTICS_DB;
    
    const duration = session.endedAt - session.startedAt;
    const avgParticipants = session.totalParticipantTime / duration;
    
    await db.prepare(`
      INSERT INTO voice_analytics (
        session_id,
        channel_id,
        duration_seconds,
        peak_participants,
        avg_participants,
        total_speaker_time,
        date
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      session.id,
      session.channelId,
      Math.floor(duration / 1000),
      session.peakParticipants,
      Math.floor(avgParticipants),
      session.totalSpeakerTime,
      new Date().toISOString().split('T')[0]
    ).run();
  }
  
  static async getChannelStats(channelId, days = 30, env) {
    const stats = await env.ANALYTICS_DB.prepare(`
      SELECT 
        COUNT(*) as total_sessions,
        SUM(duration_seconds) as total_duration,
        AVG(duration_seconds) as avg_duration,
        MAX(peak_participants) as max_participants,
        AVG(avg_participants) as avg_participants
      FROM voice_analytics
      WHERE channel_id = ?
        AND date > date('now', '-' || ? || ' days')
    `).bind(channelId, days).first();
    
    return stats;
  }
}
```

## Dependencies
- Database Schema (Issue #05) for base tables
- RealTimeKit Setup (Issue #02) for voice infrastructure
- Permission System (Issue #23) for access control

## Estimated Effort
**4 days**
- 1 day: Database schema and models
- 1 day: Voice state management
- 1 day: Stage channel features
- 1 day: Permissions and analytics

## Notes
- Consider voice region selection for optimal latency
- Plan for voice channel templates
- Add support for voice channel events/activities
- Monitor RealTimeKit session limits