# Issue #59: Analytics Dashboard

## User Story
As a **waddle owner**, I want to **view comprehensive analytics about my community's usage** so that **I can understand member engagement and make data-driven decisions**.

## Description
Build a comprehensive analytics dashboard that provides insights into waddle usage patterns, member engagement, content popularity, and growth trends. The dashboard should offer real-time metrics, historical data, and predictive analytics to help waddle owners optimize their communities.

## Acceptance Criteria
- [ ] Real-time usage metrics and statistics
- [ ] Member engagement analytics
- [ ] Content performance tracking
- [ ] Voice/video usage insights
- [ ] Growth trend visualization
- [ ] Custom date range selection
- [ ] Export functionality for reports
- [ ] Predictive analytics and insights

## Technical Implementation

### 1. Analytics Data Pipeline
```typescript
// Analytics data collection and processing
export class AnalyticsPipeline {
  private collectors: Map<string, DataCollector> = new Map();
  private processors: Map<string, DataProcessor> = new Map();
  private storage: AnalyticsStorage;
  
  constructor(
    private env: Env,
    private queue: Queue<AnalyticsEvent>
  ) {
    this.storage = new AnalyticsStorage(env);
    this.initializeCollectors();
    this.initializeProcessors();
  }
  
  async collectEvent(event: AnalyticsEvent): Promise<void> {
    // Validate and enrich event
    const enrichedEvent = await this.enrichEvent(event);
    
    // Send to processing queue
    await this.queue.send(enrichedEvent);
    
    // Real-time processing for critical metrics
    if (this.isRealTimeMetric(event.type)) {
      await this.processRealTime(enrichedEvent);
    }
  }
  
  private async enrichEvent(event: AnalyticsEvent): Promise<EnrichedEvent> {
    return {
      ...event,
      timestamp: Date.now(),
      sessionId: event.sessionId || this.generateSessionId(),
      metadata: {
        ...event.metadata,
        userAgent: event.userAgent,
        ip: event.ip,
        geo: await this.getGeoData(event.ip),
        device: this.parseDevice(event.userAgent)
      }
    };
  }
  
  async processBatch(events: AnalyticsEvent[]): Promise<void> {
    // Group events by type for efficient processing
    const eventGroups = this.groupEventsByType(events);
    
    for (const [eventType, groupedEvents] of eventGroups) {
      const processor = this.processors.get(eventType);
      if (processor) {
        const processed = await processor.process(groupedEvents);
        await this.storage.store(eventType, processed);
      }
    }
    
    // Update aggregated metrics
    await this.updateAggregates(events);
  }
  
  private async updateAggregates(events: AnalyticsEvent[]): Promise<void> {
    const aggregates = new Map<string, AggregateMetric>();
    
    for (const event of events) {
      // Update hourly aggregates
      const hourKey = this.getHourKey(event.timestamp);
      const hourAggregate = aggregates.get(hourKey) || new AggregateMetric(hourKey);
      hourAggregate.addEvent(event);
      aggregates.set(hourKey, hourAggregate);
      
      // Update daily aggregates
      const dayKey = this.getDayKey(event.timestamp);
      const dayAggregate = aggregates.get(dayKey) || new AggregateMetric(dayKey);
      dayAggregate.addEvent(event);
      aggregates.set(dayKey, dayAggregate);
    }
    
    // Store aggregates
    for (const [key, aggregate] of aggregates) {
      await this.storage.updateAggregate(key, aggregate);
    }
  }
}

// Event collectors for different metrics
export class MessageCollector implements DataCollector {
  async collect(waddle: Waddle, channel: Channel): Promise<MessageMetrics> {
    const messages = await this.getMessages(waddle.id, channel.id);
    
    return {
      totalMessages: messages.length,
      uniqueAuthors: new Set(messages.map(m => m.authorId)).size,
      messageTypes: this.categorizeMessages(messages),
      peakHours: this.analyzePeakHours(messages),
      averageLength: this.calculateAverageLength(messages),
      engagement: {
        reactions: messages.reduce((sum, m) => sum + m.reactions.length, 0),
        replies: messages.filter(m => m.replyTo).length,
        mentions: this.countMentions(messages)
      }
    };
  }
  
  private categorizeMessages(messages: Message[]): MessageTypeBreakdown {
    const types = {
      text: 0,
      media: 0,
      links: 0,
      code: 0,
      other: 0
    };
    
    for (const message of messages) {
      if (message.attachments.length > 0) {
        types.media++;
      } else if (this.containsCode(message.content)) {
        types.code++;
      } else if (this.containsLinks(message.content)) {
        types.links++;
      } else {
        types.text++;
      }
    }
    
    return types;
  }
}

export class VoiceAnalytics implements DataCollector {
  async collect(waddle: Waddle): Promise<VoiceMetrics> {
    const sessions = await this.getVoiceSessions(waddle.id);
    
    return {
      totalSessions: sessions.length,
      totalDuration: sessions.reduce((sum, s) => sum + s.duration, 0),
      averageDuration: this.calculateAverageDuration(sessions),
      peakConcurrentUsers: this.calculatePeakConcurrency(sessions),
      userParticipation: this.analyzeParticipation(sessions),
      quality: {
        averageBitrate: this.calculateAverageBitrate(sessions),
        packetLoss: this.calculatePacketLoss(sessions),
        jitter: this.calculateJitter(sessions)
      },
      patterns: {
        byHour: this.groupByHour(sessions),
        byDayOfWeek: this.groupByDayOfWeek(sessions),
        byChannel: this.groupByChannel(sessions)
      }
    };
  }
  
  private calculatePeakConcurrency(sessions: VoiceSession[]): number {
    const timeline: Array<{ time: number; delta: number }> = [];
    
    for (const session of sessions) {
      timeline.push({ time: session.startTime, delta: 1 });
      timeline.push({ time: session.endTime, delta: -1 });
    }
    
    timeline.sort((a, b) => a.time - b.time);
    
    let current = 0;
    let peak = 0;
    
    for (const event of timeline) {
      current += event.delta;
      peak = Math.max(peak, current);
    }
    
    return peak;
  }
}
```

### 2. Real-time Analytics Engine
```typescript
// Real-time analytics processing
export class RealTimeAnalytics {
  private metrics: Map<string, RealTimeMetric> = new Map();
  private subscribers: Map<string, Set<(data: any) => void>> = new Map();
  
  constructor(
    private env: Env,
    private websocket: WebSocketService
  ) {
    this.initializeMetrics();
  }
  
  private initializeMetrics() {
    // Active users
    this.metrics.set('activeUsers', new ActiveUsersMetric());
    
    // Message rate
    this.metrics.set('messageRate', new MessageRateMetric());
    
    // Voice activity
    this.metrics.set('voiceActivity', new VoiceActivityMetric());
    
    // System health
    this.metrics.set('systemHealth', new SystemHealthMetric());
  }
  
  async updateMetric(metricName: string, data: any): Promise<void> {
    const metric = this.metrics.get(metricName);
    if (!metric) return;
    
    // Update metric
    const updated = await metric.update(data);
    
    // Notify subscribers
    const subscribers = this.subscribers.get(metricName) || new Set();
    for (const callback of subscribers) {
      callback(updated);
    }
    
    // Broadcast to connected clients
    await this.broadcastUpdate(metricName, updated);
  }
  
  async getDashboardData(waddleId: string): Promise<RealTimeDashboard> {
    const activeUsers = await this.getActiveUsers(waddleId);
    const messageRate = await this.getMessageRate(waddleId);
    const voiceChannels = await this.getActiveVoiceChannels(waddleId);
    
    return {
      timestamp: Date.now(),
      activeUsers: {
        count: activeUsers.size,
        trend: this.calculateTrend('activeUsers', activeUsers.size),
        breakdown: {
          desktop: this.countByDevice(activeUsers, 'desktop'),
          mobile: this.countByDevice(activeUsers, 'mobile'),
          web: this.countByDevice(activeUsers, 'web')
        }
      },
      messageRate: {
        current: messageRate,
        average: await this.getAverageMessageRate(waddleId),
        peak: await this.getPeakMessageRate(waddleId)
      },
      voiceActivity: {
        activeChannels: voiceChannels.length,
        totalParticipants: voiceChannels.reduce((sum, ch) => sum + ch.participants, 0),
        channels: voiceChannels
      },
      systemStatus: await this.getSystemStatus()
    };
  }
  
  private calculateTrend(metric: string, currentValue: number): Trend {
    const history = this.getMetricHistory(metric, 60); // Last 60 seconds
    
    if (history.length < 2) {
      return { direction: 'stable', percentage: 0 };
    }
    
    const previousValue = history[history.length - 2].value;
    const change = currentValue - previousValue;
    const percentage = (change / previousValue) * 100;
    
    return {
      direction: change > 0 ? 'up' : change < 0 ? 'down' : 'stable',
      percentage: Math.abs(percentage)
    };
  }
}

// Real-time metric implementations
export class ActiveUsersMetric implements RealTimeMetric {
  private users: Map<string, UserActivity> = new Map();
  private windowSize = 5 * 60 * 1000; // 5 minutes
  
  async update(event: UserEvent): Promise<ActiveUsersData> {
    const now = Date.now();
    
    // Update user activity
    this.users.set(event.userId, {
      lastActivity: now,
      device: event.device,
      location: event.location,
      actions: [...(this.users.get(event.userId)?.actions || []), event.action]
    });
    
    // Clean up inactive users
    for (const [userId, activity] of this.users) {
      if (now - activity.lastActivity > this.windowSize) {
        this.users.delete(userId);
      }
    }
    
    return {
      count: this.users.size,
      users: Array.from(this.users.entries()).map(([id, activity]) => ({
        id,
        ...activity
      }))
    };
  }
}
```

### 3. Analytics Dashboard UI
```typescript
// Main analytics dashboard component
export function AnalyticsDashboard({ waddleId }: { waddleId: string }) {
  const [timeRange, setTimeRange] = useState<TimeRange>({ 
    start: Date.now() - 7 * 24 * 60 * 60 * 1000, // 7 days
    end: Date.now() 
  });
  const [activeTab, setActiveTab] = useState('overview');
  const [realTimeData, setRealTimeData] = useState<RealTimeDashboard>();
  const [historicalData, setHistoricalData] = useState<HistoricalAnalytics>();
  
  useEffect(() => {
    loadAnalytics();
    const ws = connectToRealTimeUpdates();
    
    return () => ws.close();
  }, [waddleId, timeRange]);
  
  const connectToRealTimeUpdates = () => {
    const ws = new WebSocket(`wss://api.waddle.chat/analytics/realtime/${waddleId}`);
    
    ws.onmessage = (event) => {
      const update = JSON.parse(event.data);
      setRealTimeData(prev => ({ ...prev, ...update }));
    };
    
    return ws;
  };
  
  const loadAnalytics = async () => {
    const [realTime, historical] = await Promise.all([
      api.getRealTimeAnalytics(waddleId),
      api.getHistoricalAnalytics(waddleId, timeRange)
    ]);
    
    setRealTimeData(realTime);
    setHistoricalData(historical);
  };
  
  return (
    <div className="analytics-dashboard">
      <div className="dashboard-header">
        <h1>Analytics Dashboard</h1>
        <div className="header-controls">
          <DateRangePicker
            value={timeRange}
            onChange={setTimeRange}
            presets={[
              { label: '24 Hours', value: { hours: 24 } },
              { label: '7 Days', value: { days: 7 } },
              { label: '30 Days', value: { days: 30 } },
              { label: '90 Days', value: { days: 90 } }
            ]}
          />
          <Button
            variant="secondary"
            startIcon={<DownloadIcon />}
            onClick={() => exportAnalytics(waddleId, timeRange)}
          >
            Export Report
          </Button>
        </div>
      </div>
      
      {realTimeData && (
        <div className="real-time-metrics">
          <MetricCard
            title="Active Now"
            value={realTimeData.activeUsers.count}
            trend={realTimeData.activeUsers.trend}
            sparkline={realTimeData.activeUsers.history}
            icon={<UsersIcon />}
          />
          
          <MetricCard
            title="Messages/min"
            value={realTimeData.messageRate.current}
            subtitle={`Avg: ${realTimeData.messageRate.average}`}
            trend={realTimeData.messageRate.trend}
            icon={<MessageIcon />}
          />
          
          <MetricCard
            title="Voice Channels"
            value={realTimeData.voiceActivity.activeChannels}
            subtitle={`${realTimeData.voiceActivity.totalParticipants} participants`}
            icon={<MicIcon />}
          />
          
          <MetricCard
            title="System Health"
            value={`${realTimeData.systemStatus.health}%`}
            status={realTimeData.systemStatus.status}
            icon={<ActivityIcon />}
          />
        </div>
      )}
      
      <Tabs value={activeTab} onChange={setActiveTab}>
        <Tab value="overview">Overview</Tab>
        <Tab value="engagement">Engagement</Tab>
        <Tab value="content">Content</Tab>
        <Tab value="voice">Voice & Video</Tab>
        <Tab value="growth">Growth</Tab>
        <Tab value="insights">Insights</Tab>
      </Tabs>
      
      {historicalData && (
        <div className="dashboard-content">
          {activeTab === 'overview' && (
            <OverviewTab data={historicalData} timeRange={timeRange} />
          )}
          
          {activeTab === 'engagement' && (
            <EngagementTab data={historicalData.engagement} />
          )}
          
          {activeTab === 'content' && (
            <ContentTab data={historicalData.content} />
          )}
          
          {activeTab === 'voice' && (
            <VoiceTab data={historicalData.voice} />
          )}
          
          {activeTab === 'growth' && (
            <GrowthTab data={historicalData.growth} />
          )}
          
          {activeTab === 'insights' && (
            <InsightsTab data={historicalData} />
          )}
        </div>
      )}
    </div>
  );
}

// Engagement analytics tab
function EngagementTab({ data }: { data: EngagementAnalytics }) {
  return (
    <div className="engagement-analytics">
      <div className="metrics-grid">
        <EngagementMetric
          title="Daily Active Users"
          value={data.dau}
          change={data.dauChange}
          chart={<MiniChart data={data.dauHistory} />}
        />
        
        <EngagementMetric
          title="Weekly Active Users"
          value={data.wau}
          change={data.wauChange}
          chart={<MiniChart data={data.wauHistory} />}
        />
        
        <EngagementMetric
          title="Monthly Active Users"
          value={data.mau}
          change={data.mauChange}
          chart={<MiniChart data={data.mauHistory} />}
        />
        
        <EngagementMetric
          title="Avg Session Duration"
          value={formatDuration(data.avgSessionDuration)}
          change={data.sessionDurationChange}
          chart={<MiniChart data={data.sessionDurationHistory} />}
        />
      </div>
      
      <div className="engagement-charts">
        <ChartCard title="User Activity Heatmap">
          <ActivityHeatmap data={data.activityHeatmap} />
        </ChartCard>
        
        <ChartCard title="Retention Cohorts">
          <RetentionChart data={data.retentionCohorts} />
        </ChartCard>
        
        <ChartCard title="User Journey Funnel">
          <FunnelChart
            data={data.userJourney}
            steps={['Visit', 'Join', 'Message', 'Voice', 'Return']}
          />
        </ChartCard>
        
        <ChartCard title="Engagement Score Distribution">
          <DistributionChart data={data.engagementScores} />
        </ChartCard>
      </div>
      
      <div className="top-users">
        <h3>Most Engaged Users</h3>
        <UsersList
          users={data.topUsers}
          columns={[
            { key: 'name', label: 'User' },
            { key: 'messages', label: 'Messages' },
            { key: 'voiceTime', label: 'Voice Time' },
            { key: 'reactions', label: 'Reactions' },
            { key: 'score', label: 'Engagement Score' }
          ]}
        />
      </div>
    </div>
  );
}

// Content analytics tab
function ContentTab({ data }: { data: ContentAnalytics }) {
  const [selectedChannel, setSelectedChannel] = useState<string>('all');
  
  return (
    <div className="content-analytics">
      <div className="content-overview">
        <StatCard
          title="Total Messages"
          value={data.totalMessages}
          change={data.messageGrowth}
        />
        
        <StatCard
          title="Media Shared"
          value={data.totalMedia}
          subtitle={formatBytes(data.mediaSize)}
        />
        
        <StatCard
          title="Links Shared"
          value={data.totalLinks}
          subtitle={`${data.uniqueDomains} domains`}
        />
        
        <StatCard
          title="Avg Response Time"
          value={formatDuration(data.avgResponseTime)}
          change={data.responseTimeChange}
        />
      </div>
      
      <div className="channel-selector">
        <Select
          value={selectedChannel}
          onChange={setSelectedChannel}
          options={[
            { value: 'all', label: 'All Channels' },
            ...data.channels.map(ch => ({
              value: ch.id,
              label: ch.name
            }))
          ]}
        />
      </div>
      
      <div className="content-charts">
        <ChartCard title="Message Volume">
          <TimeSeriesChart
            data={data.messageVolume}
            series={[
              { key: 'messages', name: 'Messages', color: '#3b82f6' },
              { key: 'media', name: 'Media', color: '#10b981' },
              { key: 'links', name: 'Links', color: '#f59e0b' }
            ]}
          />
        </ChartCard>
        
        <ChartCard title="Content Types">
          <PieChart
            data={[
              { name: 'Text', value: data.contentTypes.text },
              { name: 'Images', value: data.contentTypes.images },
              { name: 'Videos', value: data.contentTypes.videos },
              { name: 'Files', value: data.contentTypes.files },
              { name: 'Code', value: data.contentTypes.code }
            ]}
          />
        </ChartCard>
        
        <ChartCard title="Popular Topics">
          <WordCloud
            words={data.topicAnalysis.topics}
            maxSize={60}
            minSize={12}
          />
        </ChartCard>
        
        <ChartCard title="Sentiment Analysis">
          <SentimentChart
            data={data.sentimentAnalysis}
            categories={['Positive', 'Neutral', 'Negative']}
          />
        </ChartCard>
      </div>
      
      <div className="content-tables">
        <TableCard title="Most Active Channels">
          <DataTable
            data={data.channelActivity}
            columns={[
              { key: 'name', label: 'Channel' },
              { key: 'messages', label: 'Messages', sortable: true },
              { key: 'participants', label: 'Participants', sortable: true },
              { key: 'avgResponseTime', label: 'Avg Response', format: formatDuration }
            ]}
          />
        </TableCard>
        
        <TableCard title="Popular Messages">
          <MessageList
            messages={data.popularMessages}
            showReactions
            showReplies
          />
        </TableCard>
      </div>
    </div>
  );
}
```

### 4. Advanced Analytics Features
```typescript
// Predictive analytics engine
export class PredictiveAnalytics {
  private models: Map<string, PredictionModel> = new Map();
  
  constructor(
    private historicalData: HistoricalDataService,
    private mlService: MachineLearningService
  ) {
    this.initializeModels();
  }
  
  private initializeModels() {
    // User churn prediction
    this.models.set('churn', new ChurnPredictionModel());
    
    // Growth forecasting
    this.models.set('growth', new GrowthForecastModel());
    
    // Activity prediction
    this.models.set('activity', new ActivityPredictionModel());
    
    // Content trend prediction
    this.models.set('trends', new TrendPredictionModel());
  }
  
  async generateInsights(waddleId: string): Promise<AnalyticsInsights> {
    const insights: AnalyticsInsights = {
      predictions: [],
      recommendations: [],
      risks: [],
      opportunities: []
    };
    
    // Churn risk analysis
    const churnRisk = await this.analyzeChurnRisk(waddleId);
    if (churnRisk.highRiskUsers.length > 0) {
      insights.risks.push({
        type: 'churn',
        severity: 'high',
        message: `${churnRisk.highRiskUsers.length} users at high risk of churning`,
        affectedUsers: churnRisk.highRiskUsers,
        recommendation: 'Engage with personalized content or direct outreach'
      });
    }
    
    // Growth forecast
    const growthForecast = await this.forecastGrowth(waddleId);
    insights.predictions.push({
      type: 'growth',
      metric: 'Monthly Active Users',
      current: growthForecast.currentMAU,
      predicted: growthForecast.predictedMAU,
      confidence: growthForecast.confidence,
      timeframe: '30 days'
    });
    
    // Activity patterns
    const activityInsights = await this.analyzeActivityPatterns(waddleId);
    if (activityInsights.unusualPatterns.length > 0) {
      for (const pattern of activityInsights.unusualPatterns) {
        insights.opportunities.push({
          type: 'engagement',
          description: pattern.description,
          impact: pattern.impact,
          suggestion: pattern.suggestion
        });
      }
    }
    
    // Content recommendations
    const contentInsights = await this.analyzeContent(waddleId);
    insights.recommendations.push(...contentInsights.recommendations);
    
    return insights;
  }
  
  private async analyzeChurnRisk(waddleId: string): Promise<ChurnAnalysis> {
    const users = await this.historicalData.getUsers(waddleId);
    const riskScores: Array<{ userId: string; score: number }> = [];
    
    for (const user of users) {
      const features = await this.extractUserFeatures(user);
      const score = await this.models.get('churn')!.predict(features);
      riskScores.push({ userId: user.id, score });
    }
    
    return {
      highRiskUsers: riskScores
        .filter(r => r.score > 0.7)
        .map(r => r.userId),
      averageRisk: riskScores.reduce((sum, r) => sum + r.score, 0) / riskScores.length,
      riskFactors: await this.identifyRiskFactors(riskScores)
    };
  }
  
  private async extractUserFeatures(user: User): Promise<UserFeatures> {
    const activity = await this.historicalData.getUserActivity(user.id);
    
    return {
      daysSinceLastActive: this.daysSince(activity.lastActive),
      messageFrequency: activity.messageCount / activity.daysActive,
      voiceParticipation: activity.voiceMinutes / activity.daysActive,
      reactionGiven: activity.reactionsGiven,
      reactionReceived: activity.reactionsReceived,
      channelDiversity: activity.uniqueChannels / activity.totalChannels,
      sessionFrequency: activity.sessions / activity.daysActive,
      avgSessionDuration: activity.totalSessionTime / activity.sessions
    };
  }
}

// Insights visualization component
function InsightsTab({ data }: { data: HistoricalAnalytics }) {
  const [insights, setInsights] = useState<AnalyticsInsights>();
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadInsights();
  }, [data]);
  
  const loadInsights = async () => {
    setLoading(true);
    try {
      const insightsData = await api.getAnalyticsInsights(data.waddleId);
      setInsights(insightsData);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading) return <LoadingSpinner />;
  if (!insights) return null;
  
  return (
    <div className="insights-tab">
      <div className="insights-header">
        <h2>AI-Powered Insights</h2>
        <p>Predictive analytics and recommendations based on your community data</p>
      </div>
      
      {insights.risks.length > 0 && (
        <div className="risk-alerts">
          <h3>Risk Alerts</h3>
          {insights.risks.map((risk, index) => (
            <Alert
              key={index}
              severity={risk.severity}
              action={
                <Button size="small" onClick={() => handleRisk(risk)}>
                  Take Action
                </Button>
              }
            >
              <AlertTitle>{risk.message}</AlertTitle>
              {risk.recommendation}
            </Alert>
          ))}
        </div>
      )}
      
      <div className="predictions-grid">
        {insights.predictions.map((prediction, index) => (
          <PredictionCard
            key={index}
            title={prediction.metric}
            current={prediction.current}
            predicted={prediction.predicted}
            confidence={prediction.confidence}
            timeframe={prediction.timeframe}
          />
        ))}
      </div>
      
      <div className="opportunities">
        <h3>Growth Opportunities</h3>
        <div className="opportunity-cards">
          {insights.opportunities.map((opportunity, index) => (
            <OpportunityCard
              key={index}
              type={opportunity.type}
              description={opportunity.description}
              impact={opportunity.impact}
              suggestion={opportunity.suggestion}
            />
          ))}
        </div>
      </div>
      
      <div className="recommendations">
        <h3>Recommendations</h3>
        <RecommendationList
          recommendations={insights.recommendations}
          onImplement={handleRecommendation}
        />
      </div>
      
      <div className="comparative-analysis">
        <h3>Comparative Analysis</h3>
        <BenchmarkChart
          yourMetrics={data.metrics}
          industryBenchmarks={insights.benchmarks}
        />
      </div>
    </div>
  );
}
```

### 5. Export and Reporting
```typescript
// Analytics export functionality
export class AnalyticsExporter {
  constructor(
    private analytics: AnalyticsService,
    private storage: StorageService
  ) {}
  
  async exportReport(
    waddleId: string,
    timeRange: TimeRange,
    format: 'pdf' | 'csv' | 'json'
  ): Promise<string> {
    // Gather all analytics data
    const data = await this.gatherAnalyticsData(waddleId, timeRange);
    
    // Generate report based on format
    let report: Buffer;
    let contentType: string;
    let filename: string;
    
    switch (format) {
      case 'pdf':
        report = await this.generatePDFReport(data);
        contentType = 'application/pdf';
        filename = `analytics-${waddleId}-${Date.now()}.pdf`;
        break;
        
      case 'csv':
        report = await this.generateCSVReport(data);
        contentType = 'text/csv';
        filename = `analytics-${waddleId}-${Date.now()}.csv`;
        break;
        
      case 'json':
        report = Buffer.from(JSON.stringify(data, null, 2));
        contentType = 'application/json';
        filename = `analytics-${waddleId}-${Date.now()}.json`;
        break;
    }
    
    // Store report
    const url = await this.storage.uploadFile(filename, report, contentType);
    
    // Track export
    await this.analytics.track('analytics_exported', {
      waddleId,
      format,
      timeRange,
      fileSize: report.length
    });
    
    return url;
  }
  
  private async generatePDFReport(data: AnalyticsData): Promise<Buffer> {
    const pdf = new PDFGenerator();
    
    // Cover page
    pdf.addPage({
      title: 'Analytics Report',
      subtitle: `${data.waddleName} - ${data.timeRange.label}`,
      logo: data.waddleLogo
    });
    
    // Executive summary
    pdf.addSection({
      title: 'Executive Summary',
      content: this.generateExecutiveSummary(data)
    });
    
    // Key metrics
    pdf.addSection({
      title: 'Key Metrics',
      charts: [
        this.generateMetricsChart(data.metrics),
        this.generateGrowthChart(data.growth),
        this.generateEngagementChart(data.engagement)
      ]
    });
    
    // Detailed analysis sections
    const sections = [
      { title: 'User Engagement', data: data.engagement },
      { title: 'Content Analysis', data: data.content },
      { title: 'Voice & Video Usage', data: data.voice },
      { title: 'Growth Trends', data: data.growth }
    ];
    
    for (const section of sections) {
      pdf.addSection({
        title: section.title,
        content: this.generateSectionContent(section.data),
        charts: this.generateSectionCharts(section.data)
      });
    }
    
    // Insights and recommendations
    if (data.insights) {
      pdf.addSection({
        title: 'Insights & Recommendations',
        content: this.formatInsights(data.insights)
      });
    }
    
    return pdf.generate();
  }
  
  private generateExecutiveSummary(data: AnalyticsData): string {
    const summary = [];
    
    summary.push(`During the ${data.timeRange.label.toLowerCase()}, your community showed:`);
    summary.push('');
    
    // Growth summary
    const userGrowth = ((data.metrics.endUsers - data.metrics.startUsers) / data.metrics.startUsers) * 100;
    summary.push(`• ${userGrowth.toFixed(1)}% user growth (${data.metrics.endUsers} total users)`);
    
    // Engagement summary
    summary.push(`• ${data.engagement.avgDailyActive} average daily active users`);
    summary.push(`• ${formatDuration(data.engagement.avgSessionDuration)} average session duration`);
    
    // Activity summary
    summary.push(`• ${data.content.totalMessages.toLocaleString()} messages sent`);
    summary.push(`• ${formatDuration(data.voice.totalDuration)} spent in voice channels`);
    
    return summary.join('\n');
  }
}

// Export button component
function ExportButton({ waddleId, timeRange }: ExportButtonProps) {
  const [exporting, setExporting] = useState(false);
  const [showMenu, setShowMenu] = useState(false);
  
  const handleExport = async (format: 'pdf' | 'csv' | 'json') => {
    setExporting(true);
    setShowMenu(false);
    
    try {
      const url = await api.exportAnalytics(waddleId, timeRange, format);
      
      // Download file
      const link = document.createElement('a');
      link.href = url;
      link.download = `analytics-report.${format}`;
      link.click();
      
      toast.success('Report exported successfully');
    } catch (error) {
      toast.error('Failed to export report');
    } finally {
      setExporting(false);
    }
  };
  
  return (
    <div className="export-button-container">
      <Button
        variant="secondary"
        startIcon={<DownloadIcon />}
        onClick={() => setShowMenu(!showMenu)}
        disabled={exporting}
      >
        {exporting ? 'Exporting...' : 'Export Report'}
      </Button>
      
      {showMenu && (
        <Menu onClose={() => setShowMenu(false)}>
          <MenuItem onClick={() => handleExport('pdf')}>
            <FileIcon type="pdf" />
            Export as PDF
          </MenuItem>
          <MenuItem onClick={() => handleExport('csv')}>
            <FileIcon type="csv" />
            Export as CSV
          </MenuItem>
          <MenuItem onClick={() => handleExport('json')}>
            <FileIcon type="json" />
            Export as JSON
          </MenuItem>
        </Menu>
      )}
    </div>
  );
}
```

## Dependencies
- Time-series database (InfluxDB or TimescaleDB)
- Chart library (Recharts or D3.js)
- WebSocket for real-time updates
- ML service for predictive analytics
- PDF generation library

## Estimated Effort
**5 days**
- 1 day: Data pipeline and collection
- 1 day: Real-time analytics engine
- 1 day: Dashboard UI components
- 1 day: Advanced analytics features
- 1 day: Export and reporting functionality

## Notes
- Ensure GDPR compliance for data collection
- Implement data retention policies
- Cache expensive queries
- Consider sampling for large datasets
- Add role-based access control