# Issue #15: Voice UI Components (Web)

## User Story
As a **web user**, I want to **have intuitive voice channel controls** so that **I can easily join calls, manage my audio settings, and see who's speaking**.

## Description
Build comprehensive voice UI components for the web interface using React and the RealTimeKit SDK. This includes channel lists, participant views, audio controls, and visual indicators for voice activity.

## Acceptance Criteria
- [ ] Voice channel list shows active participants
- [ ] One-click join/leave voice channels
- [ ] Audio input/output device selection
- [ ] Volume controls and mute/unmute
- [ ] Speaking indicators with audio levels
- [ ] Screen sharing controls
- [ ] Voice connection status display
- [ ] Accessible keyboard shortcuts

## Technical Implementation

### 1. Voice Channel List Component
```tsx
interface VoiceChannelProps {
  channel: Channel;
  currentUserId: string;
  onJoin: (channelId: string) => void;
  onLeave: () => void;
}

export function VoiceChannel({ 
  channel, 
  currentUserId, 
  onJoin, 
  onLeave 
}: VoiceChannelProps) {
  const { participants, isConnected } = useVoiceState(channel.id);
  const isInChannel = participants.some(p => p.userId === currentUserId);
  
  return (
    <div className="voice-channel">
      <button
        className="channel-header"
        onClick={() => isInChannel ? onLeave() : onJoin(channel.id)}
        aria-label={isInChannel ? `Leave ${channel.name}` : `Join ${channel.name}`}
      >
        <div className="channel-info">
          <VoiceChannelIcon type={channel.voiceConfig?.type} />
          <span className="channel-name">{channel.name}</span>
          {channel.voiceConfig?.userLimit > 0 && (
            <span className="user-limit">
              {participants.length}/{channel.voiceConfig.userLimit}
            </span>
          )}
        </div>
        
        <div className="channel-actions">
          {isInChannel ? (
            <PhoneOffIcon className="leave-icon" />
          ) : (
            <PhoneIcon className="join-icon" />
          )}
        </div>
      </button>
      
      {participants.length > 0 && (
        <div className="participants-list">
          {participants.map(participant => (
            <VoiceParticipant
              key={participant.userId}
              participant={participant}
              isCurrentUser={participant.userId === currentUserId}
            />
          ))}
        </div>
      )}
    </div>
  );
}

function VoiceParticipant({ 
  participant, 
  isCurrentUser 
}: { 
  participant: VoiceParticipant;
  isCurrentUser: boolean;
}) {
  const { user } = useUser(participant.userId);
  const audioLevel = useAudioLevel(participant.userId);
  
  return (
    <div className={`voice-participant ${participant.isSpeaking ? 'speaking' : ''}`}>
      <div className="participant-avatar">
        <Avatar user={user} size="small" />
        <SpeakingIndicator 
          level={audioLevel} 
          active={participant.isSpeaking}
        />
      </div>
      
      <span className="participant-name">
        {user?.username}
        {isCurrentUser && ' (You)'}
      </span>
      
      <div className="participant-status">
        {participant.isMuted && <MicOffIcon />}
        {participant.isDeafened && <HeadsetOffIcon />}
        {participant.isVideoEnabled && <VideocamIcon />}
        {participant.isScreenSharing && <ScreenShareIcon />}
      </div>
    </div>
  );
}
```

### 2. Voice Controls Bar
```tsx
export function VoiceControlBar() {
  const { 
    isConnected, 
    currentChannel, 
    localParticipant,
    disconnect 
  } = useVoice();
  
  const [showSettings, setShowSettings] = useState(false);
  const [showScreenShare, setShowScreenShare] = useState(false);
  
  if (!isConnected || !currentChannel) return null;
  
  return (
    <div className="voice-control-bar">
      <div className="channel-info">
        <VoiceChannelIcon type={currentChannel.type} />
        <span>{currentChannel.name}</span>
        <ConnectionStatus status={localParticipant?.connectionQuality} />
      </div>
      
      <div className="voice-controls">
        <MicrophoneControl />
        <AudioOutputControl />
        <VideoControl />
        <ScreenShareControl />
        <VoiceSettingsButton onClick={() => setShowSettings(true)} />
      </div>
      
      <button
        className="disconnect-button"
        onClick={disconnect}
        aria-label="Leave voice channel"
      >
        <PhoneOffIcon />
        Disconnect
      </button>
      
      {showSettings && (
        <VoiceSettingsModal onClose={() => setShowSettings(false)} />
      )}
    </div>
  );
}

function MicrophoneControl() {
  const { localParticipant, toggleMute } = useVoice();
  const [showDevices, setShowDevices] = useState(false);
  const audioLevel = useLocalAudioLevel();
  
  const isMuted = localParticipant?.isMuted || false;
  
  return (
    <div className="microphone-control">
      <button
        className={`control-button ${isMuted ? 'muted' : ''}`}
        onClick={toggleMute}
        aria-label={isMuted ? 'Unmute microphone' : 'Mute microphone'}
      >
        {isMuted ? <MicOffIcon /> : <MicIcon />}
        <AudioLevelIndicator level={audioLevel} muted={isMuted} />
      </button>
      
      <button
        className="device-selector"
        onClick={() => setShowDevices(!showDevices)}
        aria-label="Select microphone"
      >
        <ChevronDownIcon />
      </button>
      
      {showDevices && (
        <AudioDeviceMenu 
          type="input"
          onClose={() => setShowDevices(false)}
        />
      )}
    </div>
  );
}
```

### 3. Audio Device Management
```tsx
interface AudioDeviceMenuProps {
  type: 'input' | 'output';
  onClose: () => void;
}

export function AudioDeviceMenu({ type, onClose }: AudioDeviceMenuProps) {
  const { devices, currentDevice, selectDevice } = useAudioDevices(type);
  const [testingDevice, setTestingDevice] = useState<string | null>(null);
  
  const handleSelectDevice = async (deviceId: string) => {
    setTestingDevice(deviceId);
    
    try {
      await selectDevice(deviceId);
      
      // Play test sound for output devices
      if (type === 'output') {
        await playTestSound(deviceId);
      }
    } finally {
      setTestingDevice(null);
      onClose();
    }
  };
  
  return (
    <Menu onClose={onClose}>
      <MenuHeader>
        {type === 'input' ? 'Select Microphone' : 'Select Speaker'}
      </MenuHeader>
      
      {devices.map(device => (
        <MenuItem
          key={device.deviceId}
          selected={device.deviceId === currentDevice?.deviceId}
          onClick={() => handleSelectDevice(device.deviceId)}
        >
          <div className="device-info">
            <span className="device-label">{device.label}</span>
            {device.deviceId === 'default' && (
              <Badge>System Default</Badge>
            )}
          </div>
          
          {testingDevice === device.deviceId && (
            <Spinner size="small" />
          )}
          
          {device.deviceId === currentDevice?.deviceId && (
            <CheckIcon />
          )}
        </MenuItem>
      ))}
      
      <MenuDivider />
      
      <MenuItem onClick={() => openAudioSettings()}>
        <SettingsIcon />
        Audio Settings
      </MenuItem>
    </Menu>
  );
}

// Audio level visualization
export function AudioLevelIndicator({ 
  level, 
  muted 
}: { 
  level: number; 
  muted: boolean;
}) {
  const bars = 3;
  const activeBarCount = muted ? 0 : Math.ceil(level * bars);
  
  return (
    <div className="audio-level-indicator">
      {Array.from({ length: bars }, (_, i) => (
        <div
          key={i}
          className={`level-bar ${i < activeBarCount ? 'active' : ''}`}
          style={{
            animationDelay: `${i * 100}ms`,
            height: `${(i + 1) * 4 + 4}px`
          }}
        />
      ))}
    </div>
  );
}
```

### 4. Voice Settings Modal
```tsx
export function VoiceSettingsModal({ onClose }: { onClose: () => void }) {
  const { settings, updateSettings } = useVoiceSettings();
  const [localSettings, setLocalSettings] = useState(settings);
  
  const handleSave = async () => {
    await updateSettings(localSettings);
    onClose();
  };
  
  return (
    <Modal 
      title="Voice & Video Settings" 
      onClose={onClose}
      className="voice-settings-modal"
    >
      <div className="settings-section">
        <h3>Voice Settings</h3>
        
        <SettingRow label="Input Device">
          <AudioDeviceSelect
            type="input"
            value={localSettings.inputDevice}
            onChange={(device) => 
              setLocalSettings({ ...localSettings, inputDevice: device })
            }
          />
        </SettingRow>
        
        <SettingRow label="Output Device">
          <AudioDeviceSelect
            type="output"
            value={localSettings.outputDevice}
            onChange={(device) => 
              setLocalSettings({ ...localSettings, outputDevice: device })
            }
          />
        </SettingRow>
        
        <SettingRow label="Input Sensitivity">
          <InputSensitivityControl
            value={localSettings.inputSensitivity}
            onChange={(value) => 
              setLocalSettings({ ...localSettings, inputSensitivity: value })
            }
          />
        </SettingRow>
        
        <SettingRow label="Noise Suppression">
          <Switch
            checked={localSettings.noiseSuppression}
            onChange={(checked) => 
              setLocalSettings({ ...localSettings, noiseSuppression: checked })
            }
          />
        </SettingRow>
        
        <SettingRow label="Echo Cancellation">
          <Switch
            checked={localSettings.echoCancellation}
            onChange={(checked) => 
              setLocalSettings({ ...localSettings, echoCancellation: checked })
            }
          />
        </SettingRow>
        
        <SettingRow label="Automatic Gain Control">
          <Switch
            checked={localSettings.automaticGainControl}
            onChange={(checked) => 
              setLocalSettings({ ...localSettings, automaticGainControl: checked })
            }
          />
        </SettingRow>
      </div>
      
      <div className="settings-section">
        <h3>Video Settings</h3>
        
        <SettingRow label="Camera">
          <VideoDeviceSelect
            value={localSettings.videoDevice}
            onChange={(device) => 
              setLocalSettings({ ...localSettings, videoDevice: device })
            }
          />
        </SettingRow>
        
        <SettingRow label="Video Quality">
          <Select
            value={localSettings.videoQuality}
            onChange={(quality) => 
              setLocalSettings({ ...localSettings, videoQuality: quality })
            }
            options={[
              { value: 'low', label: 'Low (360p)' },
              { value: 'medium', label: 'Medium (720p)' },
              { value: 'high', label: 'High (1080p)' }
            ]}
          />
        </SettingRow>
      </div>
      
      <div className="settings-section">
        <h3>Advanced</h3>
        
        <SettingRow label="Hardware Acceleration">
          <Switch
            checked={localSettings.hardwareAcceleration}
            onChange={(checked) => 
              setLocalSettings({ ...localSettings, hardwareAcceleration: checked })
            }
          />
        </SettingRow>
        
        <SettingRow label="Debug Overlay">
          <Switch
            checked={localSettings.debugOverlay}
            onChange={(checked) => 
              setLocalSettings({ ...localSettings, debugOverlay: checked })
            }
          />
        </SettingRow>
      </div>
      
      <div className="modal-footer">
        <Button variant="secondary" onClick={onClose}>
          Cancel
        </Button>
        <Button variant="primary" onClick={handleSave}>
          Save Settings
        </Button>
      </div>
    </Modal>
  );
}
```

### 5. Screen Share Component
```tsx
export function ScreenShareControl() {
  const { isScreenSharing, startScreenShare, stopScreenShare } = useScreenShare();
  const [showOptions, setShowOptions] = useState(false);
  
  const handleScreenShare = async () => {
    if (isScreenSharing) {
      await stopScreenShare();
    } else {
      setShowOptions(true);
    }
  };
  
  return (
    <>
      <button
        className={`control-button ${isScreenSharing ? 'active' : ''}`}
        onClick={handleScreenShare}
        aria-label={isScreenSharing ? 'Stop screen share' : 'Share screen'}
      >
        {isScreenSharing ? <StopScreenShareIcon /> : <ScreenShareIcon />}
      </button>
      
      {showOptions && (
        <ScreenSharePicker
          onSelect={async (source) => {
            await startScreenShare(source);
            setShowOptions(false);
          }}
          onClose={() => setShowOptions(false)}
        />
      )}
    </>
  );
}

function ScreenSharePicker({ 
  onSelect, 
  onClose 
}: { 
  onSelect: (source: ScreenShareSource) => void;
  onClose: () => void;
}) {
  const sources = useScreenSources();
  
  return (
    <Modal title="Choose what to share" onClose={onClose}>
      <div className="screen-share-sources">
        <div className="source-category">
          <h3>Screens</h3>
          <div className="source-grid">
            {sources.screens.map(screen => (
              <button
                key={screen.id}
                className="source-option"
                onClick={() => onSelect(screen)}
              >
                <img src={screen.thumbnail} alt={screen.name} />
                <span>{screen.name}</span>
              </button>
            ))}
          </div>
        </div>
        
        <div className="source-category">
          <h3>Windows</h3>
          <div className="source-grid">
            {sources.windows.map(window => (
              <button
                key={window.id}
                className="source-option"
                onClick={() => onSelect(window)}
              >
                <img src={window.thumbnail} alt={window.name} />
                <span>{window.name}</span>
              </button>
            ))}
          </div>
        </div>
      </div>
      
      <div className="share-options">
        <label>
          <input
            type="checkbox"
            defaultChecked
          />
          Share audio
        </label>
      </div>
    </Modal>
  );
}
```

### 6. Voice Connection Status
```tsx
export function ConnectionStatus({ 
  status 
}: { 
  status?: 'excellent' | 'good' | 'poor';
}) {
  const { latency, packetLoss } = useConnectionMetrics();
  
  const getStatusColor = () => {
    if (status === 'excellent') return 'green';
    if (status === 'good') return 'yellow';
    return 'red';
  };
  
  return (
    <div className="connection-status">
      <div className={`status-indicator ${getStatusColor()}`}>
        <SignalIcon />
      </div>
      
      <Tooltip>
        <div className="connection-details">
          <div>Connection: {status || 'checking...'}</div>
          <div>Latency: {latency}ms</div>
          <div>Packet Loss: {packetLoss}%</div>
        </div>
      </Tooltip>
    </div>
  );
}
```

### 7. Keyboard Shortcuts
```tsx
export function useVoiceKeyboardShortcuts() {
  const { toggleMute, toggleDeafen, disconnect } = useVoice();
  
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      // Check if user is typing
      if (isTyping()) return;
      
      // Ctrl/Cmd + Shift + M: Toggle mute
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'M') {
        e.preventDefault();
        toggleMute();
      }
      
      // Ctrl/Cmd + Shift + D: Toggle deafen
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'D') {
        e.preventDefault();
        toggleDeafen();
      }
      
      // Ctrl/Cmd + Shift + H: Disconnect
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'H') {
        e.preventDefault();
        disconnect();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [toggleMute, toggleDeafen, disconnect]);
}

// Shortcut help overlay
export function VoiceShortcutsHelp() {
  const shortcuts = [
    { keys: ['Ctrl', 'Shift', 'M'], action: 'Toggle Mute' },
    { keys: ['Ctrl', 'Shift', 'D'], action: 'Toggle Deafen' },
    { keys: ['Ctrl', 'Shift', 'H'], action: 'Disconnect from Voice' },
    { keys: ['Space'], action: 'Push to Talk (when enabled)' }
  ];
  
  return (
    <div className="shortcuts-help">
      <h3>Voice Shortcuts</h3>
      {shortcuts.map((shortcut, i) => (
        <div key={i} className="shortcut-row">
          <div className="shortcut-keys">
            {shortcut.keys.map((key, j) => (
              <React.Fragment key={j}>
                {j > 0 && <span className="plus">+</span>}
                <kbd>{key}</kbd>
              </React.Fragment>
            ))}
          </div>
          <span className="shortcut-action">{shortcut.action}</span>
        </div>
      ))}
    </div>
  );
}
```

### 8. Voice Context Provider
```tsx
export const VoiceContext = createContext<VoiceContextValue | null>(null);

export function VoiceProvider({ children }: { children: ReactNode }) {
  const [rtk, setRtk] = useState<RealtimeKit | null>(null);
  const [currentChannel, setCurrentChannel] = useState<Channel | null>(null);
  const [participants, setParticipants] = useState<Map<string, VoiceParticipant>>(new Map());
  const [localParticipant, setLocalParticipant] = useState<LocalParticipant | null>(null);
  
  const connect = useCallback(async (channelId: string) => {
    try {
      // Get RTK token
      const { token, sessionId } = await api.getVoiceToken(channelId);
      
      // Initialize RTK
      const rtkInstance = await RealtimeKit.init({
        authToken: token,
        defaults: {
          audio: true,
          video: false
        }
      });
      
      // Set up event handlers
      rtkInstance.on('participantJoined', handleParticipantJoined);
      rtkInstance.on('participantLeft', handleParticipantLeft);
      rtkInstance.on('participantChanged', handleParticipantChanged);
      rtkInstance.on('connectionQualityChanged', handleConnectionQualityChanged);
      
      // Join session
      await rtkInstance.join();
      
      setRtk(rtkInstance);
      setCurrentChannel(await api.getChannel(channelId));
      
    } catch (error) {
      console.error('Failed to connect to voice:', error);
      throw error;
    }
  }, []);
  
  const disconnect = useCallback(async () => {
    if (rtk) {
      await rtk.disconnect();
      setRtk(null);
      setCurrentChannel(null);
      setParticipants(new Map());
      setLocalParticipant(null);
    }
  }, [rtk]);
  
  const value = {
    isConnected: !!rtk,
    currentChannel,
    participants: Array.from(participants.values()),
    localParticipant,
    connect,
    disconnect,
    toggleMute: () => rtk?.toggleAudio(),
    toggleDeafen: () => rtk?.toggleDeafen(),
    setVolume: (userId: string, volume: number) => rtk?.setParticipantVolume(userId, volume)
  };
  
  return (
    <VoiceContext.Provider value={value}>
      {children}
    </VoiceContext.Provider>
  );
}
```

## Dependencies
- RealTimeKit Setup (Issue #02) for SDK integration
- Voice Channel Model (Issue #13) for data structures
- WebSocket Architecture (Issue #04) for state updates

## Estimated Effort
**5 days**
- 1 day: Voice channel list and participant views
- 1 day: Voice control bar and audio controls
- 1 day: Settings modal and device management
- 1 day: Screen sharing and connection status
- 1 day: Context provider and testing

## Notes
- Ensure WCAG 2.1 AA compliance for accessibility
- Test with various audio devices and configurations
- Add visual feedback for all voice states
- Consider mobile responsive design early