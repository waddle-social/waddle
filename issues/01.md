# Issue #01: Waddle Entity Model

## User Story
As a **platform architect**, I want to **define the core waddle entity structure** so that **we have a scalable foundation for organizing communities**.

## Description
Design and implement the core data model for waddles (our equivalent of Discord servers). This includes the entity structure, relationships, and partitioning strategy that will scale from small friend groups to large communities.

## Acceptance Criteria
- [ ] Waddle entity supports 1 to 250,000 members
- [ ] Each waddle has a unique ID and human-readable name
- [ ] Waddles can be public (discoverable) or private
- [ ] Support for waddle metadata (description, icon, banner)
- [ ] Automatic sharding strategy when waddle exceeds 1,000 active users
- [ ] D1 database created per waddle (horizontal partitioning)
- [ ] Durable Object created per waddle for real-time coordination

## Technical Implementation

### 1. Core Entity Structure
```typescript
interface Waddle {
  id: string;              // UUID
  name: string;            // Unique, 3-32 chars
  displayName: string;     // Non-unique, 1-100 chars
  description?: string;    // Up to 1000 chars
  iconUrl?: string;        // R2 URL
  bannerUrl?: string;      // R2 URL
  ownerId: string;         // User ID
  isPublic: boolean;       // Discoverable
  memberCount: number;     // Cached count
  shardCount: number;      // Number of DOs
  createdAt: Date;
  settings: WaddleSettings;
}

interface WaddleSettings {
  defaultChannelId: string;
  locale: string;
  timezone: string;
  features: string[];      // ["voice", "livestream", "ai"]
}
```

### 2. D1 Schema (Central Directory)
```sql
-- Central waddle directory (single D1)
CREATE TABLE waddles (
  id TEXT PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,
  icon_url TEXT,
  banner_url TEXT,
  owner_id TEXT NOT NULL,
  is_public BOOLEAN DEFAULT false,
  member_count INTEGER DEFAULT 0,
  shard_count INTEGER DEFAULT 1,
  d1_database_id TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  settings JSON,
  
  INDEX idx_name (name),
  INDEX idx_public (is_public),
  INDEX idx_owner (owner_id)
);

-- Waddle memberships (central)
CREATE TABLE waddle_members (
  waddle_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  role TEXT DEFAULT 'member',
  
  PRIMARY KEY (waddle_id, user_id),
  INDEX idx_user (user_id)
);
```

### 3. Per-Waddle D1 Schema
```sql
-- Each waddle gets its own D1 database
CREATE TABLE channels (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL, -- 'text', 'voice', 'announcement'
  position INTEGER,
  category_id TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  channel_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  content TEXT,
  thread_id TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  edited_at DATETIME,
  
  INDEX idx_channel_time (channel_id, created_at DESC)
);

CREATE TABLE roles (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  permissions INTEGER NOT NULL,
  position INTEGER,
  color TEXT
);
```

### 4. Durable Object Implementation
```javascript
export class WaddleDurableObject {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.activeUsers = new Map();
    this.channels = new Map();
  }

  async initialize() {
    const stored = await this.state.storage.get('waddle');
    if (!stored) {
      throw new Error('Waddle not initialized');
    }
    this.waddle = stored;
  }

  async handleJoin(userId, ws) {
    this.activeUsers.set(userId, {
      ws,
      joinedAt: Date.now(),
      presence: 'online'
    });
    
    // Broadcast user joined
    this.broadcast({
      type: 'user_joined',
      userId,
      memberCount: this.activeUsers.size
    });
  }

  async shouldShard() {
    return this.activeUsers.size > 800; // 80% of 1000 limit
  }
}
```

### 5. Sharding Strategy
```javascript
// Worker handles routing to correct shard
export default {
  async fetch(request, env) {
    const { waddleId, channelId } = parseRequest(request);
    
    // Get waddle metadata
    const waddle = await env.CENTRAL_DB.prepare(
      'SELECT shard_count FROM waddles WHERE id = ?'
    ).bind(waddleId).first();
    
    // Route to appropriate shard
    const shardIndex = hashChannel(channelId) % waddle.shard_count;
    const doId = env.WADDLE_DO.idFromName(`${waddleId}-${shardIndex}`);
    const stub = env.WADDLE_DO.get(doId);
    
    return stub.fetch(request);
  }
};
```

## Dependencies
- WorkOS authentication system (Issue #03)
- D1 database setup
- Durable Objects namespace configuration

## Estimated Effort
**5 days**
- 1 day: Entity design and schema
- 2 days: Durable Object implementation
- 1 day: Sharding logic
- 1 day: Testing and documentation

## Notes
- Start with single DO per waddle, implement sharding when needed
- Consider future migration path for waddles that grow beyond expectations
- Monitor D1 10GB limit per waddle database