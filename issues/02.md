# Issue #02: RealTimeKit Setup

## User Story
As a **platform developer**, I want to **configure Cloudflare RealTimeKit** so that **we can provide low-latency voice and video communication globally**.

## Description
Set up and configure Cloudflare RealTimeKit (beta) for our voice/video infrastructure. This includes creating the RealTimeKit app, configuring authentication, and establishing patterns for session management.

## Acceptance Criteria
- [ ] RealTimeKit app created in Cloudflare dashboard
- [ ] Authentication tokens properly integrated with our auth system
- [ ] Voice session creation and management working
- [ ] Participant join/leave flows implemented
- [ ] Audio device permissions handled correctly
- [ ] Session state synchronized with Durable Objects
- [ ] Error handling for common failure scenarios

## Technical Implementation

### 1. RealTimeKit App Configuration
```javascript
// Environment configuration
const REALTIMEKIT_CONFIG = {
  appId: process.env.RTK_APP_ID,
  secretKey: process.env.RTK_SECRET_KEY,
  features: {
    recording: true,
    transcription: true,
    noiseSupression: true,
    aiVoice: true
  }
};
```

### 2. Token Generation
```javascript
// Worker endpoint for RTK token generation
export async function generateRTKToken(userId, waddleId, channelId, env) {
  // Verify user has permission to join voice channel
  const hasPermission = await checkVoicePermission(userId, waddleId, channelId, env);
  if (!hasPermission) {
    throw new Error('Unauthorized');
  }
  
  // Generate RTK auth token
  const payload = {
    sub: userId,
    room: `${waddleId}-${channelId}`,
    permissions: {
      canPublish: true,
      canSubscribe: true,
      canRecord: false, // Based on role
      maxBitrate: 128000
    },
    exp: Math.floor(Date.now() / 1000) + 3600 // 1 hour
  };
  
  // Sign with RTK secret
  const token = await signJWT(payload, env.RTK_SECRET);
  
  return {
    token,
    sessionId: `${waddleId}-${channelId}`,
    iceServers: [] // RTK handles this
  };
}
```

### 3. Session Coordination with Durable Objects
```javascript
export class VoiceChannelDurableObject {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.participants = new Map();
    this.rtkSession = null;
  }
  
  async initializeRTKSession(channelId) {
    // Create RTK session
    const sessionConfig = {
      sessionId: `${this.state.id.toString()}-${channelId}`,
      maxParticipants: 100,
      features: ['recording', 'transcription'],
      webhookUrl: `${this.env.WORKER_URL}/rtk-webhook`
    };
    
    // Store session info
    this.rtkSession = await createRTKSession(sessionConfig, this.env);
    await this.state.storage.put('rtkSession', this.rtkSession);
    
    return this.rtkSession;
  }
  
  async addParticipant(userId, metadata) {
    if (!this.rtkSession) {
      await this.initializeRTKSession(metadata.channelId);
    }
    
    this.participants.set(userId, {
      joinedAt: Date.now(),
      audioEnabled: true,
      videoEnabled: false,
      ...metadata
    });
    
    // Broadcast participant list update
    this.broadcastParticipants();
    
    // Start recording if configured
    if (this.shouldRecord()) {
      await this.startRecording();
    }
  }
  
  async removeParticipant(userId) {
    this.participants.delete(userId);
    this.broadcastParticipants();
    
    // End session if empty
    if (this.participants.size === 0) {
      await this.endSession();
    }
  }
}
```

### 4. Client SDK Integration Pattern
```javascript
// Web client example
class VoiceClient {
  constructor() {
    this.rtk = null;
    this.localStream = null;
  }
  
  async joinVoiceChannel(waddleId, channelId) {
    // Get RTK token from our API
    const { token } = await fetch('/api/voice/token', {
      method: 'POST',
      body: JSON.stringify({ waddleId, channelId })
    }).then(r => r.json());
    
    // Initialize RTK
    this.rtk = await RealtimeKit.init({
      authToken: token,
      defaults: {
        audio: true,
        video: false
      }
    });
    
    // Handle events
    this.rtk.on('participantJoined', this.handleParticipantJoined);
    this.rtk.on('participantLeft', this.handleParticipantLeft);
    this.rtk.on('error', this.handleError);
    
    // Join session
    await this.rtk.join();
  }
  
  async toggleMute() {
    if (this.rtk) {
      const audioTrack = this.rtk.localParticipant.audioTrack;
      audioTrack.enabled = !audioTrack.enabled;
    }
  }
}
```

### 5. Webhook Handler for RTK Events
```javascript
// Worker webhook endpoint
export async function handleRTKWebhook(request, env) {
  const event = await request.json();
  
  switch (event.type) {
    case 'session.started':
      await logSessionStart(event, env);
      break;
      
    case 'session.ended':
      await handleSessionEnd(event, env);
      break;
      
    case 'recording.completed':
      await processRecording(event, env);
      break;
      
    case 'participant.joined':
    case 'participant.left':
      // Update DO state
      const doId = env.VOICE_DO.idFromName(event.sessionId);
      const stub = env.VOICE_DO.get(doId);
      await stub.updateParticipant(event);
      break;
  }
  
  return new Response('OK');
}
```

### 6. Error Handling
```javascript
class RTKErrorHandler {
  static async handle(error, context) {
    const errorTypes = {
      'token_expired': () => context.refreshToken(),
      'session_full': () => context.notifyUserSessionFull(),
      'network_error': () => context.retryWithBackoff(),
      'permission_denied': () => context.showPermissionError(),
      'device_error': () => context.requestDevicePermissions()
    };
    
    const handler = errorTypes[error.code] || (() => {
      console.error('Unhandled RTK error:', error);
      context.showGenericError();
    });
    
    await handler();
  }
}
```

## Dependencies
- Waddle entity model (Issue #01)
- Authentication system (Issue #03)
- RealTimeKit beta access (confirmed)

## Estimated Effort
**5 days**
- 1 day: RTK app setup and configuration
- 2 days: Token generation and session management
- 1 day: Client SDK integration patterns
- 1 day: Testing with multiple participants

## Notes
- Monitor RTK beta limitations and quotas
- Plan for graceful degradation if RTK is unavailable
- Consider recording storage costs in R2
- Test with various network conditions