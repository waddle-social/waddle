# Issue #19: Voice Channel Moderation Tools

## User Story
As a **moderator**, I want to **manage voice channel participants effectively** so that **I can maintain a safe and organized communication environment**.

## Description
Implement comprehensive moderation tools for voice channels including mute/unmute, move participants, disconnect users, and stage channel management. This includes both UI controls and permission-based API endpoints.

## Acceptance Criteria
- [ ] Server mute/unmute participants
- [ ] Move participants between channels
- [ ] Disconnect users from voice
- [ ] Stage channel speaker management
- [ ] Bulk moderation actions
- [ ] Moderation audit log
- [ ] Permission-based UI visibility
- [ ] Mobile moderation support

## Technical Implementation

### 1. Moderation Actions Model
```typescript
export enum ModerationAction {
  // Voice moderation
  SERVER_MUTE = 'server_mute',
  SERVER_UNMUTE = 'server_unmute',
  SERVER_DEAFEN = 'server_deafen',
  SERVER_UNDEAFEN = 'server_undeafen',
  DISCONNECT = 'disconnect',
  MOVE_CHANNEL = 'move_channel',
  
  // Stage moderation
  PROMOTE_SPEAKER = 'promote_speaker',
  DEMOTE_LISTENER = 'demote_listener',
  APPROVE_REQUEST = 'approve_request',
  DENY_REQUEST = 'deny_request',
  
  // Channel management
  LIMIT_USERS = 'limit_users',
  LOCK_CHANNEL = 'lock_channel',
  UNLOCK_CHANNEL = 'unlock_channel',
  SET_BITRATE = 'set_bitrate'
}

export interface ModerationRequest {
  action: ModerationAction;
  targetUserId?: string;
  targetUserIds?: string[]; // For bulk actions
  channelId: string;
  moderatorId: string;
  reason?: string;
  metadata?: {
    moveToChannelId?: string;
    userLimit?: number;
    bitrate?: number;
  };
}

export interface ModerationResult {
  success: boolean;
  action: ModerationAction;
  affectedUsers: string[];
  error?: string;
  timestamp: number;
}
```

### 2. Voice Moderation Service
```typescript
export class VoiceModerationService {
  constructor(
    private channelManager: ChannelManager,
    private permissionService: PermissionService,
    private auditLogger: AuditLogger
  ) {}
  
  async executeModerationAction(
    request: ModerationRequest
  ): Promise<ModerationResult> {
    // Verify moderator permissions
    const hasPermission = await this.verifyPermission(
      request.moderatorId,
      request.channelId,
      request.action
    );
    
    if (!hasPermission) {
      return {
        success: false,
        action: request.action,
        affectedUsers: [],
        error: 'Insufficient permissions',
        timestamp: Date.now()
      };
    }
    
    try {
      let result: ModerationResult;
      
      switch (request.action) {
        case ModerationAction.SERVER_MUTE:
          result = await this.serverMute(request);
          break;
          
        case ModerationAction.SERVER_UNMUTE:
          result = await this.serverUnmute(request);
          break;
          
        case ModerationAction.DISCONNECT:
          result = await this.disconnectUser(request);
          break;
          
        case ModerationAction.MOVE_CHANNEL:
          result = await this.moveUser(request);
          break;
          
        case ModerationAction.PROMOTE_SPEAKER:
          result = await this.promoteSpeaker(request);
          break;
          
        case ModerationAction.LOCK_CHANNEL:
          result = await this.lockChannel(request);
          break;
          
        default:
          throw new Error(`Unknown moderation action: ${request.action}`);
      }
      
      // Log action
      await this.auditLogger.log({
        ...request,
        result,
        timestamp: Date.now()
      });
      
      return result;
      
    } catch (error) {
      console.error('Moderation action failed:', error);
      return {
        success: false,
        action: request.action,
        affectedUsers: [],
        error: error.message,
        timestamp: Date.now()
      };
    }
  }
  
  private async serverMute(request: ModerationRequest): Promise<ModerationResult> {
    const targets = this.getTargetUsers(request);
    const affectedUsers: string[] = [];
    
    for (const userId of targets) {
      const participant = await this.channelManager.getParticipant(
        request.channelId,
        userId
      );
      
      if (!participant) continue;
      
      // Update participant state
      await this.channelManager.updateParticipant(request.channelId, userId, {
        isMuted: true,
        isSelfMuted: false, // Distinguish server mute
        mutedBy: request.moderatorId,
        mutedAt: Date.now()
      });
      
      // Update RTK permissions
      await this.updateRTKPermissions(participant.sessionId, userId, {
        canPublish: false
      });
      
      // Send notification
      await this.notifyUser(userId, {
        type: 'server_muted',
        channelId: request.channelId,
        moderator: request.moderatorId,
        reason: request.reason
      });
      
      affectedUsers.push(userId);
    }
    
    return {
      success: true,
      action: request.action,
      affectedUsers,
      timestamp: Date.now()
    };
  }
  
  private async disconnectUser(request: ModerationRequest): Promise<ModerationResult> {
    const targets = this.getTargetUsers(request);
    const affectedUsers: string[] = [];
    
    for (const userId of targets) {
      // Force disconnect from RTK
      await this.forceDisconnectRTK(request.channelId, userId);
      
      // Remove from channel
      await this.channelManager.removeParticipant(request.channelId, userId);
      
      // Send disconnect command
      await this.sendDisconnectCommand(userId, {
        reason: 'moderator_action',
        message: request.reason || 'Disconnected by moderator'
      });
      
      affectedUsers.push(userId);
    }
    
    // Broadcast to channel
    await this.broadcastModerationAction(request.channelId, {
      type: 'users_disconnected',
      users: affectedUsers,
      moderator: request.moderatorId
    });
    
    return {
      success: true,
      action: request.action,
      affectedUsers,
      timestamp: Date.now()
    };
  }
  
  private async moveUser(request: ModerationRequest): Promise<ModerationResult> {
    const targetChannelId = request.metadata?.moveToChannelId;
    if (!targetChannelId) {
      throw new Error('Target channel ID required for move action');
    }
    
    // Verify target channel exists and user can join
    const targetChannel = await this.channelManager.getChannel(targetChannelId);
    if (!targetChannel) {
      throw new Error('Target channel not found');
    }
    
    const targets = this.getTargetUsers(request);
    const affectedUsers: string[] = [];
    
    for (const userId of targets) {
      // Check if user can join target channel
      const canJoin = await this.permissionService.canJoinChannel(
        userId,
        targetChannelId
      );
      
      if (!canJoin) continue;
      
      // Move user
      await this.channelManager.moveParticipant(
        userId,
        request.channelId,
        targetChannelId
      );
      
      // Send move notification
      await this.sendMoveNotification(userId, {
        fromChannel: request.channelId,
        toChannel: targetChannelId,
        moderator: request.moderatorId
      });
      
      affectedUsers.push(userId);
    }
    
    return {
      success: true,
      action: request.action,
      affectedUsers,
      timestamp: Date.now()
    };
  }
}
```

### 3. Stage Channel Moderation
```typescript
export class StageModerationService {
  async manageSpeakerRequests(
    channelId: string,
    moderatorId: string
  ): Promise<SpeakerRequest[]> {
    // Get pending requests
    const requests = await this.db.prepare(`
      SELECT * FROM stage_requests
      WHERE channel_id = ? AND status = 'pending'
      ORDER BY requested_at ASC
    `).bind(channelId).all();
    
    return requests.results.map(r => ({
      id: r.id,
      userId: r.user_id,
      requestedAt: r.requested_at,
      user: this.getUserInfo(r.user_id)
    }));
  }
  
  async processSpeakerRequest(
    requestId: string,
    action: 'approve' | 'deny',
    moderatorId: string,
    reason?: string
  ): Promise<void> {
    const request = await this.getRequest(requestId);
    if (!request || request.status !== 'pending') {
      throw new Error('Invalid request');
    }
    
    if (action === 'approve') {
      // Update request
      await this.db.prepare(`
        UPDATE stage_requests
        SET status = 'approved',
            approved_by = ?,
            approved_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(moderatorId, requestId).run();
      
      // Promote to speaker
      await this.promoteToSpeaker(request.channel_id, request.user_id);
      
      // Notify user
      await this.notify(request.user_id, {
        type: 'speaker_request_approved',
        channelId: request.channel_id
      });
      
    } else {
      // Update request
      await this.db.prepare(`
        UPDATE stage_requests
        SET status = 'denied',
            denied_by = ?,
            denied_at = CURRENT_TIMESTAMP,
            denial_reason = ?
        WHERE id = ?
      `).bind(moderatorId, reason, requestId).run();
      
      // Notify user
      await this.notify(request.user_id, {
        type: 'speaker_request_denied',
        channelId: request.channel_id,
        reason
      });
    }
  }
  
  async inviteToSpeak(
    channelId: string,
    userId: string,
    moderatorId: string
  ): Promise<void> {
    // Check if user is in channel
    const participant = await this.getParticipant(channelId, userId);
    if (!participant || participant.role === 'speaker') {
      throw new Error('Invalid target user');
    }
    
    // Send invitation
    await this.notify(userId, {
      type: 'speaker_invitation',
      channelId,
      invitedBy: moderatorId,
      actions: [
        { label: 'Accept', action: 'accept_speaker_invite' },
        { label: 'Decline', action: 'decline_speaker_invite' }
      ]
    });
    
    // Store invitation
    await this.db.prepare(`
      INSERT INTO speaker_invitations (channel_id, user_id, invited_by)
      VALUES (?, ?, ?)
    `).bind(channelId, userId, moderatorId).run();
  }
}
```

### 4. Moderation UI Components
```tsx
export function VoiceModerationPanel({ channelId }: { channelId: string }) {
  const { participants } = useVoiceParticipants(channelId);
  const { permissions } = useChannelPermissions(channelId);
  const [selectedUsers, setSelectedUsers] = useState<Set<string>>(new Set());
  const [showBulkActions, setShowBulkActions] = useState(false);
  
  const moderationActions = useMemo(() => {
    const actions = [];
    
    if (permissions.canMuteMembers) {
      actions.push({
        id: 'mute',
        label: 'Server Mute',
        icon: <MicOffIcon />,
        action: ModerationAction.SERVER_MUTE
      });
    }
    
    if (permissions.canMoveMembers) {
      actions.push({
        id: 'move',
        label: 'Move to Channel',
        icon: <MoveIcon />,
        action: ModerationAction.MOVE_CHANNEL
      });
    }
    
    if (permissions.canDisconnectMembers) {
      actions.push({
        id: 'disconnect',
        label: 'Disconnect',
        icon: <PhoneDisabledIcon />,
        action: ModerationAction.DISCONNECT,
        danger: true
      });
    }
    
    return actions;
  }, [permissions]);
  
  const handleBulkAction = async (action: ModerationAction) => {
    const result = await executeModerationAction({
      action,
      targetUserIds: Array.from(selectedUsers),
      channelId
    });
    
    if (result.success) {
      toast.success(`Action completed for ${result.affectedUsers.length} users`);
      setSelectedUsers(new Set());
    } else {
      toast.error(result.error || 'Action failed');
    }
  };
  
  return (
    <div className="voice-moderation-panel">
      <div className="panel-header">
        <h3>Voice Moderation</h3>
        {selectedUsers.size > 0 && (
          <Button
            variant="secondary"
            size="small"
            onClick={() => setShowBulkActions(!showBulkActions)}
          >
            {selectedUsers.size} selected
          </Button>
        )}
      </div>
      
      {showBulkActions && (
        <BulkActionBar
          actions={moderationActions}
          onAction={handleBulkAction}
          onCancel={() => {
            setSelectedUsers(new Set());
            setShowBulkActions(false);
          }}
        />
      )}
      
      <div className="participant-list">
        {participants.map(participant => (
          <ModeratableParticipant
            key={participant.userId}
            participant={participant}
            selected={selectedUsers.has(participant.userId)}
            onSelect={(selected) => {
              const newSelection = new Set(selectedUsers);
              if (selected) {
                newSelection.add(participant.userId);
              } else {
                newSelection.delete(participant.userId);
              }
              setSelectedUsers(newSelection);
            }}
            actions={moderationActions}
          />
        ))}
      </div>
    </div>
  );
}

function ModeratableParticipant({ 
  participant, 
  selected, 
  onSelect, 
  actions 
}: {
  participant: VoiceParticipant;
  selected: boolean;
  onSelect: (selected: boolean) => void;
  actions: ModerationActionDef[];
}) {
  const [showActions, setShowActions] = useState(false);
  const { currentUser } = useAuth();
  
  // Don't show moderation for self
  if (participant.userId === currentUser.id) {
    return <ParticipantItem participant={participant} />;
  }
  
  return (
    <div className="moderatable-participant">
      <Checkbox
        checked={selected}
        onChange={(e) => onSelect(e.target.checked)}
      />
      
      <ParticipantItem participant={participant} />
      
      <IconButton
        icon={<MoreVertIcon />}
        onClick={() => setShowActions(true)}
        size="small"
      />
      
      {showActions && (
        <ModerationMenu
          participant={participant}
          actions={actions}
          onClose={() => setShowActions(false)}
        />
      )}
    </div>
  );
}
```

### 5. Quick Moderation Shortcuts
```tsx
export function QuickModerationBar({ channelId }: { channelId: string }) {
  const { executeAction } = useVoiceModeration();
  const [muteAllActive, setMuteAllActive] = useState(false);
  
  const quickActions = [
    {
      id: 'mute-all',
      label: 'Mute All',
      icon: <MicOffIcon />,
      description: 'Server mute all participants except moderators',
      action: async () => {
        const confirmed = await confirm(
          'Mute all participants?',
          'This will server mute all non-moderator participants.'
        );
        
        if (confirmed) {
          setMuteAllActive(true);
          await executeAction({
            action: ModerationAction.SERVER_MUTE,
            channelId,
            targetUserIds: 'all_except_moderators'
          });
        }
      }
    },
    {
      id: 'unmute-all',
      label: 'Unmute All',
      icon: <MicIcon />,
      description: 'Remove server mute from all participants',
      action: async () => {
        await executeAction({
          action: ModerationAction.SERVER_UNMUTE,
          channelId,
          targetUserIds: 'all'
        });
        setMuteAllActive(false);
      },
      disabled: !muteAllActive
    },
    {
      id: 'lock-channel',
      label: 'Lock Channel',
      icon: <LockIcon />,
      description: 'Prevent new users from joining',
      action: async () => {
        await executeAction({
          action: ModerationAction.LOCK_CHANNEL,
          channelId
        });
      }
    },
    {
      id: 'clear-channel',
      label: 'Clear Channel',
      icon: <ClearAllIcon />,
      description: 'Disconnect all participants',
      danger: true,
      action: async () => {
        const confirmed = await confirm(
          'Clear voice channel?',
          'This will disconnect all participants from the channel.',
          { dangerous: true }
        );
        
        if (confirmed) {
          await executeAction({
            action: ModerationAction.DISCONNECT,
            channelId,
            targetUserIds: 'all'
          });
        }
      }
    }
  ];
  
  return (
    <div className="quick-moderation-bar">
      {quickActions.map(action => (
        <Tooltip key={action.id} content={action.description}>
          <Button
            variant={action.danger ? 'danger' : 'secondary'}
            size="small"
            onClick={action.action}
            disabled={action.disabled}
            icon={action.icon}
          >
            {action.label}
          </Button>
        </Tooltip>
      ))}
    </div>
  );
}
```

### 6. Moderation Audit Log
```typescript
export class ModerationAuditLogger {
  async log(entry: AuditLogEntry): Promise<void> {
    await this.db.prepare(`
      INSERT INTO moderation_audit_log (
        id, action, moderator_id, target_user_id, target_user_ids,
        channel_id, reason, metadata, result, timestamp
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      crypto.randomUUID(),
      entry.action,
      entry.moderatorId,
      entry.targetUserId,
      JSON.stringify(entry.targetUserIds || []),
      entry.channelId,
      entry.reason,
      JSON.stringify(entry.metadata || {}),
      JSON.stringify(entry.result),
      entry.timestamp
    ).run();
    
    // Send to analytics
    await this.analytics.track('moderation_action', {
      action: entry.action,
      success: entry.result.success,
      affectedCount: entry.result.affectedUsers.length
    });
  }
  
  async getAuditLog(
    filters: AuditLogFilters
  ): Promise<AuditLogEntry[]> {
    let query = `
      SELECT 
        l.*,
        m.username as moderator_name,
        m.avatar_url as moderator_avatar
      FROM moderation_audit_log l
      JOIN users m ON l.moderator_id = m.id
      WHERE 1=1
    `;
    
    const params = [];
    
    if (filters.channelId) {
      query += ' AND l.channel_id = ?';
      params.push(filters.channelId);
    }
    
    if (filters.moderatorId) {
      query += ' AND l.moderator_id = ?';
      params.push(filters.moderatorId);
    }
    
    if (filters.action) {
      query += ' AND l.action = ?';
      params.push(filters.action);
    }
    
    if (filters.startDate) {
      query += ' AND l.timestamp >= ?';
      params.push(filters.startDate.getTime());
    }
    
    query += ' ORDER BY l.timestamp DESC LIMIT ? OFFSET ?';
    params.push(filters.limit || 50, filters.offset || 0);
    
    const results = await this.db.prepare(query).bind(...params).all();
    
    return results.results.map(this.formatAuditEntry);
  }
}

// Audit log viewer component
export function AuditLogViewer({ channelId }: { channelId: string }) {
  const [entries, setEntries] = useState<AuditLogEntry[]>([]);
  const [filters, setFilters] = useState<AuditLogFilters>({ channelId });
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadAuditLog();
  }, [filters]);
  
  const loadAuditLog = async () => {
    setLoading(true);
    const log = await api.getModerationAuditLog(filters);
    setEntries(log);
    setLoading(false);
  };
  
  return (
    <div className="audit-log-viewer">
      <AuditLogFilters value={filters} onChange={setFilters} />
      
      {loading ? (
        <Spinner />
      ) : (
        <div className="audit-entries">
          {entries.map(entry => (
            <AuditLogEntry key={entry.id} entry={entry} />
          ))}
        </div>
      )}
    </div>
  );
}
```

### 7. Mobile Moderation Interface
```tsx
export function MobileModerationSheet({ 
  participant,
  onClose 
}: { 
  participant: VoiceParticipant;
  onClose: () => void;
}) {
  const { executeAction } = useVoiceModeration();
  const [loading, setLoading] = useState(false);
  
  const handleAction = async (action: ModerationAction) => {
    setLoading(true);
    
    try {
      const result = await executeAction({
        action,
        targetUserId: participant.userId,
        channelId: participant.channelId
      });
      
      if (result.success) {
        toast.success('Action completed');
        onClose();
      } else {
        toast.error(result.error || 'Action failed');
      }
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <BottomSheet onClose={onClose}>
      <div className="mobile-moderation">
        <div className="participant-header">
          <Avatar user={participant} size="large" />
          <h3>{participant.username}</h3>
          <p className="participant-state">
            {participant.isSpeaking && 'Speaking • '}
            {participant.isMuted && 'Muted • '}
            {participant.connectionQuality}
          </p>
        </div>
        
        <div className="moderation-actions">
          <ModerationAction
            icon={<MicOffIcon />}
            label={participant.isMuted ? "Unmute" : "Server Mute"}
            onPress={() => handleAction(
              participant.isMuted 
                ? ModerationAction.SERVER_UNMUTE 
                : ModerationAction.SERVER_MUTE
            )}
            disabled={loading}
          />
          
          <ModerationAction
            icon={<MoveIcon />}
            label="Move to Channel"
            onPress={() => openChannelPicker(participant.userId)}
            disabled={loading}
          />
          
          <ModerationAction
            icon={<PhoneDisabledIcon />}
            label="Disconnect"
            onPress={() => handleAction(ModerationAction.DISCONNECT)}
            disabled={loading}
            danger
          />
        </div>
        
        <div className="additional-actions">
          <Button
            variant="text"
            fullWidth
            onClick={() => openUserProfile(participant.userId)}
          >
            View Profile
          </Button>
          
          <Button
            variant="text"
            fullWidth
            onClick={() => openDirectMessage(participant.userId)}
          >
            Send Message
          </Button>
        </div>
      </div>
    </BottomSheet>
  );
}
```

## Dependencies
- Voice Channel Model (Issue #13) for channel structure
- Participant Tracking (Issue #18) for user state
- Permission System (Issue #23) for access control
- RealTimeKit Session (Issue #14) for voice control

## Estimated Effort
**5 days**
- 1 day: Core moderation service
- 1 day: Stage channel management
- 1 day: UI components for moderation
- 1 day: Audit logging system
- 1 day: Mobile interface and testing

## Notes
- Implement rate limiting for moderation actions
- Add moderation action queuing for bulk operations
- Consider temporary moderation actions (timed mutes)
- Add moderation templates for common scenarios