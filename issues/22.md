# Issue #22: Invitation System

## User Story
As a **waddle member**, I want to **invite friends to join my waddle** so that **I can grow my community with people I trust**.

## Description
Implement a comprehensive invitation system supporting multiple invite types, expiration settings, usage limits, role assignments, and analytics. This includes both temporary and permanent invites, custom vanity URLs, and integration with social platforms.

## Acceptance Criteria
- [ ] Generate unique invitation links
- [ ] Set expiration time for invites
- [ ] Limit number of uses per invite
- [ ] Assign roles to invited users
- [ ] Track invite usage analytics
- [ ] Support vanity URLs for waddles
- [ ] QR code generation for invites
- [ ] Social media integration

## Technical Implementation

### 1. Invite System Architecture
```typescript
export interface Invite {
  code: string;
  waddleId: string;
  channelId?: string; // Optional landing channel
  createdBy: string;
  createdAt: number;
  expiresAt: number | null;
  maxUses: number | null;
  uses: number;
  targetRole?: string;
  metadata?: {
    campaign?: string;
    source?: string;
    customMessage?: string;
  };
}

export class InviteService {
  private readonly INVITE_CODE_LENGTH = 8;
  private readonly VANITY_MIN_LENGTH = 3;
  
  constructor(
    private db: D1Database,
    private analytics: AnalyticsService,
    private rateLimiter: RateLimiter
  ) {}
  
  async createInvite(
    request: CreateInviteRequest,
    userId: string
  ): Promise<InviteResponse> {
    // Check permissions
    const canInvite = await this.checkInvitePermission(userId, request.waddleId);
    if (!canInvite) {
      throw new ForbiddenError('No permission to create invites');
    }
    
    // Rate limiting
    await this.rateLimiter.check(`invite:${userId}`, {
      limit: 10,
      window: 3600 // 1 hour
    });
    
    // Generate invite code
    const code = request.customCode 
      ? await this.validateCustomCode(request.customCode)
      : this.generateInviteCode();
    
    // Create invite
    const invite: Invite = {
      code,
      waddleId: request.waddleId,
      channelId: request.channelId,
      createdBy: userId,
      createdAt: Date.now(),
      expiresAt: request.expiresIn 
        ? Date.now() + request.expiresIn 
        : null,
      maxUses: request.maxUses || null,
      uses: 0,
      targetRole: request.targetRole,
      metadata: request.metadata
    };
    
    // Store in database
    await this.saveInvite(invite);
    
    // Generate response
    return {
      code: invite.code,
      url: this.generateInviteUrl(invite.code),
      qrCode: await this.generateQRCode(invite.code),
      expiresAt: invite.expiresAt,
      maxUses: invite.maxUses
    };
  }
  
  private generateInviteCode(): string {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
    let code = '';
    
    for (let i = 0; i < this.INVITE_CODE_LENGTH; i++) {
      code += chars[Math.floor(Math.random() * chars.length)];
    }
    
    return code;
  }
  
  private generateInviteUrl(code: string): string {
    return `${process.env.APP_URL}/invite/${code}`;
  }
  
  async useInvite(
    code: string,
    userId: string,
    metadata?: InviteUseMetadata
  ): Promise<InviteUseResult> {
    const invite = await this.getInvite(code);
    
    if (!invite) {
      throw new NotFoundError('Invalid invite code');
    }
    
    // Validate invite
    const validation = await this.validateInvite(invite, userId);
    if (!validation.valid) {
      throw new InvalidInviteError(validation.reason);
    }
    
    // Check if user is already a member
    const isMember = await this.isMember(userId, invite.waddleId);
    if (isMember) {
      return {
        success: true,
        alreadyMember: true,
        waddleId: invite.waddleId
      };
    }
    
    // Use the invite
    await this.db.batch([
      // Increment usage count
      this.db.prepare(`
        UPDATE invites 
        SET uses = uses + 1 
        WHERE code = ?
      `).bind(code),
      
      // Add user to waddle
      this.db.prepare(`
        INSERT INTO waddle_members (waddle_id, user_id, joined_at, invited_by, invite_code)
        VALUES (?, ?, ?, ?, ?)
      `).bind(invite.waddleId, userId, Date.now(), invite.createdBy, code),
      
      // Assign role if specified
      ...(invite.targetRole ? [
        this.db.prepare(`
          INSERT INTO member_roles (waddle_id, user_id, role_id)
          VALUES (?, ?, ?)
        `).bind(invite.waddleId, userId, invite.targetRole)
      ] : [])
    ]);
    
    // Track analytics
    await this.trackInviteUse(invite, userId, metadata);
    
    // Send notifications
    await this.sendInviteNotifications(invite, userId);
    
    return {
      success: true,
      waddleId: invite.waddleId,
      channelId: invite.channelId,
      assignedRole: invite.targetRole
    };
  }
  
  private async validateInvite(
    invite: Invite,
    userId: string
  ): Promise<ValidationResult> {
    // Check expiration
    if (invite.expiresAt && Date.now() > invite.expiresAt) {
      return { valid: false, reason: 'Invite has expired' };
    }
    
    // Check usage limit
    if (invite.maxUses && invite.uses >= invite.maxUses) {
      return { valid: false, reason: 'Invite has reached usage limit' };
    }
    
    // Check if user is banned
    const isBanned = await this.isUserBanned(userId, invite.waddleId);
    if (isBanned) {
      return { valid: false, reason: 'You are banned from this waddle' };
    }
    
    // Check waddle capacity
    const waddle = await this.getWaddle(invite.waddleId);
    if (waddle.memberLimit && waddle.memberCount >= waddle.memberLimit) {
      return { valid: false, reason: 'Waddle is full' };
    }
    
    return { valid: true };
  }
}
```

### 2. Vanity URL System
```typescript
export class VanityURLService {
  private readonly RESERVED_PATHS = new Set([
    'api', 'app', 'admin', 'login', 'register', 'invite',
    'discover', 'settings', 'help', 'about', 'terms'
  ]);
  
  async createVanityURL(
    waddleId: string,
    vanityPath: string,
    userId: string
  ): Promise<VanityURL> {
    // Validate permissions
    const canManage = await this.checkManagePermission(userId, waddleId);
    if (!canManage) {
      throw new ForbiddenError('No permission to manage vanity URLs');
    }
    
    // Validate vanity path
    const validation = this.validateVanityPath(vanityPath);
    if (!validation.valid) {
      throw new ValidationError(validation.errors);
    }
    
    // Check availability
    const isAvailable = await this.checkAvailability(vanityPath);
    if (!isAvailable) {
      throw new ConflictError('Vanity URL is already taken');
    }
    
    // Create vanity URL
    const vanityURL = {
      id: crypto.randomUUID(),
      waddleId,
      path: vanityPath.toLowerCase(),
      createdBy: userId,
      createdAt: Date.now(),
      isActive: true
    };
    
    await this.db.prepare(`
      INSERT INTO vanity_urls (id, waddle_id, path, created_by, created_at, is_active)
      VALUES (?, ?, ?, ?, ?, ?)
    `).bind(...Object.values(vanityURL)).run();
    
    // Update edge configuration
    await this.updateEdgeRouting(vanityPath, waddleId);
    
    return {
      path: vanityPath,
      url: `${process.env.APP_URL}/${vanityPath}`,
      waddleId
    };
  }
  
  private validateVanityPath(path: string): ValidationResult {
    const errors: string[] = [];
    
    // Length check
    if (path.length < this.VANITY_MIN_LENGTH) {
      errors.push(`Path must be at least ${this.VANITY_MIN_LENGTH} characters`);
    }
    
    if (path.length > 32) {
      errors.push('Path must be 32 characters or less');
    }
    
    // Character check
    if (!/^[a-z0-9-]+$/.test(path.toLowerCase())) {
      errors.push('Path can only contain letters, numbers, and hyphens');
    }
    
    // Reserved check
    if (this.RESERVED_PATHS.has(path.toLowerCase())) {
      errors.push('This path is reserved');
    }
    
    // No consecutive hyphens
    if (path.includes('--')) {
      errors.push('Path cannot contain consecutive hyphens');
    }
    
    // Must start and end with alphanumeric
    if (!/^[a-z0-9].*[a-z0-9]$/i.test(path)) {
      errors.push('Path must start and end with a letter or number');
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  async updateEdgeRouting(path: string, waddleId: string): Promise<void> {
    // Update Cloudflare Worker routes
    await this.env.VANITY_ROUTES.put(path, waddleId, {
      metadata: {
        type: 'waddle',
        createdAt: Date.now()
      }
    });
  }
}
```

### 3. QR Code Generation
```typescript
export class QRCodeService {
  async generateInviteQR(
    inviteCode: string,
    options?: QROptions
  ): Promise<QRCodeResult> {
    const qr = new QRCodeGenerator();
    
    const inviteUrl = `${process.env.APP_URL}/invite/${inviteCode}`;
    
    // Generate QR code with branding
    const qrOptions = {
      text: inviteUrl,
      width: options?.size || 400,
      height: options?.size || 400,
      colorDark: options?.darkColor || '#1a1a1a',
      colorLight: options?.lightColor || '#ffffff',
      correctLevel: QRErrorCorrectLevel.M,
      logo: options?.includeLogo ? '/waddle-logo.png' : undefined,
      logoWidth: options?.size ? options.size * 0.2 : 80,
      logoHeight: options?.size ? options.size * 0.2 : 80,
      logoBackgroundTransparent: true
    };
    
    const qrDataURL = await qr.toDataURL(qrOptions);
    const qrBuffer = await qr.toBuffer(qrOptions);
    
    // Store in R2 for caching
    const qrKey = `qr/${inviteCode}-${this.hashOptions(qrOptions)}.png`;
    await this.env.QR_BUCKET.put(qrKey, qrBuffer, {
      httpMetadata: {
        contentType: 'image/png',
        cacheControl: 'public, max-age=3600'
      }
    });
    
    return {
      dataURL: qrDataURL,
      url: `${process.env.CDN_URL}/${qrKey}`,
      inviteUrl
    };
  }
  
  async generateDynamicQR(
    waddleId: string,
    options?: DynamicQROptions
  ): Promise<DynamicQRResult> {
    // Create a permanent redirect that can be updated
    const redirectId = crypto.randomUUID();
    const redirectUrl = `${process.env.APP_URL}/r/${redirectId}`;
    
    // Store redirect mapping
    await this.env.REDIRECTS.put(redirectId, JSON.stringify({
      type: 'waddle_invite',
      waddleId,
      createdAt: Date.now(),
      analytics: true
    }));
    
    // Generate QR for redirect URL
    const qr = await this.generateQR(redirectUrl, options);
    
    return {
      ...qr,
      redirectId,
      redirectUrl,
      updateUrl: `${process.env.API_URL}/qr/${redirectId}`
    };
  }
}
```

### 4. Invite Analytics
```typescript
export class InviteAnalytics {
  async trackInviteUse(
    invite: Invite,
    userId: string,
    metadata?: InviteUseMetadata
  ): Promise<void> {
    const event = {
      eventType: 'invite_used',
      inviteCode: invite.code,
      waddleId: invite.waddleId,
      inviterId: invite.createdBy,
      inviteeId: userId,
      timestamp: Date.now(),
      metadata: {
        source: metadata?.source || 'direct',
        referrer: metadata?.referrer,
        device: metadata?.device,
        location: metadata?.location,
        campaign: invite.metadata?.campaign
      }
    };
    
    // Store event
    await this.analytics.track(event);
    
    // Update invite stats
    await this.updateInviteStats(invite.code, {
      lastUsedAt: Date.now(),
      totalUses: invite.uses + 1
    });
    
    // Update inviter stats
    await this.updateUserInviteStats(invite.createdBy, {
      invitesSent: 1,
      successfulInvites: 1
    });
  }
  
  async getInviteAnalytics(
    waddleId: string,
    timeRange: TimeRange
  ): Promise<InviteAnalyticsReport> {
    const stats = await this.db.prepare(`
      SELECT 
        COUNT(DISTINCT i.code) as total_invites,
        COUNT(DISTINCT iu.user_id) as unique_joins,
        SUM(i.uses) as total_uses,
        AVG(i.uses) as avg_uses_per_invite,
        COUNT(DISTINCT i.created_by) as unique_inviters
      FROM invites i
      LEFT JOIN invite_uses iu ON i.code = iu.invite_code
      WHERE i.waddle_id = ?
        AND i.created_at >= ?
        AND i.created_at <= ?
    `).bind(waddleId, timeRange.start, timeRange.end).first();
    
    // Get top inviters
    const topInviters = await this.db.prepare(`
      SELECT 
        u.id,
        u.username,
        u.avatar_url,
        COUNT(DISTINCT iu.user_id) as invites_accepted,
        COUNT(DISTINCT i.code) as invites_created
      FROM users u
      JOIN invites i ON u.id = i.created_by
      LEFT JOIN invite_uses iu ON i.code = iu.invite_code
      WHERE i.waddle_id = ?
        AND i.created_at >= ?
      GROUP BY u.id
      ORDER BY invites_accepted DESC
      LIMIT 10
    `).bind(waddleId, timeRange.start).all();
    
    // Get conversion funnel
    const funnel = await this.calculateInviteFunnel(waddleId, timeRange);
    
    // Get source attribution
    const sources = await this.getInviteSources(waddleId, timeRange);
    
    return {
      overview: {
        totalInvites: stats.total_invites,
        uniqueJoins: stats.unique_joins,
        totalUses: stats.total_uses,
        averageUsesPerInvite: stats.avg_uses_per_invite,
        conversionRate: stats.total_invites > 0 
          ? (stats.unique_joins / stats.total_invites) * 100 
          : 0
      },
      topInviters: topInviters.results,
      funnel,
      sources,
      timeRange
    };
  }
  
  private async calculateInviteFunnel(
    waddleId: string,
    timeRange: TimeRange
  ): Promise<InviteFunnel> {
    const stages = await this.db.prepare(`
      SELECT
        COUNT(DISTINCT i.code) as invites_created,
        COUNT(DISTINCT iv.invite_code) as invites_viewed,
        COUNT(DISTINCT iu.invite_code) as invites_used,
        COUNT(DISTINCT 
          CASE WHEN m.last_active_at > m.joined_at + 86400000 
          THEN m.user_id END
        ) as members_retained
      FROM invites i
      LEFT JOIN invite_views iv ON i.code = iv.invite_code
      LEFT JOIN invite_uses iu ON i.code = iu.invite_code
      LEFT JOIN waddle_members m ON iu.user_id = m.user_id 
        AND i.waddle_id = m.waddle_id
      WHERE i.waddle_id = ?
        AND i.created_at >= ?
        AND i.created_at <= ?
    `).bind(waddleId, timeRange.start, timeRange.end).first();
    
    return {
      created: stages.invites_created,
      viewed: stages.invites_viewed,
      used: stages.invites_used,
      retained: stages.members_retained,
      viewRate: stages.invites_created > 0 
        ? (stages.invites_viewed / stages.invites_created) * 100 
        : 0,
      conversionRate: stages.invites_viewed > 0 
        ? (stages.invites_used / stages.invites_viewed) * 100 
        : 0,
      retentionRate: stages.invites_used > 0 
        ? (stages.members_retained / stages.invites_used) * 100 
        : 0
    };
  }
}
```

### 5. Social Media Integration
```typescript
export class SocialInviteService {
  async generateSocialShare(
    inviteCode: string,
    platform: SocialPlatform
  ): Promise<SocialShareData> {
    const invite = await this.getInvite(inviteCode);
    const waddle = await this.getWaddle(invite.waddleId);
    
    const baseUrl = `${process.env.APP_URL}/invite/${inviteCode}`;
    const utm = `?utm_source=${platform}&utm_medium=social&utm_campaign=invite`;
    
    const templates = {
      twitter: {
        text: `Join me on ${waddle.name}! ${waddle.description.slice(0, 100)}...`,
        url: `${baseUrl}${utm}`,
        hashtags: ['waddle', ...waddle.tags.slice(0, 2)],
        via: 'waddlechat'
      },
      discord: {
        content: `Hey! Join **${waddle.name}** on Waddle!\n${waddle.description}\n\n${baseUrl}${utm}`
      },
      whatsapp: {
        text: `Join ${waddle.name} on Waddle! ${waddle.description}\n\n${baseUrl}${utm}`
      },
      telegram: {
        text: `Join ${waddle.name} on Waddle!\n\n${waddle.description}\n\n${baseUrl}${utm}`
      },
      email: {
        subject: `You're invited to ${waddle.name}`,
        body: this.generateEmailTemplate(waddle, invite, baseUrl + utm)
      }
    };
    
    const shareUrls = {
      twitter: `https://twitter.com/intent/tweet?${new URLSearchParams(templates.twitter)}`,
      whatsapp: `https://wa.me/?text=${encodeURIComponent(templates.whatsapp.text)}`,
      telegram: `https://t.me/share/url?url=${encodeURIComponent(baseUrl + utm)}&text=${encodeURIComponent(templates.telegram.text)}`,
      email: `mailto:?subject=${encodeURIComponent(templates.email.subject)}&body=${encodeURIComponent(templates.email.body)}`
    };
    
    // Generate Open Graph metadata
    const ogData = await this.generateOpenGraphData(waddle, invite);
    
    return {
      urls: shareUrls,
      templates,
      ogData,
      shortUrl: await this.shortenUrl(baseUrl + utm)
    };
  }
  
  private async generateOpenGraphData(
    waddle: Waddle,
    invite: Invite
  ): Promise<OpenGraphData> {
    // Generate dynamic OG image
    const ogImage = await this.generateOGImage({
      title: waddle.name,
      description: waddle.description,
      memberCount: waddle.memberCount,
      iconUrl: waddle.iconUrl,
      inviterName: await this.getUsername(invite.createdBy)
    });
    
    return {
      title: `Join ${waddle.name} on Waddle`,
      description: waddle.description,
      image: ogImage.url,
      url: `${process.env.APP_URL}/invite/${invite.code}`,
      type: 'website',
      site_name: 'Waddle',
      locale: 'en_US'
    };
  }
}
```

### 6. Invite Management UI
```tsx
export function InviteManager({ waddleId }: { waddleId: string }) {
  const [invites, setInvites] = useState<Invite[]>([]);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [analytics, setAnalytics] = useState<InviteAnalytics | null>(null);
  
  return (
    <div className="invite-manager">
      <div className="invite-header">
        <h2>Invite People</h2>
        <Button
          onClick={() => setShowCreateModal(true)}
          icon={<AddIcon />}
        >
          Create Invite
        </Button>
      </div>
      
      <Tabs>
        <TabList>
          <Tab>Active Invites</Tab>
          <Tab>Analytics</Tab>
          <Tab>Vanity URL</Tab>
        </TabList>
        
        <TabPanels>
          <TabPanel>
            <InviteList 
              invites={invites}
              onRevoke={handleRevoke}
              onEdit={handleEdit}
            />
          </TabPanel>
          
          <TabPanel>
            <InviteAnalyticsDashboard 
              waddleId={waddleId}
              analytics={analytics}
            />
          </TabPanel>
          
          <TabPanel>
            <VanityURLManager waddleId={waddleId} />
          </TabPanel>
        </TabPanels>
      </Tabs>
      
      {showCreateModal && (
        <CreateInviteModal
          waddleId={waddleId}
          onClose={() => setShowCreateModal(false)}
          onCreate={handleInviteCreated}
        />
      )}
    </div>
  );
}

function CreateInviteModal({ 
  waddleId, 
  onClose, 
  onCreate 
}: CreateInviteModalProps) {
  const [settings, setSettings] = useState<InviteSettings>({
    expiresIn: '24h',
    maxUses: null,
    targetRole: null,
    channelId: null,
    customMessage: ''
  });
  
  const handleCreate = async () => {
    const invite = await api.createInvite(waddleId, settings);
    onCreate(invite);
  };
  
  return (
    <Modal onClose={onClose} title="Create Invite Link">
      <div className="invite-settings">
        <FormField label="Expire After">
          <Select
            value={settings.expiresIn}
            onChange={(value) => setSettings({ ...settings, expiresIn: value })}
            options={[
              { value: '30m', label: '30 minutes' },
              { value: '1h', label: '1 hour' },
              { value: '6h', label: '6 hours' },
              { value: '12h', label: '12 hours' },
              { value: '24h', label: '1 day' },
              { value: '7d', label: '7 days' },
              { value: 'never', label: 'Never' }
            ]}
          />
        </FormField>
        
        <FormField label="Max Uses">
          <Input
            type="number"
            placeholder="No limit"
            value={settings.maxUses || ''}
            onChange={(e) => setSettings({ 
              ...settings, 
              maxUses: e.target.value ? parseInt(e.target.value) : null 
            })}
          />
        </FormField>
        
        <FormField label="Grant Role">
          <RoleSelect
            waddleId={waddleId}
            value={settings.targetRole}
            onChange={(roleId) => setSettings({ ...settings, targetRole: roleId })}
            placeholder="@everyone (default)"
          />
        </FormField>
        
        <FormField label="Landing Channel">
          <ChannelSelect
            waddleId={waddleId}
            value={settings.channelId}
            onChange={(channelId) => setSettings({ ...settings, channelId })}
            placeholder="Default channel"
          />
        </FormField>
        
        <FormField label="Welcome Message (optional)">
          <TextArea
            value={settings.customMessage}
            onChange={(e) => setSettings({ ...settings, customMessage: e.target.value })}
            placeholder="Add a personal message for invitees..."
            maxLength={200}
          />
        </FormField>
      </div>
      
      <div className="modal-footer">
        <Button variant="secondary" onClick={onClose}>
          Cancel
        </Button>
        <Button variant="primary" onClick={handleCreate}>
          Generate Link
        </Button>
      </div>
    </Modal>
  );
}

function InviteDisplay({ invite }: { invite: InviteResponse }) {
  const [showQR, setShowQR] = useState(false);
  const [copied, setCopied] = useState(false);
  
  const handleCopy = () => {
    navigator.clipboard.writeText(invite.url);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  
  return (
    <div className="invite-display">
      <div className="invite-url">
        <Input
          value={invite.url}
          readOnly
          onFocus={(e) => e.target.select()}
        />
        <Button
          onClick={handleCopy}
          variant="secondary"
          icon={copied ? <CheckIcon /> : <CopyIcon />}
        >
          {copied ? 'Copied!' : 'Copy'}
        </Button>
      </div>
      
      <div className="invite-actions">
        <Button
          onClick={() => setShowQR(!showQR)}
          variant="secondary"
          icon={<QRCodeIcon />}
        >
          QR Code
        </Button>
        
        <SocialShareButtons inviteUrl={invite.url} />
      </div>
      
      {showQR && (
        <div className="qr-display">
          <img src={invite.qrCode} alt="Invite QR Code" />
          <Button
            onClick={() => downloadImage(invite.qrCode, 'invite-qr.png')}
            variant="secondary"
            size="small"
          >
            Download QR
          </Button>
        </div>
      )}
      
      <div className="invite-info">
        {invite.expiresAt && (
          <span>Expires {formatRelativeTime(invite.expiresAt)}</span>
        )}
        {invite.maxUses && (
          <span>Max {invite.maxUses} uses</span>
        )}
      </div>
    </div>
  );
}
```

## Dependencies
- Permission System (Issue #23) for invite permissions
- Analytics Service (Issue #61) for tracking
- QR Code Library for generation
- Social Media APIs for integration

## Estimated Effort
**5 days**
- 1 day: Core invite service and validation
- 1 day: Vanity URL system
- 1 day: QR code and social sharing
- 1 day: Analytics and tracking
- 1 day: UI components and testing

## Notes
- Implement invite abuse detection
- Add bulk invite generation for campaigns
- Consider time-zone aware expiration display
- Add invite templates for common use cases
- Monitor for spam and implement rate limits