# Issue #28: Push Notifications (FCM)

## User Story
As an **Android user**, I want to **receive timely notifications about messages and activities** so that **I stay connected with my waddles even when the app is closed**.

## Description
Implement Firebase Cloud Messaging (FCM) for push notifications on Android, including message notifications, mention alerts, voice channel invites, and waddle updates. This includes notification grouping, rich media support, and quick actions.

## Acceptance Criteria
- [ ] FCM integration and token management
- [ ] Message notifications with preview
- [ ] Notification grouping by waddle
- [ ] Rich media in notifications
- [ ] Quick reply from notifications
- [ ] Voice call notifications
- [ ] Notification channels configuration
- [ ] Do Not Disturb respect

## Technical Implementation

### 1. FCM Service Setup
```kotlin
// FCM Service
@AndroidEntryPoint
class WaddleFCMService : FirebaseMessagingService() {
    @Inject lateinit var notificationManager: WaddleNotificationManager
    @Inject lateinit var authRepository: AuthRepository
    @Inject lateinit var messageRepository: MessageRepository
    @Inject lateinit var analyticsService: AnalyticsService
    
    override fun onNewToken(token: String) {
        super.onNewToken(token)
        Log.d(TAG, "FCM token refreshed: $token")
        
        // Update token on server
        lifecycleScope.launch {
            try {
                authRepository.updateFCMToken(token)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to update FCM token", e)
            }
        }
    }
    
    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        super.onMessageReceived(remoteMessage)
        
        // Log notification analytics
        analyticsService.logNotificationReceived(
            type = remoteMessage.data["type"] ?: "unknown",
            waddleId = remoteMessage.data["waddle_id"]
        )
        
        // Handle different notification types
        when (remoteMessage.data["type"]) {
            "message" -> handleMessageNotification(remoteMessage)
            "mention" -> handleMentionNotification(remoteMessage)
            "voice_invite" -> handleVoiceInviteNotification(remoteMessage)
            "waddle_update" -> handleWaddleUpdateNotification(remoteMessage)
            "friend_request" -> handleFriendRequestNotification(remoteMessage)
            else -> handleGenericNotification(remoteMessage)
        }
    }
    
    private fun handleMessageNotification(remoteMessage: RemoteMessage) {
        val data = remoteMessage.data
        
        val message = NotificationMessage(
            id = data["message_id"] ?: return,
            channelId = data["channel_id"] ?: return,
            waddleId = data["waddle_id"] ?: return,
            waddleName = data["waddle_name"] ?: "Waddle",
            channelName = data["channel_name"] ?: "Channel",
            authorId = data["author_id"] ?: return,
            authorName = data["author_name"] ?: "Someone",
            authorAvatar = data["author_avatar"],
            content = data["message"] ?: "",
            timestamp = data["timestamp"]?.toLongOrNull() ?: System.currentTimeMillis(),
            attachmentUrl = data["attachment_url"],
            attachmentType = data["attachment_type"]
        )
        
        // Check if user wants notifications for this waddle
        lifecycleScope.launch {
            val settings = notificationManager.getNotificationSettings(message.waddleId)
            if (!settings.messagesEnabled) return@launch
            
            // Don't show if app is in foreground and user is in the same channel
            if (isAppInForeground() && isUserInChannel(message.channelId)) {
                return@launch
            }
            
            notificationManager.showMessageNotification(message)
        }
    }
    
    private fun handleVoiceInviteNotification(remoteMessage: RemoteMessage) {
        val data = remoteMessage.data
        
        val invite = VoiceInvite(
            channelId = data["channel_id"] ?: return,
            waddleId = data["waddle_id"] ?: return,
            waddleName = data["waddle_name"] ?: "Waddle",
            channelName = data["channel_name"] ?: "Voice Channel",
            inviterId = data["inviter_id"] ?: return,
            inviterName = data["inviter_name"] ?: "Someone",
            inviterAvatar = data["inviter_avatar"],
            expiresAt = data["expires_at"]?.toLongOrNull() ?: (System.currentTimeMillis() + 60000)
        )
        
        notificationManager.showVoiceInviteNotification(invite)
    }
    
    companion object {
        private const val TAG = "WaddleFCMService"
    }
}

// Notification Manager
@Singleton
class WaddleNotificationManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val notificationRepository: NotificationRepository,
    private val resourceProvider: ResourceProvider
) {
    private val notificationManager = NotificationManagerCompat.from(context)
    private val messageNotifications = mutableMapOf<String, MutableList<NotificationMessage>>()
    
    init {
        createNotificationChannels()
    }
    
    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channels = listOf(
                NotificationChannel(
                    CHANNEL_MESSAGES,
                    "Messages",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    description = "New message notifications"
                    enableLights(true)
                    lightColor = Color.BLUE
                    enableVibration(true)
                    setShowBadge(true)
                },
                
                NotificationChannel(
                    CHANNEL_MENTIONS,
                    "Mentions",
                    NotificationManager.IMPORTANCE_HIGH
                ).apply {
                    description = "Notifications when you're mentioned"
                    enableLights(true)
                    lightColor = Color.GREEN
                    enableVibration(true)
                    setSound(
                        Uri.parse("android.resource://${context.packageName}/raw/mention"),
                        audioAttributes
                    )
                },
                
                NotificationChannel(
                    CHANNEL_VOICE,
                    "Voice Calls",
                    NotificationManager.IMPORTANCE_MAX
                ).apply {
                    description = "Voice call invitations"
                    enableLights(true)
                    lightColor = Color.RED
                    enableVibration(true)
                    vibrationPattern = longArrayOf(0, 500, 200, 500)
                    setSound(
                        Uri.parse("android.resource://${context.packageName}/raw/ringtone"),
                        audioAttributes
                    )
                    setBypassDnd(true)
                },
                
                NotificationChannel(
                    CHANNEL_WADDLE_UPDATES,
                    "Waddle Updates",
                    NotificationManager.IMPORTANCE_DEFAULT
                ).apply {
                    description = "Updates about your waddles"
                    setShowBadge(false)
                }
            )
            
            notificationManager.createNotificationChannels(channels)
        }
    }
    
    suspend fun showMessageNotification(message: NotificationMessage) {
        // Add to grouped notifications
        val waddleMessages = messageNotifications.getOrPut(message.waddleId) { mutableListOf() }
        waddleMessages.add(message)
        
        // Create notification
        val notification = if (waddleMessages.size == 1) {
            createSingleMessageNotification(message)
        } else {
            createGroupedMessageNotification(message.waddleId, waddleMessages)
        }
        
        // Show notification
        notificationManager.notify(
            message.waddleId,
            getNotificationId(message.waddleId),
            notification
        )
        
        // Also show summary notification for the group
        if (waddleMessages.size > 1) {
            val summaryNotification = createSummaryNotification(message.waddleId, waddleMessages)
            notificationManager.notify(
                message.waddleId,
                SUMMARY_ID,
                summaryNotification
            )
        }
    }
    
    private fun createSingleMessageNotification(message: NotificationMessage): Notification {
        val channelPendingIntent = createChannelPendingIntent(message.waddleId, message.channelId)
        val replyPendingIntent = createReplyPendingIntent(message)
        
        val builder = NotificationCompat.Builder(context, CHANNEL_MESSAGES)
            .setSmallIcon(R.drawable.ic_notification)
            .setLargeIcon(loadBitmap(message.authorAvatar))
            .setContentTitle(message.authorName)
            .setContentText(message.content)
            .setSubText("${message.waddleName} â€¢ #${message.channelName}")
            .setWhen(message.timestamp)
            .setShowWhen(true)
            .setAutoCancel(true)
            .setContentIntent(channelPendingIntent)
            .setGroup(message.waddleId)
            .setCategory(NotificationCompat.CATEGORY_MESSAGE)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            
        // Add message style for better display
        val messagingStyle = NotificationCompat.MessagingStyle(
            Person.Builder()
                .setName("You")
                .build()
        ).apply {
            addMessage(
                message.content,
                message.timestamp,
                Person.Builder()
                    .setName(message.authorName)
                    .setIcon(IconCompat.createWithBitmap(loadBitmap(message.authorAvatar)))
                    .build()
            )
        }
        builder.setStyle(messagingStyle)
            
        // Add attachment preview if present
        message.attachmentUrl?.let { url ->
            when (message.attachmentType) {
                "image" -> {
                    val bitmap = loadBitmap(url)
                    if (bitmap != null) {
                        builder.setStyle(
                            NotificationCompat.BigPictureStyle()
                                .bigPicture(bitmap)
                                .setBigContentTitle(message.authorName)
                                .setSummaryText(message.content)
                        )
                    }
                }
            }
        }
        
        // Add quick reply action
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            val replyInput = RemoteInput.Builder(KEY_REPLY_TEXT)
                .setLabel("Reply to ${message.authorName}")
                .build()
                
            val replyAction = NotificationCompat.Action.Builder(
                R.drawable.ic_reply,
                "Reply",
                replyPendingIntent
            )
                .addRemoteInput(replyInput)
                .setAllowGeneratedReplies(true)
                .build()
                
            builder.addAction(replyAction)
        }
        
        // Add mark as read action
        val markReadAction = NotificationCompat.Action.Builder(
            R.drawable.ic_mark_read,
            "Mark as Read",
            createMarkAsReadPendingIntent(message)
        ).build()
        
        builder.addAction(markReadAction)
        
        return builder.build()
    }
    
    private fun createGroupedMessageNotification(
        waddleId: String,
        messages: List<NotificationMessage>
    ): Notification {
        val waddle = messages.first()
        val latestMessage = messages.last()
        
        val builder = NotificationCompat.Builder(context, CHANNEL_MESSAGES)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(waddle.waddleName)
            .setContentText("${messages.size} new messages")
            .setSubText(waddle.waddleName)
            .setWhen(latestMessage.timestamp)
            .setShowWhen(true)
            .setAutoCancel(true)
            .setGroup(waddleId)
            .setGroupSummary(false)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            
        // Create inbox style for multiple messages
        val inboxStyle = NotificationCompat.InboxStyle()
            .setBigContentTitle("${messages.size} new messages")
            .setSummaryText(waddle.waddleName)
            
        messages.takeLast(7).forEach { msg ->
            inboxStyle.addLine("${msg.authorName}: ${msg.content}")
        }
        
        if (messages.size > 7) {
            inboxStyle.addLine("+ ${messages.size - 7} more messages")
        }
        
        builder.setStyle(inboxStyle)
        
        return builder.build()
    }
    
    companion object {
        const val CHANNEL_MESSAGES = "waddle_messages"
        const val CHANNEL_MENTIONS = "waddle_mentions"
        const val CHANNEL_VOICE = "waddle_voice"
        const val CHANNEL_WADDLE_UPDATES = "waddle_updates"
        
        const val KEY_REPLY_TEXT = "reply_text"
        const val SUMMARY_ID = 0
        
        private val audioAttributes = AudioAttributes.Builder()
            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
            .setUsage(AudioAttributes.USAGE_NOTIFICATION)
            .build()
    }
}
```

### 2. Rich Notifications
```kotlin
// Voice Invite Notification
fun showVoiceInviteNotification(invite: VoiceInvite) {
    val joinIntent = createVoiceJoinIntent(invite)
    val declineIntent = createVoiceDeclineIntent(invite)
    
    // Create full-screen intent for incoming calls
    val fullScreenIntent = PendingIntent.getActivity(
        context,
        0,
        Intent(context, IncomingCallActivity::class.java).apply {
            putExtra("invite", invite)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_FULL_SCREEN_INTENT
        },
        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    )
    
    val notification = NotificationCompat.Builder(context, CHANNEL_VOICE)
        .setSmallIcon(R.drawable.ic_voice_call)
        .setLargeIcon(loadBitmap(invite.inviterAvatar))
        .setContentTitle("${invite.inviterName} is calling")
        .setContentText("Voice call in ${invite.channelName}")
        .setSubText(invite.waddleName)
        .setPriority(NotificationCompat.PRIORITY_MAX)
        .setCategory(NotificationCompat.CATEGORY_CALL)
        .setFullScreenIntent(fullScreenIntent, true)
        .setAutoCancel(true)
        .setTimeoutAfter(60000) // 1 minute timeout
        .setOngoing(true)
        .setVibrate(longArrayOf(0, 500, 200, 500))
        .addAction(
            R.drawable.ic_call_decline,
            "Decline",
            declineIntent
        )
        .addAction(
            R.drawable.ic_call_accept,
            "Join",
            joinIntent
        )
        .build()
        
    notificationManager.notify(VOICE_INVITE_ID, notification)
    
    // Schedule automatic dismissal
    handler.postDelayed({
        notificationManager.cancel(VOICE_INVITE_ID)
    }, 60000)
}

// Friend Request Notification
fun showFriendRequestNotification(request: FriendRequest) {
    val acceptIntent = createAcceptFriendIntent(request)
    val declineIntent = createDeclineFriendIntent(request)
    val profileIntent = createProfileIntent(request.fromUserId)
    
    val notification = NotificationCompat.Builder(context, CHANNEL_SOCIAL)
        .setSmallIcon(R.drawable.ic_friend_request)
        .setLargeIcon(loadBitmap(request.fromUserAvatar))
        .setContentTitle("Friend Request")
        .setContentText("${request.fromUserName} wants to be your friend")
        .setContentIntent(profileIntent)
        .setAutoCancel(true)
        .setPriority(NotificationCompat.PRIORITY_HIGH)
        .addAction(
            R.drawable.ic_check,
            "Accept",
            acceptIntent
        )
        .addAction(
            R.drawable.ic_close,
            "Decline",
            declineIntent
        )
        .build()
        
    notificationManager.notify(
        "friend_${request.fromUserId}",
        FRIEND_REQUEST_ID,
        notification
    )
}
```

### 3. Notification Actions Handler
```kotlin
// Broadcast Receiver for notification actions
@AndroidEntryPoint
class NotificationActionReceiver : BroadcastReceiver() {
    @Inject lateinit var messageRepository: MessageRepository
    @Inject lateinit var voiceService: VoiceServiceConnection
    @Inject lateinit var notificationManager: WaddleNotificationManager
    
    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            ACTION_REPLY -> handleReply(context, intent)
            ACTION_MARK_READ -> handleMarkAsRead(intent)
            ACTION_JOIN_VOICE -> handleJoinVoice(intent)
            ACTION_DECLINE_VOICE -> handleDeclineVoice(intent)
            ACTION_ACCEPT_FRIEND -> handleAcceptFriend(intent)
            ACTION_DECLINE_FRIEND -> handleDeclineFriend(intent)
        }
    }
    
    private fun handleReply(context: Context, intent: Intent) {
        val message = intent.getParcelableExtra<NotificationMessage>("message") ?: return
        val replyText = RemoteInput.getResultsFromIntent(intent)
            ?.getCharSequence(WaddleNotificationManager.KEY_REPLY_TEXT)
            ?.toString() ?: return
            
        // Show "Sending..." notification
        val sendingNotification = NotificationCompat.Builder(context, CHANNEL_MESSAGES)
            .setSmallIcon(R.drawable.ic_sending)
            .setContentTitle("Sending reply...")
            .setProgress(0, 0, true)
            .build()
            
        notificationManager.notify(REPLY_ID, sendingNotification)
        
        // Send message
        goAsync {
            try {
                val sentMessage = messageRepository.sendMessage(
                    channelId = message.channelId,
                    content = replyText
                )
                
                // Update notification to show success
                val successNotification = NotificationCompat.Builder(context, CHANNEL_MESSAGES)
                    .setSmallIcon(R.drawable.ic_sent)
                    .setContentTitle("Reply sent")
                    .setContentText(replyText)
                    .setTimeoutAfter(3000)
                    .build()
                    
                notificationManager.notify(REPLY_ID, successNotification)
                
                // Clear original notification
                notificationManager.cancel(
                    message.waddleId,
                    getNotificationId(message.waddleId)
                )
                
            } catch (e: Exception) {
                // Show error notification
                val errorNotification = NotificationCompat.Builder(context, CHANNEL_MESSAGES)
                    .setSmallIcon(R.drawable.ic_error)
                    .setContentTitle("Failed to send reply")
                    .setContentText("Tap to try again")
                    .build()
                    
                notificationManager.notify(REPLY_ID, errorNotification)
            }
        }
    }
    
    private fun handleJoinVoice(intent: Intent) {
        val invite = intent.getParcelableExtra<VoiceInvite>("invite") ?: return
        
        // Start voice service
        voiceService.startVoiceService(
            channelId = invite.channelId,
            waddleId = invite.waddleId,
            token = "" // Get token from auth
        )
        
        // Open voice activity
        val voiceIntent = Intent(context, VoiceChannelActivity::class.java).apply {
            putExtra("channel_id", invite.channelId)
            putExtra("waddle_id", invite.waddleId)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK
        }
        context.startActivity(voiceIntent)
        
        // Clear notification
        notificationManager.cancel(VOICE_INVITE_ID)
    }
    
    companion object {
        const val ACTION_REPLY = "com.waddle.android.REPLY"
        const val ACTION_MARK_READ = "com.waddle.android.MARK_READ"
        const val ACTION_JOIN_VOICE = "com.waddle.android.JOIN_VOICE"
        const val ACTION_DECLINE_VOICE = "com.waddle.android.DECLINE_VOICE"
        const val ACTION_ACCEPT_FRIEND = "com.waddle.android.ACCEPT_FRIEND"
        const val ACTION_DECLINE_FRIEND = "com.waddle.android.DECLINE_FRIEND"
    }
}
```

### 4. Notification Settings UI
```kotlin
@Composable
fun NotificationSettingsScreen(
    viewModel: NotificationSettingsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    LazyColumn(
        contentPadding = PaddingValues(vertical = 8.dp)
    ) {
        item {
            SettingsSection(title = "Global Notifications") {
                SwitchPreference(
                    title = "Enable Notifications",
                    summary = "Receive notifications from Waddle",
                    checked = uiState.globalEnabled,
                    onCheckedChange = viewModel::setGlobalEnabled
                )
                
                AnimatedVisibility(visible = uiState.globalEnabled) {
                    Column {
                        SwitchPreference(
                            title = "Message Notifications",
                            summary = "New messages in your waddles",
                            checked = uiState.messagesEnabled,
                            onCheckedChange = viewModel::setMessagesEnabled
                        )
                        
                        SwitchPreference(
                            title = "Mention Notifications",
                            summary = "When someone mentions you",
                            checked = uiState.mentionsEnabled,
                            onCheckedChange = viewModel::setMentionsEnabled
                        )
                        
                        SwitchPreference(
                            title = "Voice Call Notifications",
                            summary = "Incoming voice call invitations",
                            checked = uiState.voiceEnabled,
                            onCheckedChange = viewModel::setVoiceEnabled
                        )
                    }
                }
            }
        }
        
        item {
            SettingsSection(title = "Notification Behavior") {
                ListPreference(
                    title = "Notification Sound",
                    summary = uiState.notificationSound.name,
                    value = uiState.notificationSound,
                    onValueChange = viewModel::setNotificationSound,
                    entries = NotificationSound.values().toList()
                )
                
                SwitchPreference(
                    title = "Vibrate",
                    summary = "Vibrate for notifications",
                    checked = uiState.vibrateEnabled,
                    onCheckedChange = viewModel::setVibrateEnabled
                )
                
                SwitchPreference(
                    title = "LED Light",
                    summary = "Blink LED for notifications",
                    checked = uiState.ledEnabled,
                    onCheckedChange = viewModel::setLedEnabled
                )
                
                SwitchPreference(
                    title = "High Priority",
                    summary = "Show notifications on top of screen",
                    checked = uiState.highPriority,
                    onCheckedChange = viewModel::setHighPriority
                )
            }
        }
        
        item {
            SettingsSection(title = "Quiet Hours") {
                SwitchPreference(
                    title = "Enable Quiet Hours",
                    summary = "Mute notifications during specified times",
                    checked = uiState.quietHoursEnabled,
                    onCheckedChange = viewModel::setQuietHoursEnabled
                )
                
                AnimatedVisibility(visible = uiState.quietHoursEnabled) {
                    Column {
                        TimePreference(
                            title = "Start Time",
                            summary = uiState.quietHoursStart.format(),
                            value = uiState.quietHoursStart,
                            onValueChange = viewModel::setQuietHoursStart
                        )
                        
                        TimePreference(
                            title = "End Time",
                            summary = uiState.quietHoursEnd.format(),
                            value = uiState.quietHoursEnd,
                            onValueChange = viewModel::setQuietHoursEnd
                        )
                    }
                }
            }
        }
        
        item {
            SettingsSection(title = "Per-Waddle Settings") {
                Text(
                    text = "Configure notifications for each waddle",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )
                
                uiState.waddleSettings.forEach { (waddle, settings) ->
                    WaddleNotificationItem(
                        waddle = waddle,
                        settings = settings,
                        onSettingsChange = { newSettings ->
                            viewModel.setWaddleSettings(waddle.id, newSettings)
                        }
                    )
                }
            }
        }
        
        item {
            // System notification settings link
            Card(
                onClick = { openSystemNotificationSettings() },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column {
                        Text(
                            text = "System Notification Settings",
                            style = MaterialTheme.typography.titleMedium
                        )
                        Text(
                            text = "Advanced notification controls",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    Icon(
                        Icons.Default.OpenInNew,
                        contentDescription = null
                    )
                }
            }
        }
    }
}

@Composable
fun WaddleNotificationItem(
    waddle: Waddle,
    settings: WaddleNotificationSettings,
    onSettingsChange: (WaddleNotificationSettings) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp)
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { expanded = !expanded }
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    AsyncImage(
                        model = waddle.iconUrl,
                        contentDescription = null,
                        modifier = Modifier
                            .size(40.dp)
                            .clip(RoundedCornerShape(8.dp))
                    )
                    
                    Column {
                        Text(
                            text = waddle.name,
                            style = MaterialTheme.typography.titleSmall
                        )
                        Text(
                            text = if (settings.enabled) "Notifications on" else "Notifications off",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                
                IconButton(onClick = { expanded = !expanded }) {
                    Icon(
                        imageVector = if (expanded) {
                            Icons.Default.ExpandLess
                        } else {
                            Icons.Default.ExpandMore
                        },
                        contentDescription = null
                    )
                }
            }
            
            AnimatedVisibility(visible = expanded) {
                Column(
                    modifier = Modifier.padding(
                        start = 16.dp,
                        end = 16.dp,
                        bottom = 16.dp
                    )
                ) {
                    SwitchPreference(
                        title = "Enable Notifications",
                        checked = settings.enabled,
                        onCheckedChange = { enabled ->
                            onSettingsChange(settings.copy(enabled = enabled))
                        }
                    )
                    
                    AnimatedVisibility(visible = settings.enabled) {
                        Column {
                            SwitchPreference(
                                title = "All Messages",
                                checked = settings.allMessages,
                                onCheckedChange = { allMessages ->
                                    onSettingsChange(settings.copy(allMessages = allMessages))
                                }
                            )
                            
                            SwitchPreference(
                                title = "Only Mentions",
                                checked = settings.mentionsOnly,
                                onCheckedChange = { mentionsOnly ->
                                    onSettingsChange(settings.copy(mentionsOnly = mentionsOnly))
                                },
                                enabled = !settings.allMessages
                            )
                            
                            SwitchPreference(
                                title = "Mute @everyone",
                                checked = settings.muteEveryone,
                                onCheckedChange = { muteEveryone ->
                                    onSettingsChange(settings.copy(muteEveryone = muteEveryone))
                                }
                            )
                        }
                    }
                }
            }
        }
    }
}
```

### 5. Notification Analytics
```kotlin
// Analytics tracking for notifications
@Singleton
class NotificationAnalytics @Inject constructor(
    private val analytics: FirebaseAnalytics
) {
    fun trackNotificationReceived(type: String, waddleId: String?) {
        analytics.logEvent("notification_received") {
            param("notification_type", type)
            waddleId?.let { param("waddle_id", it) }
        }
    }
    
    fun trackNotificationOpened(type: String, waddleId: String?, action: String?) {
        analytics.logEvent("notification_opened") {
            param("notification_type", type)
            waddleId?.let { param("waddle_id", it) }
            action?.let { param("action_taken", it) }
        }
    }
    
    fun trackNotificationDismissed(type: String, waddleId: String?) {
        analytics.logEvent("notification_dismissed") {
            param("notification_type", type)
            waddleId?.let { param("waddle_id", it) }
        }
    }
    
    fun trackQuickReply(success: Boolean, responseTime: Long) {
        analytics.logEvent("notification_quick_reply") {
            param("success", success)
            param("response_time_ms", responseTime)
        }
    }
}
```

## Dependencies
- Firebase Cloud Messaging
- AndroidX Work Manager
- Notification Compat
- Coil for image loading in notifications

## Estimated Effort
**4 days**
- 1 day: FCM setup and token management
- 1 day: Notification types and rich content
- 1 day: Quick actions and reply functionality
- 1 day: Settings UI and per-waddle configuration

## Notes
- Handle notification permissions for Android 13+
- Test notification grouping behavior
- Implement notification badges
- Consider notification importance levels
- Add notification history/log