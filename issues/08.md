# Issue #08: Real-time Features (Typing & Presence)

## User Story
As a **user**, I want to **see when others are typing and who's online** so that **I can have more natural, real-time conversations**.

## Description
Implement real-time presence indicators and typing notifications using Durable Objects' WebSocket capabilities. This includes online/offline status, typing indicators, and "user is viewing" indicators for threads.

## Acceptance Criteria
- [ ] Users see who's currently online in a waddle
- [ ] Typing indicators show when someone is composing a message
- [ ] Presence updates within 1 second of status change
- [ ] Typing indicators timeout after 3 seconds of inactivity
- [ ] "Viewing thread" indicators for better awareness
- [ ] Presence persists across page refreshes
- [ ] Privacy settings allow users to hide presence
- [ ] Mobile app maintains presence in background

## Technical Implementation

### 1. Presence State Management
```javascript
export class PresenceDurableObject {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.presenceMap = new Map(); // userId -> presence data
    this.typingMap = new Map(); // channelId -> Set of userIds
    this.viewingMap = new Map(); // threadId -> Set of userIds
  }
  
  async handlePresenceUpdate(ws, data) {
    const attachment = ws.deserializeAttachment();
    const { userId } = attachment;
    
    const presence = {
      userId,
      status: data.status || 'online', // online, idle, dnd, offline
      statusText: data.statusText,
      lastSeen: Date.now(),
      device: data.device || 'web',
      activities: data.activities || []
    };
    
    // Check privacy settings
    const privacy = await this.getUserPrivacy(userId);
    if (privacy.hidePresence) {
      presence.status = 'offline';
      delete presence.statusText;
      delete presence.activities;
    }
    
    // Update presence
    this.presenceMap.set(userId, presence);
    
    // Store in state for persistence
    await this.state.storage.put(`presence:${userId}`, presence);
    
    // Broadcast to relevant users
    await this.broadcastPresence(userId, presence);
    
    // Set idle timeout
    this.setIdleTimeout(userId);
  }
  
  setIdleTimeout(userId) {
    // Clear existing timeout
    const existingTimeout = this.timeouts.get(userId);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
    }
    
    // Set new timeout for idle status (5 minutes)
    const timeout = setTimeout(() => {
      this.updateStatus(userId, 'idle');
    }, 300000);
    
    this.timeouts.set(userId, timeout);
  }
  
  async updateStatus(userId, status) {
    const presence = this.presenceMap.get(userId);
    if (presence && presence.status !== status) {
      presence.status = status;
      presence.lastSeen = Date.now();
      
      await this.state.storage.put(`presence:${userId}`, presence);
      await this.broadcastPresence(userId, presence);
    }
  }
  
  async broadcastPresence(userId, presence) {
    // Get user's waddles
    const waddles = await this.getUserWaddles(userId);
    
    const update = JSON.stringify({
      type: 'presence_update',
      userId,
      presence
    });
    
    // Broadcast to all connections in user's waddles
    for (const ws of this.state.getWebSockets()) {
      const wsAttachment = ws.deserializeAttachment();
      if (waddles.some(w => wsAttachment.waddles?.includes(w))) {
        try {
          ws.send(update);
        } catch (err) {
          // Connection closed
        }
      }
    }
  }
}
```

### 2. Typing Indicators Implementation
```javascript
export class TypingIndicatorManager {
  constructor(channelDO) {
    this.channelDO = channelDO;
    this.typingUsers = new Map(); // userId -> timeout
  }
  
  async handleTypingStart(userId, channelId) {
    // Clear existing timeout
    this.clearTypingTimeout(userId);
    
    // Add to typing set
    if (!this.typingUsers.has(userId)) {
      this.typingUsers.set(userId, null);
      await this.broadcastTypingUpdate(channelId);
    }
    
    // Set timeout to auto-remove after 3 seconds
    const timeout = setTimeout(() => {
      this.handleTypingStop(userId, channelId);
    }, 3000);
    
    this.typingUsers.set(userId, timeout);
  }
  
  async handleTypingStop(userId, channelId) {
    this.clearTypingTimeout(userId);
    
    if (this.typingUsers.delete(userId)) {
      await this.broadcastTypingUpdate(channelId);
    }
  }
  
  clearTypingTimeout(userId) {
    const timeout = this.typingUsers.get(userId);
    if (timeout) {
      clearTimeout(timeout);
    }
  }
  
  async broadcastTypingUpdate(channelId) {
    // Get user details for typing users
    const typingList = await this.getTypingUserDetails();
    
    const update = JSON.stringify({
      type: 'typing_update',
      channelId,
      users: typingList
    });
    
    // Broadcast to all channel participants
    for (const ws of this.channelDO.state.getWebSockets()) {
      try {
        ws.send(update);
      } catch (err) {
        // Connection closed
      }
    }
  }
  
  async getTypingUserDetails() {
    const userIds = Array.from(this.typingUsers.keys());
    if (userIds.length === 0) return [];
    
    // Batch fetch user details
    const users = await this.channelDO.env.USERS_DB.prepare(`
      SELECT id, username, avatar_url
      FROM users
      WHERE id IN (${userIds.map(() => '?').join(',')})
    `).bind(...userIds).all();
    
    return users.results;
  }
}
```

### 3. Thread Viewing Indicators
```javascript
export class ThreadViewingTracker {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.viewers = new Map(); // threadId -> Map(userId -> timestamp)
  }
  
  async trackViewing(threadId, userId, isViewing) {
    if (!this.viewers.has(threadId)) {
      this.viewers.set(threadId, new Map());
    }
    
    const threadViewers = this.viewers.get(threadId);
    
    if (isViewing) {
      threadViewers.set(userId, Date.now());
      
      // Set timeout to auto-remove after 30 seconds
      setTimeout(() => {
        this.trackViewing(threadId, userId, false);
      }, 30000);
    } else {
      threadViewers.delete(userId);
      
      // Clean up empty maps
      if (threadViewers.size === 0) {
        this.viewers.delete(threadId);
      }
    }
    
    // Broadcast update
    await this.broadcastViewers(threadId);
  }
  
  async broadcastViewers(threadId) {
    const viewers = this.viewers.get(threadId) || new Map();
    const viewerIds = Array.from(viewers.keys());
    
    // Get viewer details
    const viewerDetails = await this.getUserDetails(viewerIds);
    
    const update = JSON.stringify({
      type: 'thread_viewers',
      threadId,
      viewers: viewerDetails.map(user => ({
        ...user,
        viewingSince: viewers.get(user.id)
      }))
    });
    
    // Broadcast to thread participants
    await this.broadcastToThread(threadId, update);
  }
}
```

### 4. Client-side Implementation
```typescript
// React hooks for presence
export function usePresence(waddleId: string) {
  const [onlineUsers, setOnlineUsers] = useState<Map<string, Presence>>(new Map());
  const ws = useWebSocket();
  
  useEffect(() => {
    // Request initial presence state
    ws.send({
      type: 'get_presence',
      waddleId
    });
    
    // Listen for updates
    const unsubscribe = ws.on('presence_update', (data) => {
      setOnlineUsers(prev => {
        const updated = new Map(prev);
        if (data.presence.status === 'offline') {
          updated.delete(data.userId);
        } else {
          updated.set(data.userId, data.presence);
        }
        return updated;
      });
    });
    
    // Send heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      ws.send({
        type: 'presence_heartbeat'
      });
    }, 30000);
    
    return () => {
      unsubscribe();
      clearInterval(heartbeat);
    };
  }, [waddleId]);
  
  return {
    onlineUsers: Array.from(onlineUsers.values()),
    onlineCount: onlineUsers.size,
    isUserOnline: (userId: string) => onlineUsers.has(userId)
  };
}

// Typing indicator hook
export function useTypingIndicator(channelId: string) {
  const [typingUsers, setTypingUsers] = useState<User[]>([]);
  const ws = useWebSocket();
  const typingTimeoutRef = useRef<NodeJS.Timeout>();
  
  const startTyping = useCallback(() => {
    ws.send({
      type: 'typing_start',
      channelId
    });
    
    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set new timeout
    typingTimeoutRef.current = setTimeout(() => {
      ws.send({
        type: 'typing_stop',
        channelId
      });
    }, 2500);
  }, [channelId]);
  
  useEffect(() => {
    const unsubscribe = ws.on('typing_update', (data) => {
      if (data.channelId === channelId) {
        setTypingUsers(data.users.filter(u => u.id !== currentUserId));
      }
    });
    
    return () => {
      unsubscribe();
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
    };
  }, [channelId]);
  
  return {
    typingUsers,
    startTyping,
    typingText: getTypingText(typingUsers)
  };
}

function getTypingText(users: User[]): string {
  if (users.length === 0) return '';
  if (users.length === 1) return `${users[0].username} is typing...`;
  if (users.length === 2) return `${users[0].username} and ${users[1].username} are typing...`;
  return `${users[0].username} and ${users.length - 1} others are typing...`;
}
```

### 5. Presence UI Components
```tsx
// Online users sidebar
export function OnlineUsersList({ waddleId }: { waddleId: string }) {
  const { onlineUsers } = usePresence(waddleId);
  
  const groupedUsers = useMemo(() => {
    const groups = {
      online: [] as User[],
      idle: [] as User[],
      dnd: [] as User[]
    };
    
    onlineUsers.forEach(user => {
      groups[user.status]?.push(user);
    });
    
    return groups;
  }, [onlineUsers]);
  
  return (
    <div className="online-users">
      <h3>Online — {onlineUsers.length}</h3>
      
      {Object.entries(groupedUsers).map(([status, users]) => (
        users.length > 0 && (
          <div key={status} className="presence-group">
            <h4>{status.toUpperCase()} — {users.length}</h4>
            {users.map(user => (
              <UserPresenceItem key={user.id} user={user} />
            ))}
          </div>
        )
      ))}
    </div>
  );
}

// Individual user presence item
function UserPresenceItem({ user }: { user: User & Presence }) {
  return (
    <div className="user-presence-item">
      <Avatar user={user} />
      <StatusIndicator status={user.status} />
      <div className="user-info">
        <span className="username">{user.username}</span>
        {user.statusText && (
          <span className="status-text">{user.statusText}</span>
        )}
        {user.activities?.map(activity => (
          <ActivityBadge key={activity.id} activity={activity} />
        ))}
      </div>
    </div>
  );
}

// Typing indicator component
export function TypingIndicator({ channelId }: { channelId: string }) {
  const { typingUsers, typingText } = useTypingIndicator(channelId);
  
  if (typingUsers.length === 0) return null;
  
  return (
    <div className="typing-indicator">
      <div className="typing-dots">
        <span></span>
        <span></span>
        <span></span>
      </div>
      <span className="typing-text">{typingText}</span>
    </div>
  );
}
```

### 6. Mobile Background Presence
```kotlin
// Android background service
class PresenceService : Service() {
    private lateinit var webSocketManager: WebSocketManager
    private val handler = Handler(Looper.getMainLooper())
    private var heartbeatRunnable: Runnable? = null
    
    override fun onCreate() {
        super.onCreate()
        webSocketManager = WebSocketManager.getInstance()
        startHeartbeat()
    }
    
    private fun startHeartbeat() {
        heartbeatRunnable = object : Runnable {
            override fun run() {
                sendPresenceUpdate()
                handler.postDelayed(this, 30000) // 30 seconds
            }
        }
        handler.post(heartbeatRunnable!!)
    }
    
    private fun sendPresenceUpdate() {
        val presence = PresenceUpdate(
            status = if (isAppInForeground()) "online" else "idle",
            device = "android",
            activities = getCurrentActivities()
        )
        
        webSocketManager.send(presence)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        heartbeatRunnable?.let { handler.removeCallbacks(it) }
        sendOfflineStatus()
    }
}
```

### 7. Privacy Controls
```javascript
export class PresencePrivacy {
  static async updatePrivacySettings(userId, settings, env) {
    await env.USERS_DB.prepare(`
      UPDATE user_settings
      SET 
        hide_presence = ?,
        show_typing = ?,
        show_read_receipts = ?,
        invisible_mode = ?
      WHERE user_id = ?
    `).bind(
      settings.hidePresence || false,
      settings.showTyping ?? true,
      settings.showReadReceipts ?? true,
      settings.invisibleMode || false,
      userId
    ).run();
    
    // Update active presence if needed
    if (settings.hidePresence || settings.invisibleMode) {
      await this.hideUserPresence(userId, env);
    }
  }
  
  static async canSeePresence(viewerId, targetId, env) {
    // Check if target has hidden presence
    const privacy = await env.USERS_DB.prepare(`
      SELECT hide_presence, invisible_mode
      FROM user_settings
      WHERE user_id = ?
    `).bind(targetId).first();
    
    if (privacy?.hide_presence || privacy?.invisible_mode) {
      // Check if viewer has special permissions
      return this.hasPresenceOverride(viewerId, targetId, env);
    }
    
    return true;
  }
}
```

## Dependencies
- WebSocket Architecture (Issue #04) for real-time communication
- Authentication System (Issue #03) for user identification
- Database Schema (Issue #05) for storing presence data

## Estimated Effort
**4 days**
- 1 day: Presence state management and DO implementation
- 1 day: Typing indicators and broadcasting
- 1 day: Client-side hooks and UI components
- 1 day: Mobile background support and privacy controls

## Notes
- Consider presence history for analytics
- Add custom status options (like Discord)
- Implement presence sync across multiple devices
- Monitor DO memory usage with many presence updates