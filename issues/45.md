# Issue #45: Mobile Streaming

## User Story
As a **waddle user**, I want to **stream voice chat from mobile devices** so that **I can participate in voice conversations from anywhere using the mobile app**.

## Description
Implement mobile streaming capabilities to enable voice chat functionality on iOS and Android mobile applications. This includes audio capture, encoding, streaming protocols, and platform-specific optimizations for battery life and network efficiency.

## Acceptance Criteria
- [ ] Mobile audio capture implementation
- [ ] Low-latency streaming protocol
- [ ] Adaptive bitrate for mobile networks
- [ ] Background audio support
- [ ] Push-to-talk and voice activation
- [ ] Echo cancellation and noise suppression
- [ ] Battery optimization strategies
- [ ] Network handoff handling (WiFi/Cellular)

## Technical Implementation

### 1. Mobile Audio Architecture
```typescript
// Mobile audio streaming interface
export interface MobileAudioStream {
  id: string;
  userId: string;
  deviceInfo: DeviceInfo;
  streamConfig: StreamConfiguration;
  networkType: 'wifi' | 'cellular' | 'unknown';
  batteryLevel: number;
  isBackground: boolean;
}

export interface StreamConfiguration {
  codec: 'opus' | 'aac';
  bitrate: number;
  sampleRate: number;
  channels: number;
  echoCancellation: boolean;
  noiseSuppression: boolean;
  autoGainControl: boolean;
  voiceActivityDetection: boolean;
}

export interface DeviceInfo {
  platform: 'ios' | 'android';
  model: string;
  osVersion: string;
  appVersion: string;
  capabilities: DeviceCapabilities;
}

export interface DeviceCapabilities {
  hasEchoCancellation: boolean;
  hasNoiseSuppression: boolean;
  maxSampleRate: number;
  supportedCodecs: string[];
  hasPushToTalk: boolean;
}

// Mobile streaming manager
export class MobileStreamManager {
  private activeStreams = new Map<string, MobileAudioStream>();
  private audioEngine: AudioEngine;
  private networkMonitor: NetworkMonitor;
  
  constructor(
    private rtk: RealTimeKit,
    private config: MobileConfig
  ) {
    this.audioEngine = new AudioEngine(config);
    this.networkMonitor = new NetworkMonitor();
    this.setupEventHandlers();
  }
  
  async startStreaming(
    channelId: string,
    options: StreamOptions
  ): Promise<MobileAudioStream> {
    // Check permissions
    const hasPermission = await this.checkAudioPermissions();
    if (!hasPermission) {
      throw new Error('Microphone permission denied');
    }
    
    // Configure audio session
    await this.configureAudioSession(options);
    
    // Create stream configuration
    const streamConfig = this.createStreamConfig(options);
    
    // Initialize audio capture
    const audioCapture = await this.audioEngine.startCapture(streamConfig);
    
    // Connect to RealTimeKit
    const rtkStream = await this.rtk.createStream({
      channelId,
      type: 'audio',
      config: streamConfig
    });
    
    // Create mobile stream
    const mobileStream: MobileAudioStream = {
      id: rtkStream.id,
      userId: this.rtk.userId,
      deviceInfo: await this.getDeviceInfo(),
      streamConfig,
      networkType: await this.networkMonitor.getNetworkType(),
      batteryLevel: await this.getBatteryLevel(),
      isBackground: false
    };
    
    // Start streaming audio
    audioCapture.on('data', (audioData: AudioData) => {
      this.processAndSendAudio(rtkStream, audioData);
    });
    
    this.activeStreams.set(rtkStream.id, mobileStream);
    
    return mobileStream;
  }
  
  private async configureAudioSession(options: StreamOptions) {
    if (this.isIOS()) {
      // iOS-specific audio session configuration
      await this.configureIOSAudioSession({
        category: 'playAndRecord',
        mode: 'voiceChat',
        options: [
          'allowBluetooth',
          'defaultToSpeaker',
          'mixWithOthers'
        ]
      });
    } else if (this.isAndroid()) {
      // Android-specific audio configuration
      await this.configureAndroidAudioSession({
        streamType: 'voice_communication',
        contentType: 'speech',
        usage: 'voice_communication'
      });
    }
  }
  
  private createStreamConfig(options: StreamOptions): StreamConfiguration {
    const networkType = this.networkMonitor.getNetworkType();
    const batteryLevel = this.getBatteryLevel();
    
    // Adaptive configuration based on conditions
    let bitrate = options.bitrate || 32000;
    let sampleRate = options.sampleRate || 48000;
    
    // Reduce quality on cellular or low battery
    if (networkType === 'cellular') {
      bitrate = Math.min(bitrate, 24000);
      sampleRate = Math.min(sampleRate, 24000);
    }
    
    if (batteryLevel < 20) {
      bitrate = Math.min(bitrate, 16000);
      sampleRate = Math.min(sampleRate, 16000);
    }
    
    return {
      codec: 'opus',
      bitrate,
      sampleRate,
      channels: 1,
      echoCancellation: options.echoCancellation ?? true,
      noiseSuppression: options.noiseSuppression ?? true,
      autoGainControl: options.autoGainControl ?? true,
      voiceActivityDetection: options.voiceActivityDetection ?? true
    };
  }
  
  private processAndSendAudio(stream: RTKStream, audioData: AudioData) {
    // Apply audio processing
    let processedAudio = audioData;
    
    if (this.config.enableProcessing) {
      processedAudio = this.audioEngine.processAudio(audioData, {
        echoCancellation: stream.config.echoCancellation,
        noiseSuppression: stream.config.noiseSuppression,
        autoGainControl: stream.config.autoGainControl
      });
    }
    
    // Encode audio
    const encodedAudio = this.audioEngine.encode(processedAudio, stream.config.codec);
    
    // Send via RealTimeKit
    stream.send(encodedAudio);
  }
}
```

### 2. Adaptive Streaming
```typescript
// Adaptive bitrate streaming
export class AdaptiveStreamController {
  private currentBitrate: number;
  private targetBitrate: number;
  private networkStats: NetworkStats;
  
  constructor(
    private stream: MobileAudioStream,
    private networkMonitor: NetworkMonitor
  ) {
    this.currentBitrate = stream.streamConfig.bitrate;
    this.targetBitrate = this.currentBitrate;
    this.startAdaptation();
  }
  
  private startAdaptation() {
    // Monitor network conditions
    this.networkMonitor.on('stats', (stats: NetworkStats) => {
      this.networkStats = stats;
      this.adaptBitrate();
    });
    
    // Periodic adjustment
    setInterval(() => {
      this.adjustBitrate();
    }, 2000);
  }
  
  private adaptBitrate() {
    const { bandwidth, latency, packetLoss } = this.networkStats;
    
    // Calculate target bitrate based on network conditions
    let target = this.currentBitrate;
    
    // Bandwidth-based adaptation
    const availableBandwidth = bandwidth * 0.8; // Use 80% of available
    if (availableBandwidth < target) {
      target = Math.max(8000, availableBandwidth);
    }
    
    // Latency-based adjustment
    if (latency > 150) {
      target = Math.min(target, 24000);
    } else if (latency > 300) {
      target = Math.min(target, 16000);
    }
    
    // Packet loss adjustment
    if (packetLoss > 5) {
      target = target * 0.8;
    } else if (packetLoss > 10) {
      target = target * 0.6;
    }
    
    this.targetBitrate = Math.floor(target);
  }
  
  private adjustBitrate() {
    if (Math.abs(this.currentBitrate - this.targetBitrate) < 1000) {
      return; // No significant change needed
    }
    
    // Smooth bitrate transition
    const diff = this.targetBitrate - this.currentBitrate;
    const step = Math.sign(diff) * Math.min(Math.abs(diff), 2000);
    
    this.currentBitrate += step;
    
    // Apply new bitrate
    this.stream.streamConfig.bitrate = this.currentBitrate;
    this.applyBitrateChange();
  }
  
  private applyBitrateChange() {
    // Notify encoder of bitrate change
    this.stream.encoder.setBitrate(this.currentBitrate);
    
    // Log adaptation event
    console.log(`Adapted bitrate to ${this.currentBitrate}bps`);
  }
}
```

### 3. Push-to-Talk Implementation
```typescript
// Push-to-talk controller
export class PushToTalkController {
  private isTransmitting = false;
  private pttButton: HTMLElement | null = null;
  private gestureRecognizer: GestureRecognizer;
  
  constructor(
    private streamManager: MobileStreamManager,
    private ui: MobileUI
  ) {
    this.gestureRecognizer = new GestureRecognizer();
    this.setupPTT();
  }
  
  private setupPTT() {
    // Create PTT button
    this.pttButton = this.ui.createPTTButton({
      position: 'bottom-center',
      size: 'large',
      hapticFeedback: true
    });
    
    // Touch event handlers
    this.pttButton.addEventListener('touchstart', this.handlePTTStart.bind(this));
    this.pttButton.addEventListener('touchend', this.handlePTTEnd.bind(this));
    this.pttButton.addEventListener('touchcancel', this.handlePTTEnd.bind(this));
    
    // Gesture support (hold-to-talk)
    this.gestureRecognizer.on('longPress', this.handlePTTStart.bind(this));
    this.gestureRecognizer.on('release', this.handlePTTEnd.bind(this));
    
    // Accessibility support
    this.setupAccessibility();
  }
  
  private async handlePTTStart(event: Event) {
    event.preventDefault();
    
    if (this.isTransmitting) return;
    
    this.isTransmitting = true;
    
    // Visual feedback
    this.pttButton?.classList.add('active');
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate(50);
    }
    
    // Start transmission
    await this.streamManager.startTransmission();
    
    // Update UI
    this.ui.showTransmittingIndicator();
  }
  
  private async handlePTTEnd(event: Event) {
    event.preventDefault();
    
    if (!this.isTransmitting) return;
    
    this.isTransmitting = false;
    
    // Visual feedback
    this.pttButton?.classList.remove('active');
    
    // Stop transmission
    await this.streamManager.stopTransmission();
    
    // Update UI
    this.ui.hideTransmittingIndicator();
  }
  
  private setupAccessibility() {
    if (!this.pttButton) return;
    
    this.pttButton.setAttribute('role', 'button');
    this.pttButton.setAttribute('aria-label', 'Push to talk');
    this.pttButton.setAttribute('aria-pressed', 'false');
    
    // Update aria-pressed on state change
    const observer = new MutationObserver(() => {
      const isActive = this.pttButton?.classList.contains('active');
      this.pttButton?.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
    
    observer.observe(this.pttButton, {
      attributes: true,
      attributeFilter: ['class']
    });
  }
}
```

### 4. Background Audio Support
```typescript
// Background audio handler
export class BackgroundAudioHandler {
  private backgroundTask: BackgroundTask | null = null;
  private audioSession: AudioSession;
  
  constructor(
    private streamManager: MobileStreamManager,
    private platform: Platform
  ) {
    this.audioSession = new AudioSession(platform);
    this.setupBackgroundHandling();
  }
  
  private setupBackgroundHandling() {
    // App lifecycle events
    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
    
    if (this.platform.isIOS()) {
      // iOS background audio
      this.setupIOSBackgroundAudio();
    } else if (this.platform.isAndroid()) {
      // Android foreground service
      this.setupAndroidForegroundService();
    }
  }
  
  private setupIOSBackgroundAudio() {
    // Configure audio session for background
    this.audioSession.configure({
      category: 'playAndRecord',
      mode: 'voiceChat',
      options: ['mixWithOthers', 'allowBluetooth', 'defaultToSpeaker'],
      backgroundMode: true
    });
    
    // Begin background task when app backgrounds
    this.platform.on('didEnterBackground', async () => {
      this.backgroundTask = await this.platform.beginBackgroundTask({
        name: 'voice-chat',
        expirationHandler: () => {
          this.handleBackgroundExpiration();
        }
      });
      
      // Reduce quality for background
      this.streamManager.setBackgroundMode(true);
    });
    
    // End background task when app foregrounds
    this.platform.on('willEnterForeground', () => {
      if (this.backgroundTask) {
        this.platform.endBackgroundTask(this.backgroundTask);
        this.backgroundTask = null;
      }
      
      // Restore quality
      this.streamManager.setBackgroundMode(false);
    });
  }
  
  private setupAndroidForegroundService() {
    // Create foreground service for Android
    this.platform.on('didEnterBackground', async () => {
      await this.platform.startForegroundService({
        id: 'voice-chat-service',
        notification: {
          title: 'Waddle Voice Chat',
          text: 'Voice chat is active',
          icon: 'ic_voice_chat',
          actions: [
            {
              id: 'mute',
              title: 'Mute',
              icon: 'ic_mic_off'
            },
            {
              id: 'leave',
              title: 'Leave',
              icon: 'ic_call_end'
            }
          ]
        }
      });
    });
    
    // Handle notification actions
    this.platform.on('notificationAction', (action: string) => {
      switch (action) {
        case 'mute':
          this.streamManager.toggleMute();
          break;
        case 'leave':
          this.streamManager.leaveChannel();
          break;
      }
    });
  }
  
  private handleBackgroundExpiration() {
    // Gracefully handle background task expiration
    console.log('Background task expiring');
    
    // Notify user
    this.platform.showNotification({
      title: 'Voice Chat Ending',
      body: 'Background time expired. Tap to continue.',
      sound: true
    });
    
    // Pause streaming
    this.streamManager.pause();
  }
}
```

### 5. Battery Optimization
```typescript
// Battery optimization manager
export class BatteryOptimizationManager {
  private batteryLevel: number = 100;
  private isCharging: boolean = false;
  private optimizationLevel: 'none' | 'low' | 'medium' | 'high' = 'none';
  
  constructor(
    private streamManager: MobileStreamManager,
    private config: OptimizationConfig
  ) {
    this.startMonitoring();
  }
  
  private async startMonitoring() {
    // Battery status API
    if ('getBattery' in navigator) {
      const battery = await (navigator as any).getBattery();
      
      battery.addEventListener('levelchange', () => {
        this.batteryLevel = battery.level * 100;
        this.updateOptimization();
      });
      
      battery.addEventListener('chargingchange', () => {
        this.isCharging = battery.charging;
        this.updateOptimization();
      });
      
      // Initial values
      this.batteryLevel = battery.level * 100;
      this.isCharging = battery.charging;
    }
    
    // Fallback for platforms without Battery API
    this.setupPlatformSpecificMonitoring();
    
    // Initial optimization
    this.updateOptimization();
  }
  
  private updateOptimization() {
    const previousLevel = this.optimizationLevel;
    
    // Determine optimization level
    if (this.isCharging || this.batteryLevel > 80) {
      this.optimizationLevel = 'none';
    } else if (this.batteryLevel > 50) {
      this.optimizationLevel = 'low';
    } else if (this.batteryLevel > 20) {
      this.optimizationLevel = 'medium';
    } else {
      this.optimizationLevel = 'high';
    }
    
    if (previousLevel !== this.optimizationLevel) {
      this.applyOptimization();
    }
  }
  
  private applyOptimization() {
    const optimizations: Record<string, StreamOptimization> = {
      none: {
        bitrate: 32000,
        sampleRate: 48000,
        processingEnabled: true,
        videoEnabled: true,
        backgroundUpdates: true
      },
      low: {
        bitrate: 24000,
        sampleRate: 24000,
        processingEnabled: true,
        videoEnabled: true,
        backgroundUpdates: true
      },
      medium: {
        bitrate: 16000,
        sampleRate: 16000,
        processingEnabled: false,
        videoEnabled: false,
        backgroundUpdates: false
      },
      high: {
        bitrate: 8000,
        sampleRate: 8000,
        processingEnabled: false,
        videoEnabled: false,
        backgroundUpdates: false
      }
    };
    
    const optimization = optimizations[this.optimizationLevel];
    
    // Apply optimizations
    this.streamManager.applyOptimization(optimization);
    
    // Notify user of optimization
    if (this.optimizationLevel !== 'none') {
      this.showOptimizationNotice();
    }
  }
  
  private showOptimizationNotice() {
    const messages = {
      low: 'Optimizing for battery life',
      medium: 'Reduced quality to save battery',
      high: 'Maximum battery saving mode'
    };
    
    this.streamManager.showNotice({
      message: messages[this.optimizationLevel],
      duration: 3000,
      icon: 'battery'
    });
  }
}
```

### 6. Network Handoff
```typescript
// Network handoff manager
export class NetworkHandoffManager {
  private currentNetwork: NetworkInfo;
  private handoffInProgress = false;
  
  constructor(
    private streamManager: MobileStreamManager,
    private networkMonitor: NetworkMonitor
  ) {
    this.currentNetwork = this.networkMonitor.getCurrentNetwork();
    this.setupHandoffDetection();
  }
  
  private setupHandoffDetection() {
    // Monitor network changes
    this.networkMonitor.on('networkChange', async (newNetwork: NetworkInfo) => {
      if (this.handoffInProgress) return;
      
      console.log(`Network change detected: ${this.currentNetwork.type} -> ${newNetwork.type}`);
      
      // Handle different handoff scenarios
      if (this.isSignificantChange(this.currentNetwork, newNetwork)) {
        await this.performHandoff(newNetwork);
      }
      
      this.currentNetwork = newNetwork;
    });
    
    // Monitor connection quality
    this.networkMonitor.on('qualityChange', (quality: NetworkQuality) => {
      if (quality.score < 0.3) {
        this.prepareForPotentialHandoff();
      }
    });
  }
  
  private isSignificantChange(
    oldNetwork: NetworkInfo,
    newNetwork: NetworkInfo
  ): boolean {
    // Network type change (WiFi <-> Cellular)
    if (oldNetwork.type !== newNetwork.type) {
      return true;
    }
    
    // Different WiFi network
    if (oldNetwork.type === 'wifi' && oldNetwork.ssid !== newNetwork.ssid) {
      return true;
    }
    
    // Different cellular carrier or generation
    if (oldNetwork.type === 'cellular') {
      return oldNetwork.carrier !== newNetwork.carrier ||
             oldNetwork.generation !== newNetwork.generation;
    }
    
    return false;
  }
  
  private async performHandoff(newNetwork: NetworkInfo) {
    this.handoffInProgress = true;
    
    try {
      // Prepare for handoff
      await this.prepareHandoff(newNetwork);
      
      // Buffer audio during transition
      this.streamManager.startBuffering();
      
      // Perform network switch
      await this.switchNetwork(newNetwork);
      
      // Resume streaming
      await this.resumeStreaming();
      
      // Adjust quality for new network
      await this.optimizeForNetwork(newNetwork);
      
    } catch (error) {
      console.error('Handoff failed:', error);
      await this.handleHandoffFailure();
    } finally {
      this.handoffInProgress = false;
    }
  }
  
  private async prepareHandoff(newNetwork: NetworkInfo) {
    // Pre-establish connection on new network
    const testConnection = await this.streamManager.testConnection(newNetwork);
    
    if (!testConnection.success) {
      throw new Error('New network connection test failed');
    }
    
    // Cache current state
    this.streamManager.cacheState();
  }
  
  private async switchNetwork(newNetwork: NetworkInfo) {
    // Platform-specific network switching
    if (this.platform.isIOS()) {
      await this.switchNetworkIOS(newNetwork);
    } else if (this.platform.isAndroid()) {
      await this.switchNetworkAndroid(newNetwork);
    }
    
    // Wait for network to stabilize
    await this.waitForNetworkStability();
  }
  
  private async resumeStreaming() {
    // Restore cached state
    const cachedState = this.streamManager.getCachedState();
    
    // Reconnect with state
    await this.streamManager.reconnect(cachedState);
    
    // Flush buffered audio
    this.streamManager.flushBuffer();
  }
  
  private async optimizeForNetwork(network: NetworkInfo) {
    const optimization = this.getNetworkOptimization(network);
    await this.streamManager.applyOptimization(optimization);
  }
  
  private getNetworkOptimization(network: NetworkInfo): StreamOptimization {
    if (network.type === 'wifi') {
      return {
        bitrate: 32000,
        sampleRate: 48000,
        adaptiveBitrate: true,
        jitterBuffer: 50
      };
    }
    
    // Cellular optimizations based on generation
    const cellularOptimizations: Record<string, StreamOptimization> = {
      '5G': {
        bitrate: 32000,
        sampleRate: 48000,
        adaptiveBitrate: true,
        jitterBuffer: 100
      },
      '4G': {
        bitrate: 24000,
        sampleRate: 24000,
        adaptiveBitrate: true,
        jitterBuffer: 150
      },
      '3G': {
        bitrate: 16000,
        sampleRate: 16000,
        adaptiveBitrate: true,
        jitterBuffer: 200
      },
      '2G': {
        bitrate: 8000,
        sampleRate: 8000,
        adaptiveBitrate: false,
        jitterBuffer: 300
      }
    };
    
    return cellularOptimizations[network.generation] || cellularOptimizations['3G'];
  }
}
```

## Dependencies
- RealTimeKit for WebRTC streaming
- Platform-specific audio APIs (iOS/Android)
- Battery Status API
- Network Information API
- Background task APIs

## Estimated Effort
**8 days**
- 2 days: Core mobile streaming implementation
- 1 day: Push-to-talk and voice activation
- 2 days: Background audio support
- 1 day: Battery optimization
- 1 day: Network handoff handling
- 1 day: Testing and optimization

## Notes
- Consider WebRTC vs native streaming protocols
- Implement audio codec fallbacks
- Add telemetry for mobile performance
- Consider regional audio routing
- Plan for Bluetooth device support