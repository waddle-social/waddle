# Issue #11: Message Search (Full-text Search)

## User Story
As a **user**, I want to **search through message history** so that **I can find specific conversations or information quickly**.

## Description
Implement full-text search functionality using D1's FTS5 (Full-Text Search) capabilities. This includes searching across messages, filtering by various criteria, and providing relevant search results with context.

## Acceptance Criteria
- [ ] Search works across all messages user has access to
- [ ] Results show message context (before/after messages)
- [ ] Search supports filters (from:user, in:channel, has:attachment)
- [ ] Results are paginated and sorted by relevance
- [ ] Search highlights matching terms
- [ ] Recent searches are saved
- [ ] Search works within specific threads
- [ ] Export search results functionality

## Technical Implementation

### 1. FTS5 Table Setup
```sql
-- Add to per-waddle D1 schema
CREATE VIRTUAL TABLE messages_fts USING fts5(
  message_id UNINDEXED,
  content,
  user_name,
  channel_name,
  thread_title,
  tokenize = 'porter unicode61'
);

-- Trigger to keep FTS in sync
CREATE TRIGGER messages_fts_insert AFTER INSERT ON messages
BEGIN
  INSERT INTO messages_fts (message_id, content, user_name, channel_name, thread_title)
  SELECT 
    NEW.id,
    NEW.content,
    u.username,
    c.name,
    t.title
  FROM users u
  JOIN channels c ON NEW.channel_id = c.id
  LEFT JOIN threads t ON NEW.thread_id = t.id
  WHERE u.id = NEW.user_id;
END;

CREATE TRIGGER messages_fts_update AFTER UPDATE OF content ON messages
BEGIN
  UPDATE messages_fts 
  SET content = NEW.content
  WHERE message_id = NEW.id;
END;

CREATE TRIGGER messages_fts_delete AFTER DELETE ON messages
BEGIN
  DELETE FROM messages_fts WHERE message_id = OLD.id;
END;
```

### 2. Search Query Parser
```javascript
export class SearchQueryParser {
  static parse(query) {
    const filters = {
      text: [],
      from: [],
      in: [],
      has: [],
      before: null,
      after: null,
      thread: null
    };
    
    // Regular expressions for different filter types
    const patterns = {
      from: /from:(\S+)/g,
      in: /in:(\S+)/g,
      has: /has:(\w+)/g,
      before: /before:(\d{4}-\d{2}-\d{2})/g,
      after: /after:(\d{4}-\d{2}-\d{2})/g,
      thread: /thread:"([^"]+)"/g,
      quoted: /"([^"]+)"/g
    };
    
    let processedQuery = query;
    
    // Extract filters
    for (const [filter, pattern] of Object.entries(patterns)) {
      let match;
      while ((match = pattern.exec(query)) !== null) {
        if (filter === 'before' || filter === 'after' || filter === 'thread') {
          filters[filter] = match[1];
        } else if (filter === 'quoted') {
          filters.text.push({ type: 'exact', value: match[1] });
        } else {
          filters[filter].push(match[1]);
        }
        
        // Remove from query
        processedQuery = processedQuery.replace(match[0], '');
      }
    }
    
    // Add remaining text as general search
    const remainingText = processedQuery.trim();
    if (remainingText) {
      filters.text.push({ type: 'general', value: remainingText });
    }
    
    return filters;
  }
  
  static buildFTSQuery(filters) {
    const ftsTerms = [];
    
    // Text search terms
    for (const term of filters.text) {
      if (term.type === 'exact') {
        ftsTerms.push(`"${term.value}"`);
      } else {
        // Split into words and prefix match last word
        const words = term.value.split(/\s+/);
        const lastWord = words.pop();
        
        if (words.length > 0) {
          ftsTerms.push(words.map(w => `"${w}"`).join(' '));
        }
        
        if (lastWord) {
          ftsTerms.push(`${lastWord}*`);
        }
      }
    }
    
    // User filter
    if (filters.from.length > 0) {
      ftsTerms.push(filters.from.map(u => `user_name:"${u}"`).join(' OR '));
    }
    
    // Channel filter
    if (filters.in.length > 0) {
      ftsTerms.push(filters.in.map(c => `channel_name:"${c}"`).join(' OR '));
    }
    
    return ftsTerms.join(' AND ');
  }
}
```

### 3. Search Implementation
```javascript
export class MessageSearch {
  static async search(waddleId, userId, query, options = {}, env) {
    const {
      limit = 50,
      offset = 0,
      sortBy = 'relevance' // 'relevance' | 'date'
    } = options;
    
    // Parse search query
    const filters = SearchQueryParser.parse(query);
    const ftsQuery = SearchQueryParser.buildFTSQuery(filters);
    
    // Get user's accessible channels
    const accessibleChannels = await this.getUserChannels(waddleId, userId, env);
    
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Build main search query
    let sql = `
      SELECT 
        m.id,
        m.content,
        m.channel_id,
        m.thread_id,
        m.user_id,
        m.created_at,
        m.metadata,
        u.username,
        u.avatar_url,
        c.name as channel_name,
        t.title as thread_title,
        -- FTS rank for relevance
        rank
      FROM messages m
      JOIN users u ON m.user_id = u.id
      JOIN channels c ON m.channel_id = c.id
      LEFT JOIN threads t ON m.thread_id = t.id
      JOIN (
        SELECT message_id, rank
        FROM messages_fts
        WHERE messages_fts MATCH ?
      ) fts ON m.id = fts.message_id
      WHERE m.channel_id IN (${accessibleChannels.map(() => '?').join(',')})
        AND m.is_deleted = false
    `;
    
    const params = [ftsQuery, ...accessibleChannels];
    
    // Add additional filters
    if (filters.has.includes('attachment')) {
      sql += ` AND json_array_length(m.metadata, '$.attachments') > 0`;
    }
    
    if (filters.has.includes('link')) {
      sql += ` AND json_array_length(m.metadata, '$.embeds') > 0`;
    }
    
    if (filters.before) {
      sql += ` AND m.created_at < ?`;
      params.push(filters.before);
    }
    
    if (filters.after) {
      sql += ` AND m.created_at > ?`;
      params.push(filters.after);
    }
    
    if (filters.thread) {
      sql += ` AND t.title = ?`;
      params.push(filters.thread);
    }
    
    // Add sorting
    if (sortBy === 'relevance') {
      sql += ` ORDER BY rank DESC, m.created_at DESC`;
    } else {
      sql += ` ORDER BY m.created_at DESC`;
    }
    
    sql += ` LIMIT ? OFFSET ?`;
    params.push(limit, offset);
    
    // Execute search
    const results = await db.prepare(sql).bind(...params).all();
    
    // Get context for each result
    const enrichedResults = await this.enrichResults(results.results, db);
    
    // Save search to history
    await this.saveSearchHistory(userId, query, results.results.length, env);
    
    return {
      results: enrichedResults,
      total: results.results.length,
      hasMore: results.results.length === limit
    };
  }
  
  static async enrichResults(results, db) {
    const enriched = [];
    
    for (const result of results) {
      // Get context messages (2 before, 2 after)
      const context = await db.prepare(`
        SELECT 
          m.id,
          m.content,
          m.user_id,
          m.created_at,
          u.username,
          u.avatar_url
        FROM messages m
        JOIN users u ON m.user_id = u.id
        WHERE m.channel_id = ?
          AND m.created_at BETWEEN 
            datetime(?, '-2 minutes') AND 
            datetime(?, '+2 minutes')
          AND m.id != ?
        ORDER BY m.created_at
        LIMIT 4
      `).bind(
        result.channel_id,
        result.created_at,
        result.created_at,
        result.id
      ).all();
      
      enriched.push({
        ...result,
        context: context.results,
        highlights: this.extractHighlights(result.content, result.rank)
      });
    }
    
    return enriched;
  }
  
  static extractHighlights(content, rank) {
    // Simple highlight extraction
    // In production, use FTS5 snippet function
    const words = content.split(/\s+/);
    const highlights = [];
    
    // Extract sentences with high-ranking terms
    // This is simplified - real implementation would use FTS5 snippet()
    const sentences = content.split(/[.!?]+/);
    for (const sentence of sentences) {
      if (sentence.trim()) {
        highlights.push({
          text: sentence.trim(),
          score: Math.random() // Would be actual relevance score
        });
      }
    }
    
    return highlights.sort((a, b) => b.score - a.score).slice(0, 3);
  }
}
```

### 4. Search UI Components
```tsx
export function SearchInterface({ waddleId }: { waddleId: string }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<SearchResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState<SearchFilters>({});
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  
  const debouncedSearch = useMemo(
    () => debounce(async (searchQuery: string) => {
      if (!searchQuery.trim()) {
        setResults([]);
        return;
      }
      
      setLoading(true);
      try {
        const data = await api.searchMessages(waddleId, searchQuery, filters);
        setResults(data.results);
      } finally {
        setLoading(false);
      }
    }, 300),
    [waddleId, filters]
  );
  
  useEffect(() => {
    debouncedSearch(query);
  }, [query, debouncedSearch]);
  
  useEffect(() => {
    // Load recent searches
    const recent = localStorage.getItem('recentSearches');
    if (recent) {
      setRecentSearches(JSON.parse(recent));
    }
  }, []);
  
  return (
    <div className="search-interface">
      <SearchBar
        value={query}
        onChange={setQuery}
        onFilterChange={setFilters}
        placeholder="Search messages..."
      />
      
      {query && (
        <SearchFilters
          filters={filters}
          onChange={setFilters}
          suggestions={getSuggestions(query)}
        />
      )}
      
      {!query && recentSearches.length > 0 && (
        <RecentSearches
          searches={recentSearches}
          onSelect={setQuery}
        />
      )}
      
      {loading && <SearchSkeleton />}
      
      {results.length > 0 && (
        <SearchResults
          results={results}
          query={query}
          onLoadMore={() => loadMore()}
        />
      )}
      
      {query && !loading && results.length === 0 && (
        <NoResults query={query} />
      )}
    </div>
  );
}

function SearchResult({ result, query }: { result: SearchResult; query: string }) {
  const highlightedContent = useMemo(
    () => highlightText(result.content, query),
    [result.content, query]
  );
  
  return (
    <div className="search-result">
      <div className="result-header">
        <Avatar user={result.user} size="small" />
        <span className="username">{result.username}</span>
        <span className="separator">in</span>
        <span className="channel">#{result.channel_name}</span>
        {result.thread_title && (
          <>
            <span className="separator">â€º</span>
            <span className="thread">{result.thread_title}</span>
          </>
        )}
        <time className="timestamp">
          {formatRelativeTime(result.created_at)}
        </time>
      </div>
      
      <div className="result-content">
        <div 
          className="message-text"
          dangerouslySetInnerHTML={{ __html: highlightedContent }}
        />
        
        {result.attachments?.length > 0 && (
          <div className="attachments-indicator">
            <PaperclipIcon />
            <span>{result.attachments.length} attachment(s)</span>
          </div>
        )}
      </div>
      
      {result.context.length > 0 && (
        <details className="result-context">
          <summary>Show context</summary>
          <div className="context-messages">
            {result.context.map(msg => (
              <ContextMessage key={msg.id} message={msg} />
            ))}
          </div>
        </details>
      )}
      
      <div className="result-actions">
        <button onClick={() => jumpToMessage(result.id)}>
          Jump to message
        </button>
        <button onClick={() => copyMessageLink(result.id)}>
          Copy link
        </button>
      </div>
    </div>
  );
}
```

### 5. Advanced Search Features
```javascript
export class AdvancedSearch {
  static async searchWithAI(waddleId, userId, naturalQuery, env) {
    // Use AI to parse natural language queries
    const prompt = `
      Convert this natural language search query into search filters:
      "${naturalQuery}"
      
      Available filters:
      - from:username
      - in:channel
      - has:attachment/link
      - before:YYYY-MM-DD
      - after:YYYY-MM-DD
      - thread:"thread title"
      
      Return JSON with 'query' and 'filters' fields.
    `;
    
    const aiResponse = await env.AI.run('@cf/meta/llama-2-7b-chat-int8', {
      prompt,
      max_tokens: 200
    });
    
    try {
      const parsed = JSON.parse(aiResponse.response);
      return this.search(waddleId, userId, parsed.query, {
        ...parsed.filters
      }, env);
    } catch {
      // Fallback to regular search
      return this.search(waddleId, userId, naturalQuery, {}, env);
    }
  }
  
  static async exportSearchResults(results, format, env) {
    switch (format) {
      case 'csv':
        return this.exportAsCSV(results);
      case 'json':
        return this.exportAsJSON(results);
      case 'pdf':
        return this.exportAsPDF(results, env);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  
  static exportAsCSV(results) {
    const headers = ['Date', 'Time', 'Channel', 'User', 'Message'];
    const rows = results.map(r => [
      new Date(r.created_at).toLocaleDateString(),
      new Date(r.created_at).toLocaleTimeString(),
      r.channel_name,
      r.username,
      r.content.replace(/"/g, '""') // Escape quotes
    ]);
    
    const csv = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
    
    return new Response(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': 'attachment; filename="search-results.csv"'
      }
    });
  }
}
```

### 6. Search Analytics
```javascript
export class SearchAnalytics {
  static async trackSearch(userId, query, resultCount, env) {
    await env.ANALYTICS_DB.prepare(`
      INSERT INTO search_logs (user_id, query, result_count, searched_at)
      VALUES (?, ?, ?, CURRENT_TIMESTAMP)
    `).bind(userId, query, resultCount).run();
  }
  
  static async getPopularSearches(waddleId, days = 7, env) {
    const results = await env.ANALYTICS_DB.prepare(`
      SELECT 
        query,
        COUNT(*) as search_count,
        AVG(result_count) as avg_results
      FROM search_logs
      WHERE searched_at > datetime('now', '-' || ? || ' days')
      GROUP BY query
      ORDER BY search_count DESC
      LIMIT 10
    `).bind(days).all();
    
    return results.results;
  }
  
  static async getSearchInsights(waddleId, env) {
    const insights = await env.ANALYTICS_DB.prepare(`
      SELECT 
        COUNT(DISTINCT user_id) as unique_searchers,
        COUNT(*) as total_searches,
        AVG(result_count) as avg_results_per_search,
        COUNT(CASE WHEN result_count = 0 THEN 1 END) as zero_result_searches
      FROM search_logs
      WHERE searched_at > datetime('now', '-30 days')
    `).first();
    
    return insights;
  }
}
```

### 7. Search Optimizations
```javascript
export class SearchOptimizer {
  static async rebuildSearchIndex(waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Rebuild FTS index
    await db.prepare('DELETE FROM messages_fts').run();
    
    await db.prepare(`
      INSERT INTO messages_fts (message_id, content, user_name, channel_name, thread_title)
      SELECT 
        m.id,
        m.content,
        u.username,
        c.name,
        t.title
      FROM messages m
      JOIN users u ON m.user_id = u.id
      JOIN channels c ON m.channel_id = c.id
      LEFT JOIN threads t ON m.thread_id = t.id
    `).run();
    
    // Optimize FTS table
    await db.prepare("INSERT INTO messages_fts(messages_fts) VALUES('optimize')").run();
  }
  
  static async createSearchSuggestions(waddleId, env) {
    const db = env[`WADDLE_DB_${waddleId}`];
    
    // Extract common terms
    const terms = await db.prepare(`
      SELECT term, doc_count
      FROM messages_fts_vocab
      WHERE doc_count > 10
      ORDER BY doc_count DESC
      LIMIT 1000
    `).all();
    
    // Store as suggestions
    await env.SEARCH_KV.put(
      `suggestions:${waddleId}`,
      JSON.stringify(terms.results),
      { expirationTtl: 3600 } // 1 hour
    );
  }
}
```

## Dependencies
- Database Schema (Issue #05) for FTS5 tables
- Message Flow (Issue #06) for message structure
- Authentication (Issue #03) for access control

## Estimated Effort
**5 days**
- 1 day: FTS5 setup and query parser
- 1 day: Search implementation with filters
- 1 day: UI components and highlighting
- 1 day: Advanced features (AI, export)
- 1 day: Optimization and testing

## Notes
- Consider Algolia or Elasticsearch for larger scale
- Add search result caching for common queries
- Implement search suggestions/autocomplete
- Monitor search performance metrics