# Issue #18: Participant State Tracking

## User Story
As a **voice channel participant**, I want to **see real-time status of all participants** so that **I know who's speaking, muted, or experiencing connection issues**.

## Description
Implement comprehensive participant state tracking for voice channels, including speaking indicators, connection quality, permissions, and real-time synchronization across all clients. This ensures everyone has accurate information about voice channel participants.

## Acceptance Criteria
- [ ] Real-time participant list updates
- [ ] Speaking indicators with audio levels
- [ ] Connection quality indicators
- [ ] Mute/deafen state synchronization
- [ ] Permission-based capabilities display
- [ ] Participant metadata (roles, nicknames)
- [ ] Join/leave animations
- [ ] State persistence across reconnects

## Technical Implementation

### 1. Participant State Model
```typescript
export interface VoiceParticipant {
  // Identity
  userId: string;
  sessionId: string;
  username: string;
  nickname?: string;
  avatarUrl?: string;
  
  // Voice State
  isMuted: boolean;
  isSelfMuted: boolean;
  isDeafened: boolean;
  isSelfDeafened: boolean;
  isSpeaking: boolean;
  audioLevel: number; // 0-100
  
  // Video State
  isVideoEnabled: boolean;
  isScreenSharing: boolean;
  videoQuality?: 'low' | 'medium' | 'high';
  
  // Connection
  connectionState: 'connecting' | 'connected' | 'reconnecting' | 'disconnected';
  connectionQuality: 'excellent' | 'good' | 'poor' | 'unknown';
  latency: number; // ms
  packetLoss: number; // percentage
  
  // Permissions
  permissions: VoicePermissions;
  role: 'speaker' | 'moderator' | 'listener';
  
  // Metadata
  joinedAt: number;
  lastActivity: number;
  platform: 'web' | 'desktop' | 'mobile';
  
  // RealTimeKit specific
  rtkParticipantId?: string;
  tracks: {
    audio?: TrackInfo;
    video?: TrackInfo;
    screen?: TrackInfo;
  };
}

interface TrackInfo {
  trackId: string;
  enabled: boolean;
  muted: boolean;
  quality: string;
  statistics?: RTCStatsReport;
}
```

### 2. Participant State Manager
```typescript
export class ParticipantStateManager {
  private participants = new Map<string, VoiceParticipant>();
  private stateSubscribers = new Set<(state: ParticipantUpdate) => void>();
  private updateQueue: ParticipantUpdate[] = [];
  private updateTimer: NodeJS.Timeout | null = null;
  
  constructor(
    private channelId: string,
    private durableObject: DurableObjectStub
  ) {
    this.initializeSync();
  }
  
  private initializeSync(): void {
    // Subscribe to state updates from Durable Object
    this.durableObject.subscribeToParticipants((updates) => {
      this.handleRemoteUpdates(updates);
    });
    
    // Periodic sync for consistency
    setInterval(() => {
      this.syncWithServer();
    }, 5000);
  }
  
  async addParticipant(participant: Partial<VoiceParticipant>): Promise<void> {
    const fullParticipant: VoiceParticipant = {
      // Defaults
      isMuted: false,
      isSelfMuted: false,
      isDeafened: false,
      isSelfDeafened: false,
      isSpeaking: false,
      audioLevel: 0,
      isVideoEnabled: false,
      isScreenSharing: false,
      connectionState: 'connecting',
      connectionQuality: 'unknown',
      latency: 0,
      packetLoss: 0,
      joinedAt: Date.now(),
      lastActivity: Date.now(),
      tracks: {},
      
      // Merge provided data
      ...participant,
      userId: participant.userId!,
      sessionId: participant.sessionId!,
      username: participant.username!,
      permissions: participant.permissions!,
      role: participant.role || 'listener',
      platform: participant.platform || 'web'
    };
    
    this.participants.set(participant.userId!, fullParticipant);
    
    // Notify subscribers
    this.queueUpdate({
      type: 'participant_joined',
      participant: fullParticipant,
      timestamp: Date.now()
    });
    
    // Sync to server
    await this.durableObject.updateParticipant(fullParticipant);
  }
  
  updateParticipant(userId: string, updates: Partial<VoiceParticipant>): void {
    const participant = this.participants.get(userId);
    if (!participant) return;
    
    // Track what changed for efficient updates
    const changes: string[] = [];
    const previousState = { ...participant };
    
    // Apply updates
    Object.entries(updates).forEach(([key, value]) => {
      if (participant[key as keyof VoiceParticipant] !== value) {
        changes.push(key);
        (participant as any)[key] = value;
      }
    });
    
    if (changes.length === 0) return;
    
    // Update activity
    participant.lastActivity = Date.now();
    
    // Queue update notification
    this.queueUpdate({
      type: 'participant_updated',
      participant,
      changes,
      previousState,
      timestamp: Date.now()
    });
  }
  
  private queueUpdate(update: ParticipantUpdate): void {
    this.updateQueue.push(update);
    
    // Batch updates for performance
    if (!this.updateTimer) {
      this.updateTimer = setTimeout(() => {
        this.flushUpdateQueue();
      }, 16); // ~60fps
    }
  }
  
  private flushUpdateQueue(): void {
    if (this.updateQueue.length === 0) return;
    
    const updates = [...this.updateQueue];
    this.updateQueue = [];
    this.updateTimer = null;
    
    // Notify all subscribers
    this.stateSubscribers.forEach(subscriber => {
      updates.forEach(update => subscriber(update));
    });
  }
  
  // Audio level tracking
  updateAudioLevel(userId: string, level: number): void {
    const participant = this.participants.get(userId);
    if (!participant) return;
    
    const normalizedLevel = Math.max(0, Math.min(100, level));
    const wasSpeaking = participant.isSpeaking;
    const isSpeaking = normalizedLevel > 5; // Speaking threshold
    
    this.updateParticipant(userId, {
      audioLevel: normalizedLevel,
      isSpeaking
    });
    
    // Emit speaking change event
    if (wasSpeaking !== isSpeaking) {
      this.queueUpdate({
        type: isSpeaking ? 'started_speaking' : 'stopped_speaking',
        participant: participant,
        timestamp: Date.now()
      });
    }
  }
  
  // Connection quality monitoring
  updateConnectionQuality(userId: string, stats: ConnectionStats): void {
    const quality = this.calculateQuality(stats);
    
    this.updateParticipant(userId, {
      connectionQuality: quality,
      latency: stats.latency,
      packetLoss: stats.packetLoss
    });
  }
  
  private calculateQuality(stats: ConnectionStats): 'excellent' | 'good' | 'poor' {
    if (stats.latency < 50 && stats.packetLoss < 1) return 'excellent';
    if (stats.latency < 150 && stats.packetLoss < 5) return 'good';
    return 'poor';
  }
}
```

### 3. Speaking Detection and Visualization
```typescript
export class SpeakingDetector {
  private audioContext: AudioContext;
  private analyser: AnalyserNode;
  private processor: ScriptProcessorNode;
  private speakingHistory: boolean[] = [];
  private readonly HISTORY_SIZE = 10;
  private readonly SPEAKING_THRESHOLD = 15;
  
  constructor(
    private stream: MediaStream,
    private onSpeaking: (speaking: boolean, level: number) => void
  ) {
    this.setupAudioProcessing();
  }
  
  private setupAudioProcessing(): void {
    this.audioContext = new AudioContext();
    this.analyser = this.audioContext.createAnalyser();
    
    // Configure analyser
    this.analyser.fftSize = 512;
    this.analyser.smoothingTimeConstant = 0.3;
    this.analyser.minDecibels = -90;
    this.analyser.maxDecibels = -10;
    
    // Create processor for real-time analysis
    this.processor = this.audioContext.createScriptProcessor(512, 1, 1);
    
    // Connect nodes
    const source = this.audioContext.createMediaStreamSource(this.stream);
    source.connect(this.analyser);
    this.analyser.connect(this.processor);
    this.processor.connect(this.audioContext.destination);
    
    // Process audio
    this.processor.onaudioprocess = () => this.processAudio();
  }
  
  private processAudio(): void {
    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteFrequencyData(dataArray);
    
    // Calculate volume (0-100)
    const volume = this.calculateVolume(dataArray);
    
    // Determine if speaking
    const isSpeaking = volume > this.SPEAKING_THRESHOLD;
    
    // Add to history for smoothing
    this.speakingHistory.push(isSpeaking);
    if (this.speakingHistory.length > this.HISTORY_SIZE) {
      this.speakingHistory.shift();
    }
    
    // Smooth the speaking state
    const speakingCount = this.speakingHistory.filter(s => s).length;
    const smoothedSpeaking = speakingCount > this.HISTORY_SIZE / 2;
    
    // Notify listener
    this.onSpeaking(smoothedSpeaking, volume);
  }
  
  private calculateVolume(dataArray: Uint8Array): number {
    // Focus on voice frequency range (300-3000 Hz)
    const voiceStart = Math.floor(300 / (this.audioContext.sampleRate / this.analyser.fftSize));
    const voiceEnd = Math.floor(3000 / (this.audioContext.sampleRate / this.analyser.fftSize));
    
    let sum = 0;
    for (let i = voiceStart; i < voiceEnd && i < dataArray.length; i++) {
      sum += dataArray[i];
    }
    
    const average = sum / (voiceEnd - voiceStart);
    return (average / 255) * 100;
  }
  
  destroy(): void {
    if (this.processor) {
      this.processor.disconnect();
    }
    if (this.analyser) {
      this.analyser.disconnect();
    }
    if (this.audioContext) {
      this.audioContext.close();
    }
  }
}
```

### 4. React Components for Participant Display
```tsx
export function VoiceParticipantList({ channelId }: { channelId: string }) {
  const participants = useVoiceParticipants(channelId);
  const [sortBy, setSortBy] = useState<'activity' | 'name' | 'role'>('activity');
  
  const sortedParticipants = useMemo(() => {
    const sorted = [...participants];
    
    switch (sortBy) {
      case 'activity':
        return sorted.sort((a, b) => {
          // Speaking participants first
          if (a.isSpeaking && !b.isSpeaking) return -1;
          if (!a.isSpeaking && b.isSpeaking) return 1;
          // Then by join time
          return a.joinedAt - b.joinedAt;
        });
        
      case 'name':
        return sorted.sort((a, b) => 
          a.username.localeCompare(b.username)
        );
        
      case 'role':
        const roleOrder = { moderator: 0, speaker: 1, listener: 2 };
        return sorted.sort((a, b) => 
          roleOrder[a.role] - roleOrder[b.role]
        );
        
      default:
        return sorted;
    }
  }, [participants, sortBy]);
  
  return (
    <div className="voice-participant-list">
      <div className="list-header">
        <h3>Participants ({participants.length})</h3>
        <SortDropdown value={sortBy} onChange={setSortBy} />
      </div>
      
      <TransitionGroup className="participants">
        {sortedParticipants.map(participant => (
          <CSSTransition
            key={participant.userId}
            timeout={300}
            classNames="participant"
          >
            <ParticipantItem participant={participant} />
          </CSSTransition>
        ))}
      </TransitionGroup>
    </div>
  );
}

function ParticipantItem({ participant }: { participant: VoiceParticipant }) {
  const { user } = useUser(participant.userId);
  const [showMenu, setShowMenu] = useState(false);
  const canModerate = useCanModerate();
  
  return (
    <div 
      className={`participant-item ${participant.isSpeaking ? 'speaking' : ''}`}
      onContextMenu={(e) => {
        e.preventDefault();
        setShowMenu(true);
      }}
    >
      <div className="participant-avatar">
        <Avatar 
          user={user} 
          size="medium"
          status={participant.connectionState}
        />
        <SpeakingRing 
          active={participant.isSpeaking} 
          level={participant.audioLevel}
        />
      </div>
      
      <div className="participant-info">
        <div className="participant-name">
          <span className="username">
            {participant.nickname || user?.username}
          </span>
          {participant.role !== 'listener' && (
            <RoleBadge role={participant.role} />
          )}
        </div>
        
        <div className="participant-status">
          <ConnectionIndicator quality={participant.connectionQuality} />
          {participant.platform !== 'web' && (
            <PlatformIcon platform={participant.platform} />
          )}
        </div>
      </div>
      
      <div className="participant-controls">
        <ParticipantStateIcons participant={participant} />
      </div>
      
      {showMenu && canModerate && (
        <ParticipantContextMenu
          participant={participant}
          onClose={() => setShowMenu(false)}
        />
      )}
    </div>
  );
}

function SpeakingRing({ active, level }: { active: boolean; level: number }) {
  const scale = active ? 1 + (level / 100) * 0.2 : 1;
  const opacity = active ? 0.6 + (level / 100) * 0.4 : 0;
  
  return (
    <div 
      className="speaking-ring"
      style={{
        transform: `scale(${scale})`,
        opacity,
        borderColor: `rgba(67, 181, 129, ${opacity})`
      }}
    />
  );
}

function ParticipantStateIcons({ participant }: { participant: VoiceParticipant }) {
  return (
    <div className="state-icons">
      {participant.isMuted && (
        <Tooltip content={participant.isSelfMuted ? "Muted" : "Muted by moderator"}>
          <MicOffIcon className={participant.isSelfMuted ? '' : 'server-muted'} />
        </Tooltip>
      )}
      
      {participant.isDeafened && (
        <Tooltip content="Deafened">
          <HeadsetOffIcon />
        </Tooltip>
      )}
      
      {participant.isVideoEnabled && (
        <Tooltip content="Camera on">
          <VideocamIcon />
        </Tooltip>
      )}
      
      {participant.isScreenSharing && (
        <Tooltip content="Screen sharing">
          <ScreenShareIcon />
        </Tooltip>
      )}
      
      {participant.connectionQuality === 'poor' && (
        <Tooltip content="Poor connection">
          <SignalCellularConnectedNoInternet0BarIcon className="warning" />
        </Tooltip>
      )}
    </div>
  );
}
```

### 5. State Synchronization via WebSocket
```javascript
// In Durable Object
export class VoiceChannelDO {
  private participants = new Map();
  private stateVersion = 0;
  
  async handleParticipantUpdate(ws, message) {
    const { userId, updates } = message;
    
    // Validate permissions
    if (!this.canUpdateParticipant(ws, userId)) {
      return this.sendError(ws, 'Unauthorized');
    }
    
    // Get participant
    const participant = this.participants.get(userId);
    if (!participant) {
      return this.sendError(ws, 'Participant not found');
    }
    
    // Apply updates
    const previousState = { ...participant };
    Object.assign(participant, updates);
    participant.lastUpdate = Date.now();
    
    // Increment version for consistency
    this.stateVersion++;
    
    // Store in durable storage
    await this.state.storage.put(`participant:${userId}`, participant);
    
    // Broadcast to all except sender
    const update = {
      type: 'participant_updated',
      userId,
      updates,
      previousState,
      version: this.stateVersion
    };
    
    this.broadcastExcept(ws, update);
    
    // Send acknowledgment to sender
    ws.send(JSON.stringify({
      type: 'update_ack',
      userId,
      version: this.stateVersion
    }));
  }
  
  async handleSyncRequest(ws) {
    // Send full state to requesting client
    const fullState = {
      type: 'sync_response',
      participants: Array.from(this.participants.values()),
      version: this.stateVersion,
      timestamp: Date.now()
    };
    
    ws.send(JSON.stringify(fullState));
  }
  
  // Periodic state broadcast for consistency
  async broadcastStateSnapshot() {
    const snapshot = {
      type: 'state_snapshot',
      participants: Array.from(this.participants.entries()).map(([id, p]) => ({
        userId: id,
        isSpeaking: p.isSpeaking,
        audioLevel: p.audioLevel,
        connectionState: p.connectionState
      })),
      version: this.stateVersion
    };
    
    this.broadcast(snapshot);
  }
}
```

### 6. Connection Quality Monitoring
```typescript
export class ConnectionQualityMonitor {
  private statsInterval: number;
  private qualityHistory: QualityMeasurement[] = [];
  private readonly HISTORY_SIZE = 30;
  
  constructor(
    private peerConnection: RTCPeerConnection,
    private onQualityChange: (quality: ConnectionQuality) => void
  ) {
    this.startMonitoring();
  }
  
  private startMonitoring(): void {
    this.statsInterval = window.setInterval(async () => {
      const stats = await this.collectStats();
      const quality = this.analyzeQuality(stats);
      
      this.qualityHistory.push(quality);
      if (this.qualityHistory.length > this.HISTORY_SIZE) {
        this.qualityHistory.shift();
      }
      
      const averageQuality = this.calculateAverageQuality();
      this.onQualityChange(averageQuality);
    }, 1000);
  }
  
  private async collectStats(): Promise<QualityStats> {
    const stats = await this.peerConnection.getStats();
    const quality: QualityStats = {
      latency: 0,
      jitter: 0,
      packetLoss: 0,
      bandwidth: 0
    };
    
    stats.forEach(report => {
      if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
        quality.jitter = report.jitter || 0;
        quality.packetLoss = this.calculatePacketLoss(report);
      }
      
      if (report.type === 'candidate-pair' && report.state === 'succeeded') {
        quality.latency = report.currentRoundTripTime * 1000; // Convert to ms
      }
      
      if (report.type === 'transport') {
        quality.bandwidth = report.availableOutgoingBitrate || 0;
      }
    });
    
    return quality;
  }
  
  private analyzeQuality(stats: QualityStats): QualityMeasurement {
    let score = 100;
    
    // Deduct points for high latency
    if (stats.latency > 150) score -= 20;
    else if (stats.latency > 100) score -= 10;
    else if (stats.latency > 50) score -= 5;
    
    // Deduct points for packet loss
    if (stats.packetLoss > 5) score -= 30;
    else if (stats.packetLoss > 2) score -= 20;
    else if (stats.packetLoss > 1) score -= 10;
    
    // Deduct points for jitter
    if (stats.jitter > 30) score -= 20;
    else if (stats.jitter > 20) score -= 10;
    
    return {
      ...stats,
      score,
      quality: score > 80 ? 'excellent' : score > 60 ? 'good' : 'poor',
      timestamp: Date.now()
    };
  }
}
```

### 7. Participant Actions and Moderation
```tsx
export function ParticipantContextMenu({ 
  participant, 
  onClose 
}: { 
  participant: VoiceParticipant;
  onClose: () => void;
}) {
  const { currentUser } = useAuth();
  const { performAction } = useVoiceModeration();
  
  const actions = useMemo(() => {
    const available = [];
    
    if (participant.userId !== currentUser.id) {
      available.push({
        label: 'Adjust Volume',
        icon: <VolumeUpIcon />,
        action: () => openVolumeSlider(participant.userId)
      });
      
      if (hasPermission('MUTE_MEMBERS')) {
        available.push({
          label: participant.isMuted ? 'Unmute' : 'Mute',
          icon: participant.isMuted ? <MicIcon /> : <MicOffIcon />,
          action: () => performAction('toggle_mute', participant.userId)
        });
      }
      
      if (hasPermission('MOVE_MEMBERS')) {
        available.push({
          label: 'Move to Channel',
          icon: <MoveIcon />,
          action: () => openChannelSelector(participant.userId)
        });
      }
      
      if (hasPermission('KICK_MEMBERS')) {
        available.push({
          label: 'Disconnect',
          icon: <PhoneDisabledIcon />,
          action: () => performAction('disconnect', participant.userId),
          danger: true
        });
      }
    }
    
    return available;
  }, [participant, currentUser]);
  
  return (
    <ContextMenu onClose={onClose}>
      <div className="participant-header">
        <Avatar user={participant} size="small" />
        <span>{participant.username}</span>
      </div>
      
      <MenuDivider />
      
      {actions.map((action, index) => (
        <MenuItem
          key={index}
          onClick={() => {
            action.action();
            onClose();
          }}
          danger={action.danger}
        >
          {action.icon}
          <span>{action.label}</span>
        </MenuItem>
      ))}
    </ContextMenu>
  );
}
```

## Dependencies
- Voice Channel Model (Issue #13) for data structures
- RealTimeKit Session (Issue #14) for participant events
- WebSocket Architecture (Issue #04) for state sync
- Voice UI Components (Issue #15) for display

## Estimated Effort
**5 days**
- 1 day: Participant state model and manager
- 1 day: Speaking detection and audio levels
- 1 day: React components and animations
- 1 day: State synchronization via WebSocket
- 1 day: Connection monitoring and moderation

## Notes
- Optimize for large participant lists (100+ users)
- Consider virtual scrolling for performance
- Add participant search/filter for large channels
- Monitor memory usage with many participant updates