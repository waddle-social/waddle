# Issue #03: Unified Authentication System

## User Story
As a **user**, I want to **securely authenticate once** so that **I can access all waddle features including voice chat without re-authenticating**.

## Description
Implement a unified authentication system using WorkOS that provides secure access to all platform features. This includes web authentication, mobile app tokens, and RealTimeKit session authorization.

## Acceptance Criteria
- [ ] WorkOS integration configured for SSO and magic links
- [ ] JWT tokens work across web and mobile platforms
- [ ] Anonymous registration option available
- [ ] Session management in Durable Objects
- [ ] Token refresh mechanism implemented
- [ ] GDPR-compliant user data handling
- [ ] Logout invalidates all sessions

## Technical Implementation

### 1. WorkOS Configuration
```javascript
// Worker environment setup
const WORKOS_CONFIG = {
  apiKey: process.env.WORKOS_API_KEY,
  clientId: process.env.WORKOS_CLIENT_ID,
  redirectUri: process.env.WORKOS_REDIRECT_URI,
  providers: ['google', 'github', 'magic_link']
};

// Initialize WorkOS client
import { WorkOS } from '@workos-inc/node';
const workos = new WorkOS(WORKOS_CONFIG.apiKey);
```

### 2. Authentication Flow
```javascript
// Worker auth endpoints
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    switch (url.pathname) {
      case '/auth/login':
        return handleLogin(request, env);
      case '/auth/callback':
        return handleCallback(request, env);
      case '/auth/refresh':
        return handleRefresh(request, env);
      case '/auth/logout':
        return handleLogout(request, env);
      case '/auth/anonymous':
        return handleAnonymous(request, env);
    }
  }
};

async function handleLogin(request, env) {
  const { provider, email } = await request.json();
  
  if (provider === 'magic_link') {
    // Send magic link
    await workos.passwordless.createSession({
      email,
      type: 'MagicLink',
      redirectUri: env.WORKOS_REDIRECT_URI
    });
    
    return new Response(JSON.stringify({
      message: 'Check your email for login link'
    }));
  }
  
  // OAuth flow
  const authUrl = workos.sso.getAuthorizationUrl({
    provider,
    clientId: env.WORKOS_CLIENT_ID,
    redirectUri: env.WORKOS_REDIRECT_URI
  });
  
  return new Response(JSON.stringify({ authUrl }));
}
```

### 3. JWT Token Management
```javascript
// Token structure and signing
interface WaddleToken {
  sub: string;          // User ID
  email?: string;       // Optional for anonymous
  isAnonymous: boolean;
  permissions: string[];
  iat: number;
  exp: number;
}

async function generateTokens(user, env) {
  const accessPayload = {
    sub: user.id,
    email: user.email,
    isAnonymous: user.isAnonymous || false,
    permissions: user.permissions || ['read', 'write'],
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 900 // 15 minutes
  };
  
  const refreshPayload = {
    sub: user.id,
    type: 'refresh',
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 604800 // 7 days
  };
  
  const accessToken = await signJWT(accessPayload, env.JWT_SECRET);
  const refreshToken = await signJWT(refreshPayload, env.JWT_SECRET);
  
  // Store refresh token in DO
  await storeRefreshToken(user.id, refreshToken, env);
  
  return { accessToken, refreshToken };
}
```

### 4. Session Management with Durable Objects
```javascript
export class UserSessionDurableObject {
  constructor(state, env) {
    this.state = state;
    this.env = env;
  }
  
  async createSession(userId, metadata) {
    const sessionId = crypto.randomUUID();
    const session = {
      id: sessionId,
      userId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      deviceInfo: metadata.deviceInfo,
      ipAddress: metadata.ipAddress
    };
    
    // Store session
    await this.state.storage.put(`session:${sessionId}`, session);
    
    // Track active sessions
    const activeSessions = (await this.state.storage.get('activeSessions')) || [];
    activeSessions.push(sessionId);
    await this.state.storage.put('activeSessions', activeSessions);
    
    return session;
  }
  
  async validateSession(sessionId) {
    const session = await this.state.storage.get(`session:${sessionId}`);
    if (!session) return null;
    
    // Check if expired (24 hours)
    if (Date.now() - session.lastActivity > 86400000) {
      await this.revokeSession(sessionId);
      return null;
    }
    
    // Update activity
    session.lastActivity = Date.now();
    await this.state.storage.put(`session:${sessionId}`, session);
    
    return session;
  }
  
  async revokeAllSessions() {
    const activeSessions = (await this.state.storage.get('activeSessions')) || [];
    
    // Delete all sessions
    await Promise.all(
      activeSessions.map(id => this.state.storage.delete(`session:${id}`))
    );
    
    await this.state.storage.put('activeSessions', []);
  }
}
```

### 5. Anonymous Registration
```javascript
async function handleAnonymous(request, env) {
  // Generate anonymous user
  const userId = `anon_${crypto.randomUUID()}`;
  const username = generateRandomUsername(); // e.g., "CoolPenguin123"
  
  // Create user record
  const user = {
    id: userId,
    username,
    isAnonymous: true,
    createdAt: new Date().toISOString(),
    permissions: ['read', 'write', 'voice']
  };
  
  // Store in D1
  await env.USERS_DB.prepare(`
    INSERT INTO users (id, username, is_anonymous, created_at)
    VALUES (?, ?, ?, ?)
  `).bind(userId, username, true, user.createdAt).run();
  
  // Generate tokens
  const tokens = await generateTokens(user, env);
  
  return new Response(JSON.stringify({
    user,
    ...tokens
  }));
}
```

### 6. GDPR Compliance
```javascript
class GDPRCompliantAuth {
  static async exportUserData(userId, env) {
    const data = {
      profile: await env.USERS_DB.prepare(
        'SELECT * FROM users WHERE id = ?'
      ).bind(userId).first(),
      
      sessions: await this.getActiveSessions(userId, env),
      
      consent: await env.USERS_DB.prepare(
        'SELECT * FROM user_consent WHERE user_id = ?'
      ).bind(userId).all()
    };
    
    return data;
  }
  
  static async deleteUser(userId, env) {
    // Revoke all sessions
    const doId = env.SESSION_DO.idFromName(userId);
    const stub = env.SESSION_DO.get(doId);
    await stub.revokeAllSessions();
    
    // Delete from all databases
    await env.USERS_DB.prepare(
      'DELETE FROM users WHERE id = ?'
    ).bind(userId).run();
    
    // Queue deletion from waddle databases
    await env.DELETION_QUEUE.send({
      type: 'delete_user',
      userId,
      timestamp: Date.now()
    });
  }
}
```

### 7. Mobile Token Handling
```typescript
// Kotlin (Android)
class AuthManager(private val context: Context) {
    private val prefs = context.getSharedPreferences("auth", Context.MODE_PRIVATE)
    
    suspend fun authenticate(): AuthResult {
        // Check stored tokens
        val refreshToken = prefs.getString("refresh_token", null)
        
        if (refreshToken != null) {
            return refreshAccessToken(refreshToken)
        }
        
        // New login flow
        return initiateLogin()
    }
    
    private suspend fun refreshAccessToken(refreshToken: String): AuthResult {
        val response = apiClient.post("/auth/refresh") {
            body = RefreshRequest(refreshToken)
        }
        
        return when (response.status) {
            HttpStatusCode.OK -> {
                val tokens = response.body<TokenResponse>()
                saveTokens(tokens)
                AuthResult.Success(tokens)
            }
            else -> AuthResult.NeedsLogin
        }
    }
}
```

## Dependencies
- WorkOS account and API keys
- D1 database for user storage
- JWT library for token generation

## Estimated Effort
**4 days**
- 1 day: WorkOS integration
- 1 day: Token management and JWT
- 1 day: Session DO implementation
- 1 day: GDPR compliance and testing

## Notes
- Consider rate limiting on auth endpoints
- Implement proper CORS for web clients
- Plan for social login providers based on user feedback
- Monitor WorkOS usage limits