# Issue #46: iOS Setup

## User Story
As a **waddle developer**, I want to **set up the iOS Swift project structure** so that **we can build a native iOS app with proper architecture and development practices**.

## Description
Initialize and configure the iOS Swift project for Waddle, including project structure, dependencies, build configurations, and core infrastructure. This establishes the foundation for all iOS-specific features and ensures proper development workflow.

## Acceptance Criteria
- [ ] Xcode project setup with proper structure
- [ ] Swift Package Manager configuration
- [ ] Core architecture implementation (MVVM/Clean)
- [ ] Dependency injection setup
- [ ] Network layer foundation
- [ ] Local storage configuration
- [ ] Build configurations (Debug/Release/Staging)
- [ ] CI/CD pipeline setup

## Technical Implementation

### 1. Project Structure
```swift
// Project structure
/*
WaddleIOS/
├── Waddle.xcodeproj
├── Waddle/
│   ├── App/
│   │   ├── WaddleApp.swift
│   │   ├── AppDelegate.swift
│   │   └── SceneDelegate.swift
│   ├── Core/
│   │   ├── Network/
│   │   ├── Storage/
│   │   ├── Extensions/
│   │   └── Utilities/
│   ├── Features/
│   │   ├── Auth/
│   │   ├── Voice/
│   │   ├── Chat/
│   │   └── Settings/
│   ├── UI/
│   │   ├── Components/
│   │   ├── Styles/
│   │   └── Theme/
│   ├── Resources/
│   │   ├── Assets.xcassets
│   │   ├── Localizable.strings
│   │   └── Info.plist
│   └── Config/
│       ├── Debug.xcconfig
│       ├── Release.xcconfig
│       └── Staging.xcconfig
├── WaddleTests/
├── WaddleUITests/
└── Packages/
    ├── WaddleCore/
    ├── WaddleUI/
    └── WaddleVoice/
*/

// App entry point
import SwiftUI

@main
struct WaddleApp: App {
    @StateObject private var appState = AppState()
    @StateObject private var authManager = AuthManager()
    
    init() {
        setupApp()
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
                .environmentObject(authManager)
                .onAppear {
                    handleAppLaunch()
                }
        }
    }
    
    private func setupApp() {
        // Configure appearance
        UINavigationBar.appearance().tintColor = .waddlePrimary
        
        // Setup crash reporting
        CrashReporter.shared.setup()
        
        // Configure logging
        LoggingSystem.bootstrap(WaddleLogHandler.init)
        
        // Initialize services
        ServiceLocator.shared.register()
    }
    
    private func handleAppLaunch() {
        // Check for updates
        UpdateManager.shared.checkForUpdates()
        
        // Restore session
        authManager.restoreSession()
        
        // Setup push notifications
        PushNotificationManager.shared.requestAuthorization()
    }
}
```

### 2. Core Architecture
```swift
// MVVM + Clean Architecture

// Domain Layer
protocol WaddleRepository {
    func getWaddles() async throws -> [Waddle]
    func getWaddle(id: String) async throws -> Waddle
    func createWaddle(_ waddle: Waddle) async throws -> Waddle
    func updateWaddle(_ waddle: Waddle) async throws -> Waddle
    func deleteWaddle(id: String) async throws
}

// Use Case
protocol GetWaddlesUseCase {
    func execute() async throws -> [Waddle]
}

class GetWaddlesUseCaseImpl: GetWaddlesUseCase {
    private let repository: WaddleRepository
    
    init(repository: WaddleRepository) {
        self.repository = repository
    }
    
    func execute() async throws -> [Waddle] {
        return try await repository.getWaddles()
    }
}

// Presentation Layer - ViewModel
@MainActor
class WaddleListViewModel: ObservableObject {
    @Published private(set) var waddles: [Waddle] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private let getWaddlesUseCase: GetWaddlesUseCase
    private var cancellables = Set<AnyCancellable>()
    
    init(getWaddlesUseCase: GetWaddlesUseCase) {
        self.getWaddlesUseCase = getWaddlesUseCase
    }
    
    func loadWaddles() {
        Task {
            await loadWaddlesAsync()
        }
    }
    
    @MainActor
    private func loadWaddlesAsync() async {
        isLoading = true
        error = nil
        
        do {
            waddles = try await getWaddlesUseCase.execute()
        } catch {
            self.error = error
            Logger.error("Failed to load waddles: \(error)")
        }
        
        isLoading = false
    }
}

// View
struct WaddleListView: View {
    @StateObject private var viewModel: WaddleListViewModel
    
    init(viewModel: @autoclosure @escaping () -> WaddleListViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel())
    }
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.isLoading {
                    ProgressView()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if let error = viewModel.error {
                    ErrorView(error: error) {
                        viewModel.loadWaddles()
                    }
                } else {
                    waddleList
                }
            }
            .navigationTitle("Waddles")
            .onAppear {
                viewModel.loadWaddles()
            }
        }
    }
    
    private var waddleList: some View {
        List(viewModel.waddles) { waddle in
            NavigationLink(destination: WaddleDetailView(waddle: waddle)) {
                WaddleRow(waddle: waddle)
            }
        }
        .refreshable {
            await viewModel.loadWaddlesAsync()
        }
    }
}
```

### 3. Dependency Injection
```swift
// Service Locator pattern with property wrappers
protocol ServiceLocating {
    func register<T>(service: T, for type: T.Type)
    func resolve<T>(_ type: T.Type) -> T?
}

final class ServiceLocator: ServiceLocating {
    static let shared = ServiceLocator()
    
    private var services: [String: Any] = [:]
    
    private init() {}
    
    func register<T>(service: T, for type: T.Type) {
        let key = String(describing: type)
        services[key] = service
    }
    
    func resolve<T>(_ type: T.Type) -> T? {
        let key = String(describing: type)
        return services[key] as? T
    }
    
    func register() {
        // Register all services
        registerNetworking()
        registerRepositories()
        registerUseCases()
        registerManagers()
    }
    
    private func registerNetworking() {
        let urlSession = URLSession(configuration: .default)
        let networkClient = NetworkClient(session: urlSession)
        register(service: networkClient, for: NetworkClient.self)
        
        let apiClient = APIClient(networkClient: networkClient)
        register(service: apiClient, for: APIClient.self)
    }
    
    private func registerRepositories() {
        let waddleRepository = WaddleRepositoryImpl(
            apiClient: resolve(APIClient.self)!,
            localStorage: LocalStorage.shared
        )
        register(service: waddleRepository as WaddleRepository, for: WaddleRepository.self)
    }
    
    private func registerUseCases() {
        let getWaddlesUseCase = GetWaddlesUseCaseImpl(
            repository: resolve(WaddleRepository.self)!
        )
        register(service: getWaddlesUseCase as GetWaddlesUseCase, for: GetWaddlesUseCase.self)
    }
    
    private func registerManagers() {
        let authManager = AuthManager(
            apiClient: resolve(APIClient.self)!,
            keychain: KeychainManager.shared
        )
        register(service: authManager, for: AuthManager.self)
    }
}

// Property wrapper for dependency injection
@propertyWrapper
struct Injected<T> {
    private let type: T.Type
    
    init(_ type: T.Type) {
        self.type = type
    }
    
    var wrappedValue: T {
        guard let service = ServiceLocator.shared.resolve(type) else {
            fatalError("Service of type \(type) not registered")
        }
        return service
    }
}

// Usage
class SomeViewModel {
    @Injected(WaddleRepository.self) private var repository
    @Injected(AuthManager.self) private var authManager
}
```

### 4. Network Layer
```swift
// Network client
protocol NetworkClientProtocol {
    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T
    func upload(_ endpoint: Endpoint, data: Data) async throws -> UploadResponse
    func download(_ endpoint: Endpoint) async throws -> Data
}

class NetworkClient: NetworkClientProtocol {
    private let session: URLSession
    private let decoder = JSONDecoder()
    private let encoder = JSONEncoder()
    
    init(session: URLSession) {
        self.session = session
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        encoder.keyEncodingStrategy = .convertToSnakeCase
    }
    
    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
        let request = try buildRequest(from: endpoint)
        
        let (data, response) = try await session.data(for: request)
        
        try validateResponse(response)
        
        do {
            return try decoder.decode(T.self, from: data)
        } catch {
            throw NetworkError.decodingFailed(error)
        }
    }
    
    private func buildRequest(from endpoint: Endpoint) throws -> URLRequest {
        guard let url = endpoint.url else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = endpoint.method.rawValue
        request.allHTTPHeaderFields = endpoint.headers
        
        if let body = endpoint.body {
            request.httpBody = try encoder.encode(body)
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Add authentication if available
        if let token = AuthManager.shared.accessToken {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        return request
    }
    
    private func validateResponse(_ response: URLResponse) throws {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        switch httpResponse.statusCode {
        case 200...299:
            return
        case 401:
            throw NetworkError.unauthorized
        case 404:
            throw NetworkError.notFound
        case 500...599:
            throw NetworkError.serverError(httpResponse.statusCode)
        default:
            throw NetworkError.httpError(httpResponse.statusCode)
        }
    }
}

// Endpoint definition
struct Endpoint {
    let path: String
    let method: HTTPMethod
    let headers: [String: String]?
    let body: Encodable?
    let queryItems: [URLQueryItem]?
    
    var url: URL? {
        var components = URLComponents()
        components.scheme = APIConfig.scheme
        components.host = APIConfig.host
        components.path = "/api/v1" + path
        components.queryItems = queryItems
        return components.url
    }
}

// API Client
class APIClient {
    private let networkClient: NetworkClientProtocol
    
    init(networkClient: NetworkClientProtocol) {
        self.networkClient = networkClient
    }
    
    // Waddle endpoints
    func getWaddles() async throws -> [Waddle] {
        let endpoint = Endpoint(
            path: "/waddles",
            method: .get,
            headers: nil,
            body: nil,
            queryItems: nil
        )
        return try await networkClient.request(endpoint)
    }
    
    func createWaddle(_ waddle: CreateWaddleRequest) async throws -> Waddle {
        let endpoint = Endpoint(
            path: "/waddles",
            method: .post,
            headers: nil,
            body: waddle,
            queryItems: nil
        )
        return try await networkClient.request(endpoint)
    }
}
```

### 5. Local Storage
```swift
// Core Data stack
class CoreDataStack {
    static let shared = CoreDataStack()
    
    private lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "WaddleModel")
        
        // Enable lightweight migration
        let description = container.persistentStoreDescriptions.first
        description?.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
        description?.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
        
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Failed to load Core Data stack: \(error)")
            }
        }
        
        container.viewContext.automaticallyMergesChangesFromParent = true
        
        return container
    }()
    
    var viewContext: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    func newBackgroundContext() -> NSManagedObjectContext {
        persistentContainer.newBackgroundContext()
    }
    
    func save() throws {
        guard viewContext.hasChanges else { return }
        try viewContext.save()
    }
}

// Keychain wrapper
class KeychainManager {
    static let shared = KeychainManager()
    
    private let serviceName = "com.waddle.ios"
    
    private init() {}
    
    func save(_ value: String, for key: String) throws {
        guard let data = value.data(using: .utf8) else {
            throw KeychainError.encodingFailed
        }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecValueData as String: data
        ]
        
        // Delete existing item
        SecItemDelete(query as CFDictionary)
        
        // Add new item
        let status = SecItemAdd(query as CFDictionary, nil)
        
        guard status == errSecSuccess else {
            throw KeychainError.saveFailed(status)
        }
    }
    
    func get(_ key: String) throws -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        guard status == errSecSuccess else {
            if status == errSecItemNotFound {
                return nil
            }
            throw KeychainError.retrievalFailed(status)
        }
        
        guard let data = result as? Data,
              let value = String(data: data, encoding: .utf8) else {
            throw KeychainError.decodingFailed
        }
        
        return value
    }
    
    func delete(_ key: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.deletionFailed(status)
        }
    }
}

// UserDefaults wrapper
@propertyWrapper
struct UserDefault<T> {
    let key: String
    let defaultValue: T
    
    var wrappedValue: T {
        get {
            UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}

// Usage
struct AppSettings {
    @UserDefault(key: "pushNotificationsEnabled", defaultValue: true)
    static var pushNotificationsEnabled: Bool
    
    @UserDefault(key: "selectedTheme", defaultValue: "system")
    static var selectedTheme: String
    
    @UserDefault(key: "voiceQuality", defaultValue: "high")
    static var voiceQuality: String
}
```

### 6. Build Configurations
```swift
// Configuration management
enum Environment: String {
    case debug
    case staging
    case release
    
    static var current: Environment {
        #if DEBUG
        return .debug
        #elseif STAGING
        return .staging
        #else
        return .release
        #endif
    }
}

struct APIConfig {
    static var scheme: String {
        switch Environment.current {
        case .debug:
            return "http"
        case .staging, .release:
            return "https"
        }
    }
    
    static var host: String {
        switch Environment.current {
        case .debug:
            return "localhost:3000"
        case .staging:
            return "staging.waddle.chat"
        case .release:
            return "api.waddle.chat"
        }
    }
    
    static var websocketURL: String {
        switch Environment.current {
        case .debug:
            return "ws://localhost:3000/ws"
        case .staging:
            return "wss://staging.waddle.chat/ws"
        case .release:
            return "wss://api.waddle.chat/ws"
        }
    }
}

// Build configuration files
/*
Debug.xcconfig:
SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG
API_URL = http://localhost:3000
ENABLE_TESTABILITY = YES

Staging.xcconfig:
SWIFT_ACTIVE_COMPILATION_CONDITIONS = STAGING
API_URL = https://staging.waddle.chat
ENABLE_TESTABILITY = NO

Release.xcconfig:
SWIFT_ACTIVE_COMPILATION_CONDITIONS = RELEASE
API_URL = https://api.waddle.chat
ENABLE_TESTABILITY = NO
*/
```

### 7. CI/CD Setup
```yaml
# .github/workflows/ios.yml
name: iOS CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: macos-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install dependencies
      run: |
        brew install swiftlint
        bundle install
    
    - name: Run SwiftLint
      run: swiftlint
    
    - name: Run tests
      run: |
        xcodebuild test \
          -project Waddle.xcodeproj \
          -scheme Waddle \
          -destination 'platform=iOS Simulator,name=iPhone 14 Pro'
    
    - name: Build app
      run: |
        xcodebuild build \
          -project Waddle.xcodeproj \
          -scheme Waddle \
          -configuration Release \
          -derivedDataPath build
    
  deploy:
    needs: test
    runs-on: macos-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install Fastlane
      run: bundle install
    
    - name: Deploy to TestFlight
      env:
        FASTLANE_APPLE_ID: ${{ secrets.APPLE_ID }}
        FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      run: bundle exec fastlane beta
```

## Dependencies
- Swift 5.9+
- iOS 16.0+
- SwiftUI
- Combine
- Core Data
- Swift Package Manager

## Estimated Effort
**5 days**
- 1 day: Project setup and configuration
- 1 day: Core architecture implementation
- 1 day: Network and storage layers
- 1 day: Build configurations and CI/CD
- 1 day: Testing setup and documentation

## Notes
- Use Swift Package Manager for dependencies
- Implement proper error handling throughout
- Follow Apple's Human Interface Guidelines
- Plan for App Store submission requirements
- Consider modularization for better testability