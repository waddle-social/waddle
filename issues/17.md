# Issue #17: Voice Controls (PTT & Activity Detection)

## User Story
As a **user**, I want to **control when my microphone transmits audio** so that **I have privacy and don't accidentally broadcast unwanted sounds**.

## Description
Implement comprehensive voice activation controls including Push-to-Talk (PTT), Voice Activity Detection (VAD), and input sensitivity settings. This ensures users have full control over their microphone transmission with both automatic and manual options.

## Acceptance Criteria
- [ ] Push-to-Talk mode with customizable keybind
- [ ] Voice Activity Detection with sensitivity control
- [ ] Visual indicators for microphone activation
- [ ] Input sensitivity calibration
- [ ] Noise gate implementation
- [ ] PTT release delay setting
- [ ] Mobile-friendly PTT button
- [ ] Hybrid mode (PTT priority over VAD)

## Technical Implementation

### 1. Voice Activation Manager
```typescript
export enum VoiceActivationMode {
  VOICE_ACTIVITY = 'voice_activity',
  PUSH_TO_TALK = 'push_to_talk',
  HYBRID = 'hybrid', // PTT overrides VAD
  ALWAYS_ON = 'always_on'
}

export class VoiceActivationManager {
  private mode: VoiceActivationMode = VoiceActivationMode.VOICE_ACTIVITY;
  private vadProcessor: VoiceActivityDetector | null = null;
  private pttHandler: PushToTalkHandler | null = null;
  private isTransmitting = false;
  private callbacks: Set<(transmitting: boolean) => void> = new Set();
  
  constructor(private rtk: RealtimeKit) {
    this.loadSettings();
    this.initializeMode();
  }
  
  async setMode(mode: VoiceActivationMode): Promise<void> {
    this.mode = mode;
    await this.saveSettings();
    
    // Clean up previous mode
    this.cleanup();
    
    // Initialize new mode
    this.initializeMode();
  }
  
  private initializeMode(): void {
    switch (this.mode) {
      case VoiceActivationMode.VOICE_ACTIVITY:
        this.initializeVAD();
        break;
        
      case VoiceActivationMode.PUSH_TO_TALK:
        this.initializePTT();
        break;
        
      case VoiceActivationMode.HYBRID:
        this.initializeVAD();
        this.initializePTT();
        break;
        
      case VoiceActivationMode.ALWAYS_ON:
        this.setTransmitting(true);
        break;
    }
  }
  
  private initializeVAD(): void {
    this.vadProcessor = new VoiceActivityDetector({
      sensitivity: this.settings.vadSensitivity,
      noiseGate: this.settings.noiseGateThreshold,
      onActivity: (active) => this.handleVADActivity(active)
    });
    
    this.vadProcessor.start();
  }
  
  private initializePTT(): void {
    this.pttHandler = new PushToTalkHandler({
      keybind: this.settings.pttKeybind,
      releaseDelay: this.settings.pttReleaseDelay,
      onPTT: (pressed) => this.handlePTT(pressed)
    });
    
    this.pttHandler.start();
  }
  
  private handleVADActivity(active: boolean): void {
    if (this.mode === VoiceActivationMode.VOICE_ACTIVITY) {
      this.setTransmitting(active);
    } else if (this.mode === VoiceActivationMode.HYBRID && !this.pttHandler?.isPressed()) {
      // In hybrid mode, VAD only works when PTT is not pressed
      this.setTransmitting(active);
    }
  }
  
  private handlePTT(pressed: boolean): void {
    if (this.mode === VoiceActivationMode.PUSH_TO_TALK || 
        this.mode === VoiceActivationMode.HYBRID) {
      this.setTransmitting(pressed);
    }
  }
  
  private setTransmitting(transmitting: boolean): void {
    if (this.isTransmitting === transmitting) return;
    
    this.isTransmitting = transmitting;
    
    // Update RealTimeKit
    this.rtk.setAudioEnabled(transmitting);
    
    // Notify listeners
    this.callbacks.forEach(callback => callback(transmitting));
  }
  
  onTransmittingChange(callback: (transmitting: boolean) => void): () => void {
    this.callbacks.add(callback);
    return () => this.callbacks.delete(callback);
  }
}
```

### 2. Voice Activity Detection
```typescript
export class VoiceActivityDetector {
  private analyser: AnalyserNode;
  private microphone: MediaStreamAudioSourceNode;
  private isActive = false;
  private activityTimeout: NodeJS.Timeout | null = null;
  private smoothingBuffer: number[] = [];
  private readonly BUFFER_SIZE = 10;
  
  constructor(
    private options: {
      sensitivity: number; // 0-100
      noiseGate: number; // 0-100
      onActivity: (active: boolean) => void;
    }
  ) {
    this.setupAudioProcessing();
  }
  
  private async setupAudioProcessing(): Promise<void> {
    const audioContext = new AudioContext();
    
    // Get microphone stream
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });
    
    // Create nodes
    this.microphone = audioContext.createMediaStreamSource(stream);
    this.analyser = audioContext.createAnalyser();
    
    // Configure analyser
    this.analyser.fftSize = 512;
    this.analyser.smoothingTimeConstant = 0.3;
    
    // Connect nodes
    this.microphone.connect(this.analyser);
    
    // Start monitoring
    this.monitor();
  }
  
  private monitor(): void {
    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteFrequencyData(dataArray);
    
    // Calculate RMS (Root Mean Square) for better accuracy
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      sum += dataArray[i] * dataArray[i];
    }
    const rms = Math.sqrt(sum / dataArray.length);
    const normalizedLevel = (rms / 255) * 100;
    
    // Apply smoothing
    this.smoothingBuffer.push(normalizedLevel);
    if (this.smoothingBuffer.length > this.BUFFER_SIZE) {
      this.smoothingBuffer.shift();
    }
    
    const smoothedLevel = this.smoothingBuffer.reduce((a, b) => a + b, 0) / this.smoothingBuffer.length;
    
    // Apply sensitivity and noise gate
    const threshold = this.calculateThreshold();
    const gateThreshold = this.options.noiseGate;
    
    const shouldActivate = smoothedLevel > threshold && smoothedLevel > gateThreshold;
    
    if (shouldActivate && !this.isActive) {
      this.setActive(true);
    } else if (!shouldActivate && this.isActive) {
      // Delay deactivation to prevent choppy audio
      this.scheduleDeactivation();
    }
    
    // Continue monitoring
    requestAnimationFrame(() => this.monitor());
  }
  
  private calculateThreshold(): number {
    // Convert sensitivity (0-100) to threshold (100-0)
    // Higher sensitivity = lower threshold
    return 100 - this.options.sensitivity;
  }
  
  private setActive(active: boolean): void {
    if (this.activityTimeout) {
      clearTimeout(this.activityTimeout);
      this.activityTimeout = null;
    }
    
    this.isActive = active;
    this.options.onActivity(active);
  }
  
  private scheduleDeactivation(): void {
    if (this.activityTimeout) return;
    
    this.activityTimeout = setTimeout(() => {
      this.setActive(false);
      this.activityTimeout = null;
    }, 250); // 250ms delay
  }
  
  updateSensitivity(sensitivity: number): void {
    this.options.sensitivity = Math.max(0, Math.min(100, sensitivity));
  }
  
  updateNoiseGate(threshold: number): void {
    this.options.noiseGate = Math.max(0, Math.min(100, threshold));
  }
}
```

### 3. Push-to-Talk Handler
```typescript
export class PushToTalkHandler {
  private isPressed = false;
  private releaseTimeout: NodeJS.Timeout | null = null;
  private keybind: KeyBinding;
  private globalKeyHandler: GlobalKeyHandler | null = null;
  
  constructor(
    private options: {
      keybind: KeyBinding;
      releaseDelay: number; // ms
      onPTT: (pressed: boolean) => void;
    }
  ) {
    this.keybind = options.keybind;
    this.initialize();
  }
  
  private initialize(): void {
    // Web keyboard handler
    this.setupWebHandler();
    
    // Global hotkey handler for desktop app
    if (this.isDesktopApp()) {
      this.setupGlobalHandler();
    }
    
    // Mobile touch handler
    if (this.isMobile()) {
      this.setupTouchHandler();
    }
  }
  
  private setupWebHandler(): void {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (this.matchesKeybind(e) && !e.repeat) {
        e.preventDefault();
        this.handlePress();
      }
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      if (this.matchesKeybind(e)) {
        e.preventDefault();
        this.handleRelease();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    
    // Handle window blur (release PTT when window loses focus)
    window.addEventListener('blur', () => {
      if (this.isPressed) {
        this.handleRelease();
      }
    });
  }
  
  private matchesKeybind(event: KeyboardEvent): boolean {
    const { key, ctrlKey, altKey, shiftKey, metaKey } = event;
    
    return (
      key.toLowerCase() === this.keybind.key.toLowerCase() &&
      ctrlKey === this.keybind.ctrl &&
      altKey === this.keybind.alt &&
      shiftKey === this.keybind.shift &&
      metaKey === this.keybind.meta
    );
  }
  
  private handlePress(): void {
    if (this.releaseTimeout) {
      clearTimeout(this.releaseTimeout);
      this.releaseTimeout = null;
    }
    
    if (!this.isPressed) {
      this.isPressed = true;
      this.options.onPTT(true);
    }
  }
  
  private handleRelease(): void {
    if (!this.isPressed) return;
    
    // Apply release delay
    if (this.options.releaseDelay > 0) {
      this.releaseTimeout = setTimeout(() => {
        this.isPressed = false;
        this.options.onPTT(false);
        this.releaseTimeout = null;
      }, this.options.releaseDelay);
    } else {
      this.isPressed = false;
      this.options.onPTT(false);
    }
  }
  
  updateKeybind(keybind: KeyBinding): void {
    this.keybind = keybind;
    // Re-initialize handlers
    this.cleanup();
    this.initialize();
  }
}
```

### 4. Input Sensitivity Calibration
```typescript
export class InputSensitivityCalibrator {
  private samples: number[] = [];
  private isCalibrating = false;
  private noiseFloor = 0;
  private speakingLevel = 0;
  
  async calibrate(): Promise<CalibrationResult> {
    this.samples = [];
    this.isCalibrating = true;
    
    try {
      // Step 1: Measure noise floor
      const noiseFloor = await this.measureNoiseFloor();
      
      // Step 2: Measure speaking level
      const speakingLevel = await this.measureSpeakingLevel();
      
      // Step 3: Calculate optimal settings
      const settings = this.calculateOptimalSettings(noiseFloor, speakingLevel);
      
      return {
        success: true,
        noiseFloor,
        speakingLevel,
        recommendedSettings: settings
      };
      
    } catch (error) {
      return {
        success: false,
        error: 'Calibration failed'
      };
    } finally {
      this.isCalibrating = false;
    }
  }
  
  private async measureNoiseFloor(): Promise<number> {
    return new Promise((resolve) => {
      const ui = new CalibrationUI({
        title: 'Measuring Background Noise',
        instruction: 'Please remain quiet for 3 seconds',
        duration: 3000
      });
      
      ui.show();
      
      const samples: number[] = [];
      const collector = new AudioLevelCollector({
        onLevel: (level) => samples.push(level),
        onComplete: () => {
          const average = samples.reduce((a, b) => a + b, 0) / samples.length;
          this.noiseFloor = average;
          ui.close();
          resolve(average);
        }
      });
      
      collector.start(3000);
    });
  }
  
  private async measureSpeakingLevel(): Promise<number> {
    return new Promise((resolve) => {
      const ui = new CalibrationUI({
        title: 'Measuring Speaking Level',
        instruction: 'Please speak normally for 5 seconds',
        duration: 5000,
        showLevel: true
      });
      
      ui.show();
      
      const samples: number[] = [];
      const collector = new AudioLevelCollector({
        onLevel: (level) => {
          samples.push(level);
          ui.updateLevel(level);
        },
        onComplete: () => {
          // Take 75th percentile to avoid peaks
          samples.sort((a, b) => a - b);
          const percentileIndex = Math.floor(samples.length * 0.75);
          const speakingLevel = samples[percentileIndex];
          
          this.speakingLevel = speakingLevel;
          ui.close();
          resolve(speakingLevel);
        }
      });
      
      collector.start(5000);
    });
  }
  
  private calculateOptimalSettings(
    noiseFloor: number, 
    speakingLevel: number
  ): VoiceSettings {
    // Add 20% margin above noise floor
    const noiseGate = Math.min(noiseFloor * 1.2, speakingLevel * 0.3);
    
    // Set activation threshold between noise and speaking
    const activationThreshold = noiseFloor + (speakingLevel - noiseFloor) * 0.3;
    
    // Convert to 0-100 scale
    const sensitivity = 100 - activationThreshold;
    
    return {
      vadSensitivity: Math.round(sensitivity),
      noiseGateThreshold: Math.round(noiseGate),
      mode: noiseFloor < 20 ? 
        VoiceActivationMode.VOICE_ACTIVITY : 
        VoiceActivationMode.PUSH_TO_TALK
    };
  }
}
```

### 5. Mobile PTT Implementation
```tsx
export function MobilePTTButton() {
  const { mode, isTransmitting, setPTTState } = useVoiceActivation();
  const [isHolding, setIsHolding] = useState(false);
  const longPressTimer = useRef<NodeJS.Timeout>();
  
  if (mode !== VoiceActivationMode.PUSH_TO_TALK && 
      mode !== VoiceActivationMode.HYBRID) {
    return null;
  }
  
  const handleTouchStart = (e: React.TouchEvent) => {
    e.preventDefault();
    setIsHolding(true);
    setPTTState(true);
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate(50);
    }
    
    // Visual feedback
    longPressTimer.current = setTimeout(() => {
      setIsHolding(false);
    }, 10000); // Max 10 seconds hold
  };
  
  const handleTouchEnd = (e: React.TouchEvent) => {
    e.preventDefault();
    setIsHolding(false);
    setPTTState(false);
    
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
    }
  };
  
  return (
    <div className="mobile-ptt-container">
      <button
        className={`ptt-button ${isHolding ? 'active' : ''} ${isTransmitting ? 'transmitting' : ''}`}
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
        onTouchCancel={handleTouchEnd}
        aria-label="Push to Talk"
      >
        <div className="ptt-icon">
          {isTransmitting ? <MicIcon /> : <MicOffIcon />}
        </div>
        <div className="ptt-ripple" />
      </button>
      
      {isHolding && (
        <div className="ptt-indicator">
          <span>Release to stop talking</span>
        </div>
      )}
    </div>
  );
}
```

### 6. Voice Control Settings UI
```tsx
export function VoiceControlSettings() {
  const { settings, updateSettings } = useVoiceSettings();
  const [isCalibrating, setIsCalibrating] = useState(false);
  const [testingMode, setTestingMode] = useState(false);
  
  const handleCalibrate = async () => {
    setIsCalibrating(true);
    
    const calibrator = new InputSensitivityCalibrator();
    const result = await calibrator.calibrate();
    
    if (result.success) {
      await updateSettings({
        vadSensitivity: result.recommendedSettings.vadSensitivity,
        noiseGateThreshold: result.recommendedSettings.noiseGateThreshold
      });
    }
    
    setIsCalibrating(false);
  };
  
  return (
    <SettingsSection title="Voice Activation">
      <SettingRow label="Mode">
        <Select
          value={settings.voiceMode}
          onChange={(mode) => updateSettings({ voiceMode: mode })}
          options={[
            { value: 'voice_activity', label: 'Voice Activity' },
            { value: 'push_to_talk', label: 'Push to Talk' },
            { value: 'hybrid', label: 'Hybrid (PTT + VAD)' },
            { value: 'always_on', label: 'Always On' }
          ]}
        />
      </SettingRow>
      
      {(settings.voiceMode === 'voice_activity' || 
        settings.voiceMode === 'hybrid') && (
        <>
          <SettingRow label="Sensitivity">
            <div className="sensitivity-control">
              <Slider
                value={settings.vadSensitivity}
                onChange={(value) => updateSettings({ vadSensitivity: value })}
                min={0}
                max={100}
                disabled={isCalibrating}
              />
              <span className="sensitivity-value">
                {settings.vadSensitivity}%
              </span>
            </div>
          </SettingRow>
          
          <SettingRow label="Noise Gate">
            <div className="noise-gate-control">
              <Slider
                value={settings.noiseGateThreshold}
                onChange={(value) => updateSettings({ noiseGateThreshold: value })}
                min={0}
                max={100}
                disabled={isCalibrating}
              />
              <span className="gate-value">
                {settings.noiseGateThreshold}%
              </span>
            </div>
          </SettingRow>
          
          <SettingRow>
            <Button
              onClick={handleCalibrate}
              disabled={isCalibrating}
              variant="secondary"
            >
              {isCalibrating ? 'Calibrating...' : 'Auto-Calibrate'}
            </Button>
          </SettingRow>
        </>
      )}
      
      {(settings.voiceMode === 'push_to_talk' || 
        settings.voiceMode === 'hybrid') && (
        <>
          <SettingRow label="PTT Keybind">
            <KeybindInput
              value={settings.pttKeybind}
              onChange={(keybind) => updateSettings({ pttKeybind: keybind })}
            />
          </SettingRow>
          
          <SettingRow label="PTT Release Delay">
            <div className="delay-control">
              <Slider
                value={settings.pttReleaseDelay}
                onChange={(value) => updateSettings({ pttReleaseDelay: value })}
                min={0}
                max={1000}
                step={50}
              />
              <span className="delay-value">
                {settings.pttReleaseDelay}ms
              </span>
            </div>
          </SettingRow>
        </>
      )}
      
      <SettingRow>
        <Button
          onClick={() => setTestingMode(!testingMode)}
          variant="secondary"
        >
          {testingMode ? 'Stop Testing' : 'Test Settings'}
        </Button>
      </SettingRow>
      
      {testingMode && <VoiceTestArea settings={settings} />}
    </SettingsSection>
  );
}
```

### 7. Visual Indicators
```tsx
export function VoiceTransmissionIndicator() {
  const { isTransmitting, mode, audioLevel } = useVoiceActivation();
  const [showTooltip, setShowTooltip] = useState(false);
  
  const getIndicatorColor = () => {
    if (!isTransmitting) return 'gray';
    if (audioLevel > 80) return 'red';
    if (audioLevel > 50) return 'yellow';
    return 'green';
  };
  
  const getModeIcon = () => {
    switch (mode) {
      case VoiceActivationMode.VOICE_ACTIVITY:
        return <VoiceIcon />;
      case VoiceActivationMode.PUSH_TO_TALK:
        return <KeyboardIcon />;
      case VoiceActivationMode.HYBRID:
        return <HybridIcon />;
      default:
        return <MicIcon />;
    }
  };
  
  return (
    <div 
      className="voice-transmission-indicator"
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
    >
      <div className={`indicator-light ${getIndicatorColor()}`}>
        {isTransmitting && (
          <div className="pulse-animation" />
        )}
      </div>
      
      <div className="mode-icon">
        {getModeIcon()}
      </div>
      
      {isTransmitting && (
        <div className="audio-level-bars">
          <AudioLevelVisualizer level={audioLevel} />
        </div>
      )}
      
      {showTooltip && (
        <Tooltip>
          <div className="transmission-info">
            <div>Mode: {mode.replace('_', ' ')}</div>
            <div>Status: {isTransmitting ? 'Transmitting' : 'Idle'}</div>
            {isTransmitting && (
              <div>Level: {audioLevel}%</div>
            )}
          </div>
        </Tooltip>
      )}
    </div>
  );
}
```

## Dependencies
- Voice UI Components (Issue #15) for integration
- Audio Permissions (Issue #16) for microphone access
- RealTimeKit Session (Issue #14) for audio control

## Estimated Effort
**5 days**
- 1 day: Core activation manager and mode switching
- 1 day: Voice Activity Detection implementation
- 1 day: Push-to-Talk with keybinds
- 1 day: Calibration and sensitivity controls
- 1 day: UI components and mobile support

## Notes
- Test VAD with various background noise levels
- Ensure PTT works globally (not just when app focused)
- Add gamepad support for PTT
- Consider voice activation profiles for different environments