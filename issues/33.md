# Issue #33: Media Handling

## User Story
As a **waddle member**, I want to **share images, videos, and files in chat** so that **I can communicate more effectively with rich media content**.

## Description
Implement comprehensive media handling system supporting image uploads, video sharing, file attachments, and inline media preview. This includes automatic image optimization, thumbnail generation, virus scanning, and seamless integration with Cloudflare R2 for storage.

## Acceptance Criteria
- [ ] Image upload with automatic optimization
- [ ] Video upload with compression
- [ ] File attachment support (documents, zip, etc.)
- [ ] Drag-and-drop upload interface
- [ ] Inline media preview
- [ ] Thumbnail generation
- [ ] Progress tracking for uploads
- [ ] Virus scanning for all uploads
- [ ] Media gallery view
- [ ] Download protection and expiring URLs

## Technical Implementation

### 1. Media Upload Service
```typescript
// Media Types and Configuration
export interface MediaConfig {
  maxFileSize: {
    image: number; // 10MB
    video: number; // 100MB
    file: number;  // 50MB
  };
  allowedMimeTypes: {
    image: string[];
    video: string[];
    file: string[];
  };
  optimization: {
    image: ImageOptimizationConfig;
    video: VideoOptimizationConfig;
  };
}

export interface UploadedMedia {
  id: string;
  userId: string;
  waddleId: string;
  channelId: string;
  messageId?: string;
  type: 'image' | 'video' | 'file';
  filename: string;
  originalName: string;
  mimeType: string;
  size: number;
  width?: number;
  height?: number;
  duration?: number;
  thumbnails: Thumbnail[];
  metadata: Record<string, any>;
  url: string;
  r2Key: string;
  virusScanStatus: 'pending' | 'clean' | 'infected' | 'error';
  createdAt: Date;
}

export interface Thumbnail {
  size: 'small' | 'medium' | 'large';
  width: number;
  height: number;
  url: string;
  r2Key: string;
}

// Media Upload Service
export class MediaUploadService {
  private readonly config: MediaConfig = {
    maxFileSize: {
      image: 10 * 1024 * 1024, // 10MB
      video: 100 * 1024 * 1024, // 100MB
      file: 50 * 1024 * 1024 // 50MB
    },
    allowedMimeTypes: {
      image: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'],
      video: ['video/mp4', 'video/webm', 'video/quicktime'],
      file: [
        'application/pdf',
        'application/zip',
        'application/x-zip-compressed',
        'text/plain',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      ]
    },
    optimization: {
      image: {
        quality: 85,
        maxWidth: 2048,
        maxHeight: 2048,
        thumbnailSizes: [
          { name: 'small', width: 150, height: 150 },
          { name: 'medium', width: 400, height: 400 },
          { name: 'large', width: 800, height: 800 }
        ]
      },
      video: {
        codec: 'h264',
        maxBitrate: 2000000, // 2Mbps
        maxWidth: 1280,
        maxHeight: 720,
        generateThumbnail: true
      }
    }
  };
  
  constructor(
    private r2: R2Bucket,
    private db: D1Database,
    private imageProcessor: ImageProcessor,
    private videoProcessor: VideoProcessor,
    private virusScanner: VirusScannerService
  ) {}
  
  async uploadMedia(
    file: File,
    context: UploadContext
  ): Promise<UploadedMedia> {
    // Validate file
    const validation = await this.validateFile(file);
    if (!validation.valid) {
      throw new UploadError(validation.error!);
    }
    
    const mediaId = generateId();
    const mediaType = this.getMediaType(file.type);
    
    // Create upload session
    const session = await this.createUploadSession(mediaId, file, context);
    
    try {
      // Process based on type
      let processedFile: ProcessedFile;
      let thumbnails: Thumbnail[] = [];
      let metadata: Record<string, any> = {};
      
      switch (mediaType) {
        case 'image':
          const imageResult = await this.processImage(file, mediaId);
          processedFile = imageResult.processed;
          thumbnails = imageResult.thumbnails;
          metadata = imageResult.metadata;
          break;
          
        case 'video':
          const videoResult = await this.processVideo(file, mediaId);
          processedFile = videoResult.processed;
          thumbnails = videoResult.thumbnails;
          metadata = videoResult.metadata;
          break;
          
        default:
          processedFile = {
            buffer: await file.arrayBuffer(),
            mimeType: file.type,
            size: file.size
          };
      }
      
      // Upload to R2
      const r2Key = this.generateR2Key(context, mediaId, file.name);
      await this.uploadToR2(r2Key, processedFile);
      
      // Upload thumbnails
      for (const thumbnail of thumbnails) {
        const thumbnailKey = this.generateThumbnailKey(r2Key, thumbnail.size);
        await this.uploadToR2(thumbnailKey, thumbnail);
        thumbnail.r2Key = thumbnailKey;
        thumbnail.url = this.generateSignedUrl(thumbnailKey);
      }
      
      // Create database record
      const media: UploadedMedia = {
        id: mediaId,
        userId: context.userId,
        waddleId: context.waddleId,
        channelId: context.channelId,
        messageId: context.messageId,
        type: mediaType,
        filename: this.sanitizeFilename(file.name),
        originalName: file.name,
        mimeType: processedFile.mimeType,
        size: processedFile.size,
        width: metadata.width,
        height: metadata.height,
        duration: metadata.duration,
        thumbnails,
        metadata,
        url: this.generateSignedUrl(r2Key),
        r2Key,
        virusScanStatus: 'pending',
        createdAt: new Date()
      };
      
      await this.saveMediaRecord(media);
      
      // Queue virus scan
      await this.queueVirusScan(media);
      
      // Complete session
      await this.completeUploadSession(session.id);
      
      return media;
      
    } catch (error) {
      await this.failUploadSession(session.id, error);
      throw error;
    }
  }
  
  private async processImage(
    file: File,
    mediaId: string
  ): Promise<ImageProcessResult> {
    const buffer = await file.arrayBuffer();
    
    // Get image metadata
    const metadata = await this.imageProcessor.getMetadata(buffer);
    
    // Optimize main image
    const optimized = await this.imageProcessor.optimize(buffer, {
      quality: this.config.optimization.image.quality,
      maxWidth: this.config.optimization.image.maxWidth,
      maxHeight: this.config.optimization.image.maxHeight,
      format: 'webp',
      preserveMetadata: false
    });
    
    // Generate thumbnails
    const thumbnails: Thumbnail[] = [];
    
    for (const size of this.config.optimization.image.thumbnailSizes) {
      const thumbnail = await this.imageProcessor.resize(buffer, {
        width: size.width,
        height: size.height,
        fit: 'cover',
        format: 'webp',
        quality: 85
      });
      
      thumbnails.push({
        size: size.name as any,
        width: size.width,
        height: size.height,
        url: '', // Will be set after upload
        r2Key: '', // Will be set after upload
        buffer: thumbnail.buffer
      });
    }
    
    return {
      processed: {
        buffer: optimized.buffer,
        mimeType: 'image/webp',
        size: optimized.size
      },
      thumbnails,
      metadata: {
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
        hasAlpha: metadata.hasAlpha,
        orientation: metadata.orientation
      }
    };
  }
  
  private async processVideo(
    file: File,
    mediaId: string
  ): Promise<VideoProcessResult> {
    const buffer = await file.arrayBuffer();
    
    // Get video metadata
    const metadata = await this.videoProcessor.getMetadata(buffer);
    
    // Check if compression needed
    let processed: ArrayBuffer;
    
    if (this.needsVideoCompression(metadata)) {
      // Compress video
      processed = await this.videoProcessor.compress(buffer, {
        codec: this.config.optimization.video.codec,
        maxBitrate: this.config.optimization.video.maxBitrate,
        maxWidth: this.config.optimization.video.maxWidth,
        maxHeight: this.config.optimization.video.maxHeight,
        preserveAudio: true
      });
    } else {
      processed = buffer;
    }
    
    // Generate thumbnail from first frame
    const thumbnails: Thumbnail[] = [];
    
    if (this.config.optimization.video.generateThumbnail) {
      const frame = await this.videoProcessor.extractFrame(buffer, {
        time: 0,
        format: 'webp'
      });
      
      // Generate multiple thumbnail sizes
      for (const size of this.config.optimization.image.thumbnailSizes) {
        const thumbnail = await this.imageProcessor.resize(frame, {
          width: size.width,
          height: size.height,
          fit: 'cover',
          format: 'webp'
        });
        
        thumbnails.push({
          size: size.name as any,
          width: size.width,
          height: size.height,
          url: '',
          r2Key: '',
          buffer: thumbnail.buffer
        });
      }
    }
    
    return {
      processed: {
        buffer: processed,
        mimeType: 'video/mp4',
        size: processed.byteLength
      },
      thumbnails,
      metadata: {
        width: metadata.width,
        height: metadata.height,
        duration: metadata.duration,
        bitrate: metadata.bitrate,
        framerate: metadata.framerate,
        codec: metadata.codec
      }
    };
  }
  
  private async uploadToR2(
    key: string,
    data: ProcessedFile | Thumbnail
  ): Promise<void> {
    const buffer = 'buffer' in data ? data.buffer : data;
    
    await this.r2.put(key, buffer, {
      httpMetadata: {
        contentType: data.mimeType || 'application/octet-stream',
        cacheControl: 'public, max-age=31536000' // 1 year
      },
      customMetadata: {
        uploadedAt: new Date().toISOString()
      }
    });
  }
  
  private generateSignedUrl(key: string): string {
    // Generate a signed URL that expires in 7 days
    const url = new URL(`https://media.waddle.chat/${key}`);
    const expires = Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60);
    
    const signature = this.generateUrlSignature(key, expires);
    url.searchParams.set('expires', expires.toString());
    url.searchParams.set('signature', signature);
    
    return url.toString();
  }
  
  private generateUrlSignature(key: string, expires: number): string {
    const data = `${key}:${expires}:${this.env.MEDIA_SECRET}`;
    return createHash('sha256').update(data).digest('hex');
  }
}
```

### 2. Media Processing
```typescript
// Image Processor
export class ImageProcessor {
  async getMetadata(buffer: ArrayBuffer): Promise<ImageMetadata> {
    const image = sharp(buffer);
    const metadata = await image.metadata();
    
    return {
      width: metadata.width!,
      height: metadata.height!,
      format: metadata.format!,
      hasAlpha: metadata.hasAlpha || false,
      orientation: metadata.orientation || 1,
      density: metadata.density,
      chromaSubsampling: metadata.chromaSubsampling
    };
  }
  
  async optimize(
    buffer: ArrayBuffer,
    options: ImageOptimizeOptions
  ): Promise<ProcessedImage> {
    let image = sharp(buffer);
    
    // Auto-orient based on EXIF
    image = image.rotate();
    
    // Resize if needed
    if (options.maxWidth || options.maxHeight) {
      image = image.resize(options.maxWidth, options.maxHeight, {
        fit: 'inside',
        withoutEnlargement: true
      });
    }
    
    // Convert format
    switch (options.format) {
      case 'webp':
        image = image.webp({ quality: options.quality });
        break;
      case 'jpeg':
        image = image.jpeg({ quality: options.quality, progressive: true });
        break;
      case 'png':
        image = image.png({ quality: options.quality, progressive: true });
        break;
    }
    
    // Strip metadata unless preserved
    if (!options.preserveMetadata) {
      image = image.withMetadata({
        orientation: undefined,
        exif: undefined,
        icc: undefined,
        iptc: undefined,
        xmp: undefined
      });
    }
    
    const output = await image.toBuffer();
    
    return {
      buffer: output,
      size: output.byteLength,
      format: options.format
    };
  }
  
  async resize(
    buffer: ArrayBuffer,
    options: ResizeOptions
  ): Promise<ProcessedImage> {
    const image = sharp(buffer)
      .resize(options.width, options.height, {
        fit: options.fit || 'cover',
        position: options.position || 'center',
        background: { r: 255, g: 255, b: 255, alpha: 0 }
      });
      
    let output: Buffer;
    
    switch (options.format) {
      case 'webp':
        output = await image.webp({ quality: options.quality || 85 }).toBuffer();
        break;
      case 'jpeg':
        output = await image.jpeg({ quality: options.quality || 85 }).toBuffer();
        break;
      default:
        output = await image.png().toBuffer();
    }
    
    return {
      buffer: output,
      size: output.byteLength,
      format: options.format || 'png'
    };
  }
  
  async detectFaces(buffer: ArrayBuffer): Promise<FaceDetectionResult[]> {
    // Use face detection library (e.g., face-api.js)
    const faces = await faceApi.detectAllFaces(buffer);
    
    return faces.map(face => ({
      box: face.box,
      confidence: face.score,
      landmarks: face.landmarks
    }));
  }
  
  async blurFaces(
    buffer: ArrayBuffer,
    faces: FaceDetectionResult[]
  ): Promise<ArrayBuffer> {
    let image = sharp(buffer);
    
    // Create overlay with blurred regions
    const { width, height } = await image.metadata();
    const overlay = sharp({
      create: {
        width: width!,
        height: height!,
        channels: 4,
        background: { r: 0, g: 0, b: 0, alpha: 0 }
      }
    });
    
    // Apply blur to face regions
    for (const face of faces) {
      const faceRegion = await sharp(buffer)
        .extract({
          left: Math.round(face.box.x),
          top: Math.round(face.box.y),
          width: Math.round(face.box.width),
          height: Math.round(face.box.height)
        })
        .blur(20)
        .toBuffer();
        
      overlay.composite([{
        input: faceRegion,
        left: Math.round(face.box.x),
        top: Math.round(face.box.y)
      }]);
    }
    
    // Composite blurred faces onto original
    return image.composite([{ input: await overlay.toBuffer() }]).toBuffer();
  }
}

// Video Processor
export class VideoProcessor {
  async getMetadata(buffer: ArrayBuffer): Promise<VideoMetadata> {
    const ffprobe = await this.runFFprobe(buffer);
    
    const videoStream = ffprobe.streams.find(s => s.codec_type === 'video');
    const audioStream = ffprobe.streams.find(s => s.codec_type === 'audio');
    
    return {
      width: videoStream?.width || 0,
      height: videoStream?.height || 0,
      duration: parseFloat(ffprobe.format.duration || '0'),
      bitrate: parseInt(ffprobe.format.bit_rate || '0'),
      framerate: eval(videoStream?.r_frame_rate || '0'),
      codec: videoStream?.codec_name || '',
      hasAudio: !!audioStream,
      audioCodec: audioStream?.codec_name
    };
  }
  
  async compress(
    buffer: ArrayBuffer,
    options: VideoCompressOptions
  ): Promise<ArrayBuffer> {
    const input = new Uint8Array(buffer);
    
    // Run FFmpeg compression
    const result = await ffmpeg.run(
      '-i', 'input',
      '-c:v', options.codec,
      '-b:v', options.maxBitrate.toString(),
      '-vf', `scale='min(${options.maxWidth},iw)':'min(${options.maxHeight},ih)'`,
      '-c:a', options.preserveAudio ? 'aac' : 'none',
      '-preset', 'fast',
      '-movflags', '+faststart',
      'output.mp4',
      {
        input: [{ name: 'input', data: input }]
      }
    );
    
    return result.output[0].data.buffer;
  }
  
  async extractFrame(
    buffer: ArrayBuffer,
    options: FrameExtractionOptions
  ): Promise<ArrayBuffer> {
    const input = new Uint8Array(buffer);
    
    // Extract frame at specified time
    const result = await ffmpeg.run(
      '-i', 'input',
      '-ss', options.time.toString(),
      '-vframes', '1',
      '-f', 'image2',
      '-c:v', options.format === 'webp' ? 'libwebp' : 'mjpeg',
      'output.' + options.format,
      {
        input: [{ name: 'input', data: input }]
      }
    );
    
    return result.output[0].data.buffer;
  }
  
  async generateGif(
    buffer: ArrayBuffer,
    options: GifGenerationOptions
  ): Promise<ArrayBuffer> {
    const input = new Uint8Array(buffer);
    
    // Generate palette for better quality
    const paletteResult = await ffmpeg.run(
      '-i', 'input',
      '-vf', `fps=${options.fps},scale=${options.width}:-1:flags=lanczos,palettegen`,
      'palette.png',
      {
        input: [{ name: 'input', data: input }]
      }
    );
    
    // Generate GIF using palette
    const gifResult = await ffmpeg.run(
      '-i', 'input',
      '-i', 'palette.png',
      '-lavfi', `fps=${options.fps},scale=${options.width}:-1:flags=lanczos[x];[x][1:v]paletteuse`,
      '-loop', options.loop ? '0' : '-1',
      'output.gif',
      {
        input: [
          { name: 'input', data: input },
          { name: 'palette.png', data: paletteResult.output[0].data }
        ]
      }
    );
    
    return gifResult.output[0].data.buffer;
  }
}
```

### 3. Virus Scanning
```typescript
// Virus Scanner Service
export class VirusScannerService {
  private scanQueue: Queue;
  
  constructor(
    private clamav: ClamAVClient,
    private db: D1Database
  ) {
    this.scanQueue = new Queue('virus-scan', {
      concurrency: 5,
      retries: 3
    });
  }
  
  async queueScan(media: UploadedMedia): Promise<void> {
    await this.scanQueue.add({
      mediaId: media.id,
      r2Key: media.r2Key,
      userId: media.userId,
      waddleId: media.waddleId
    });
  }
  
  async processScanJob(job: ScanJob): Promise<void> {
    try {
      // Download file from R2
      const file = await this.r2.get(job.r2Key);
      if (!file) {
        throw new Error('File not found');
      }
      
      const buffer = await file.arrayBuffer();
      
      // Scan with ClamAV
      const scanResult = await this.clamav.scanBuffer(buffer);
      
      // Update database
      await this.updateScanStatus(job.mediaId, scanResult);
      
      // Handle infected files
      if (scanResult.isInfected) {
        await this.handleInfectedFile(job);
      }
      
    } catch (error) {
      console.error('Virus scan failed:', error);
      await this.updateScanStatus(job.mediaId, {
        isInfected: false,
        status: 'error',
        error: error.message
      });
    }
  }
  
  private async updateScanStatus(
    mediaId: string,
    result: ScanResult
  ): Promise<void> {
    await this.db
      .prepare(`
        UPDATE media 
        SET virus_scan_status = ?, 
            virus_scan_result = ?,
            virus_scan_completed_at = ?
        WHERE id = ?
      `)
      .bind(
        result.isInfected ? 'infected' : 'clean',
        JSON.stringify(result),
        new Date().toISOString(),
        mediaId
      )
      .run();
  }
  
  private async handleInfectedFile(job: ScanJob): Promise<void> {
    // Quarantine file
    await this.quarantineFile(job.r2Key);
    
    // Delete from public storage
    await this.r2.delete(job.r2Key);
    
    // Notify user
    await this.notifyUserOfInfection(job.userId, job.mediaId);
    
    // Notify admins
    await this.notifyAdminsOfInfection(job);
    
    // Log security event
    await this.logSecurityEvent({
      type: 'virus_detected',
      userId: job.userId,
      waddleId: job.waddleId,
      mediaId: job.mediaId,
      threat: job.threat
    });
  }
  
  private async quarantineFile(r2Key: string): Promise<void> {
    const file = await this.r2.get(r2Key);
    if (!file) return;
    
    // Move to quarantine bucket
    const quarantineKey = `quarantine/${Date.now()}/${r2Key}`;
    await this.quarantineR2.put(quarantineKey, file.body, {
      customMetadata: {
        originalKey: r2Key,
        quarantinedAt: new Date().toISOString()
      }
    });
  }
}
```

### 4. Media UI Components
```tsx
// Media Upload Component
export function MediaUpload({ 
  onUpload,
  acceptedTypes = ['image', 'video', 'file'],
  maxFiles = 10
}: MediaUploadProps) {
  const [files, setFiles] = useState<UploadFile[]>([]);
  const [dragActive, setDragActive] = useState(false);
  const uploadRef = useRef<HTMLInputElement>(null);
  
  const handleDrag = (e: DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };
  
  const handleDrop = async (e: DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    const droppedFiles = Array.from(e.dataTransfer?.files || []);
    await handleFiles(droppedFiles);
  };
  
  const handleFiles = async (newFiles: File[]) => {
    // Validate files
    const validFiles = newFiles.filter(file => {
      const type = getFileType(file);
      return acceptedTypes.includes(type) && validateFileSize(file, type);
    });
    
    if (validFiles.length !== newFiles.length) {
      toast.error('Some files were rejected due to type or size restrictions');
    }
    
    // Create upload objects
    const uploads = validFiles.slice(0, maxFiles - files.length).map(file => ({
      id: generateId(),
      file,
      progress: 0,
      status: 'pending' as const,
      preview: null as string | null
    }));
    
    // Generate previews
    for (const upload of uploads) {
      if (upload.file.type.startsWith('image/')) {
        upload.preview = await generateImagePreview(upload.file);
      } else if (upload.file.type.startsWith('video/')) {
        upload.preview = await generateVideoPreview(upload.file);
      }
    }
    
    setFiles(prev => [...prev, ...uploads]);
    
    // Start uploads
    for (const upload of uploads) {
      uploadFile(upload);
    }
  };
  
  const uploadFile = async (upload: UploadFile) => {
    try {
      const result = await api.uploadMedia(
        upload.file,
        {
          onProgress: (progress) => {
            setFiles(prev => prev.map(f => 
              f.id === upload.id ? { ...f, progress } : f
            ));
          }
        }
      );
      
      setFiles(prev => prev.map(f => 
        f.id === upload.id ? { ...f, status: 'completed', result } : f
      ));
      
      onUpload(result);
      
    } catch (error) {
      setFiles(prev => prev.map(f => 
        f.id === upload.id ? { ...f, status: 'error', error } : f
      ));
      
      toast.error(`Failed to upload ${upload.file.name}`);
    }
  };
  
  const removeFile = (id: string) => {
    setFiles(prev => prev.filter(f => f.id !== id));
  };
  
  return (
    <div className="media-upload">
      <div 
        className={`upload-zone ${dragActive ? 'drag-active' : ''}`}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
        onClick={() => uploadRef.current?.click()}
      >
        <UploadIcon />
        <p>Drop files here or click to upload</p>
        <p className="upload-hint">
          {getAcceptedTypesText(acceptedTypes)} • Max {getMaxSizeText(acceptedTypes)}
        </p>
      </div>
      
      <input
        ref={uploadRef}
        type="file"
        multiple
        accept={getAcceptString(acceptedTypes)}
        onChange={(e) => handleFiles(Array.from(e.target.files || []))}
        style={{ display: 'none' }}
      />
      
      {files.length > 0 && (
        <div className="upload-list">
          {files.map(file => (
            <UploadItem
              key={file.id}
              upload={file}
              onRemove={() => removeFile(file.id)}
              onRetry={() => uploadFile(file)}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// Media Preview Component
export function MediaPreview({ media }: { media: UploadedMedia }) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(false);
  
  if (media.type === 'image') {
    return (
      <div className="media-preview image-preview">
        <img
          src={media.thumbnails.find(t => t.size === 'medium')?.url || media.url}
          alt={media.filename}
          loading="lazy"
          onLoad={() => setLoading(false)}
          onError={() => setError(true)}
          onClick={() => openLightbox(media)}
        />
        {loading && <LoadingSpinner />}
        {error && <ErrorIcon />}
      </div>
    );
  }
  
  if (media.type === 'video') {
    return (
      <div className="media-preview video-preview">
        <video
          src={media.url}
          poster={media.thumbnails[0]?.url}
          controls
          preload="metadata"
          onLoadedMetadata={() => setLoading(false)}
          onError={() => setError(true)}
        />
        {loading && <LoadingSpinner />}
        {error && <ErrorIcon />}
      </div>
    );
  }
  
  return (
    <div className="media-preview file-preview">
      <FileIcon type={media.mimeType} />
      <div className="file-info">
        <p className="file-name">{media.originalName}</p>
        <p className="file-size">{formatFileSize(media.size)}</p>
      </div>
      <Button
        variant="secondary"
        size="small"
        onClick={() => downloadFile(media)}
      >
        Download
      </Button>
    </div>
  );
}

// Media Gallery Component
export function MediaGallery({ waddleId, channelId }: MediaGalleryProps) {
  const [media, setMedia] = useState<UploadedMedia[]>([]);
  const [filter, setFilter] = useState<'all' | 'image' | 'video' | 'file'>('all');
  const [loading, setLoading] = useState(true);
  const [hasMore, setHasMore] = useState(true);
  const [cursor, setCursor] = useState<string>();
  
  const loadMedia = async (reset = false) => {
    setLoading(true);
    try {
      const result = await api.getMedia({
        waddleId,
        channelId,
        type: filter === 'all' ? undefined : filter,
        cursor: reset ? undefined : cursor,
        limit: 50
      });
      
      setMedia(prev => reset ? result.items : [...prev, ...result.items]);
      setCursor(result.cursor);
      setHasMore(!!result.cursor);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    loadMedia(true);
  }, [waddleId, channelId, filter]);
  
  const handleScroll = useCallback((e: Event) => {
    const target = e.target as HTMLElement;
    if (
      target.scrollTop + target.clientHeight >= target.scrollHeight - 100 &&
      !loading &&
      hasMore
    ) {
      loadMedia();
    }
  }, [loading, hasMore]);
  
  const filteredMedia = filter === 'all' 
    ? media 
    : media.filter(m => m.type === filter);
  
  return (
    <div className="media-gallery">
      <div className="gallery-header">
        <h3>Media Gallery</h3>
        <FilterTabs
          value={filter}
          onChange={setFilter}
          options={[
            { value: 'all', label: 'All' },
            { value: 'image', label: 'Images' },
            { value: 'video', label: 'Videos' },
            { value: 'file', label: 'Files' }
          ]}
        />
      </div>
      
      <div 
        className="gallery-grid"
        onScroll={handleScroll}
      >
        {filteredMedia.map(item => (
          <MediaGalleryItem
            key={item.id}
            media={item}
            onClick={() => openMediaViewer(item)}
          />
        ))}
        
        {loading && <LoadingSpinner />}
        
        {!loading && filteredMedia.length === 0 && (
          <EmptyState message="No media found" />
        )}
      </div>
    </div>
  );
}

// Lightbox Component
export function MediaLightbox({ 
  media, 
  onClose 
}: { 
  media: UploadedMedia; 
  onClose: () => void;
}) {
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleKeyboard = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
      if (e.key === '+') setScale(s => Math.min(s + 0.1, 3));
      if (e.key === '-') setScale(s => Math.max(s - 0.1, 0.5));
    };
    
    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [onClose]);
  
  return (
    <div className="media-lightbox" onClick={onClose}>
      <div className="lightbox-toolbar">
        <Button icon={<ZoomInIcon />} onClick={() => setScale(s => s + 0.1)} />
        <Button icon={<ZoomOutIcon />} onClick={() => setScale(s => s - 0.1)} />
        <Button icon={<DownloadIcon />} onClick={() => downloadFile(media)} />
        <Button icon={<CloseIcon />} onClick={onClose} />
      </div>
      
      <div 
        className="lightbox-content"
        onClick={(e) => e.stopPropagation()}
      >
        {media.type === 'image' ? (
          <img
            src={media.url}
            alt={media.filename}
            style={{
              transform: `scale(${scale}) translate(${position.x}px, ${position.y}px)`
            }}
            draggable={false}
          />
        ) : (
          <video
            src={media.url}
            controls
            autoPlay
            style={{
              transform: `scale(${scale})`
            }}
          />
        )}
      </div>
      
      <div className="lightbox-info">
        <p>{media.originalName}</p>
        <p>{formatFileSize(media.size)} • {media.width}×{media.height}</p>
      </div>
    </div>
  );
}
```

### 5. Security and Performance
```typescript
// Media Security Service
export class MediaSecurityService {
  private readonly blockedExtensions = [
    '.exe', '.bat', '.cmd', '.com', '.pif', '.scr', '.vbs', '.js'
  ];
  
  private readonly dangerousMimeTypes = [
    'application/x-msdownload',
    'application/x-msdos-program',
    'application/x-executable'
  ];
  
  validateFile(file: File): ValidationResult {
    // Check file extension
    const extension = path.extname(file.name).toLowerCase();
    if (this.blockedExtensions.includes(extension)) {
      return {
        valid: false,
        error: 'File type not allowed for security reasons'
      };
    }
    
    // Check MIME type
    if (this.dangerousMimeTypes.includes(file.type)) {
      return {
        valid: false,
        error: 'File type not allowed for security reasons'
      };
    }
    
    // Check file size
    const maxSize = this.getMaxSizeForType(file.type);
    if (file.size > maxSize) {
      return {
        valid: false,
        error: `File size exceeds maximum of ${formatFileSize(maxSize)}`
      };
    }
    
    // Additional checks for specific types
    if (file.type.startsWith('image/')) {
      return this.validateImage(file);
    }
    
    if (file.type.startsWith('video/')) {
      return this.validateVideo(file);
    }
    
    return { valid: true };
  }
  
  private async validateImage(file: File): Promise<ValidationResult> {
    // Check if it's actually an image
    try {
      const buffer = await file.slice(0, 4100).arrayBuffer();
      const header = new Uint8Array(buffer);
      
      if (!this.isValidImageHeader(header)) {
        return {
          valid: false,
          error: 'File does not appear to be a valid image'
        };
      }
      
      return { valid: true };
    } catch {
      return {
        valid: false,
        error: 'Failed to validate image'
      };
    }
  }
  
  private isValidImageHeader(header: Uint8Array): boolean {
    // Check for common image magic numbers
    const signatures = {
      jpeg: [0xFF, 0xD8, 0xFF],
      png: [0x89, 0x50, 0x4E, 0x47],
      gif: [0x47, 0x49, 0x46],
      webp: [0x52, 0x49, 0x46, 0x46],
      bmp: [0x42, 0x4D]
    };
    
    for (const [format, signature] of Object.entries(signatures)) {
      if (signature.every((byte, i) => header[i] === byte)) {
        return true;
      }
    }
    
    return false;
  }
}

// CDN Integration
export class MediaCDNService {
  constructor(
    private cdnConfig: CDNConfig,
    private r2: R2Bucket
  ) {}
  
  async getOptimizedUrl(
    media: UploadedMedia,
    options?: ImageTransformOptions
  ): Promise<string> {
    if (media.type !== 'image') {
      return media.url;
    }
    
    // Build Cloudflare Image Resizing URL
    const params = new URLSearchParams();
    
    if (options?.width) params.set('width', options.width.toString());
    if (options?.height) params.set('height', options.height.toString());
    if (options?.quality) params.set('quality', options.quality.toString());
    if (options?.format) params.set('format', options.format);
    if (options?.fit) params.set('fit', options.fit);
    
    return `https://media.waddle.chat/cdn-cgi/image/${params.toString()}/${media.r2Key}`;
  }
  
  async purgeCache(mediaId: string): Promise<void> {
    const media = await this.getMedia(mediaId);
    if (!media) return;
    
    // Purge main file
    await this.purgeCDNUrl(media.url);
    
    // Purge thumbnails
    for (const thumbnail of media.thumbnails) {
      await this.purgeCDNUrl(thumbnail.url);
    }
  }
  
  private async purgeCDNUrl(url: string): Promise<void> {
    await fetch(`https://api.cloudflare.com/client/v4/zones/${this.cdnConfig.zoneId}/purge_cache`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.cdnConfig.apiToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        files: [url]
      })
    });
  }
}
```

## Dependencies
- Cloudflare R2 for storage
- Sharp for image processing
- FFmpeg for video processing
- ClamAV for virus scanning
- Cloudflare Image Resizing
- Face detection library

## Estimated Effort
**4 days**
- 1 day: Upload service and R2 integration
- 1 day: Image and video processing
- 1 day: UI components and gallery
- 0.5 day: Virus scanning setup
- 0.5 day: Security and performance optimization

## Notes
- Consider implementing progressive image loading
- Add support for HEIC/HEIF formats
- Implement smart compression based on connection speed
- Consider adding image editing capabilities
- Plan for large file resumable uploads
- Add support for 360° images and videos