# Issue #31: Voice Regions

## User Story
As a **waddle owner**, I want to **select the best voice server region for my community** so that **all members experience low latency and high-quality voice chat**.

## Description
Implement voice region selection allowing waddle owners to choose optimal server locations for their voice channels. This includes automatic region detection, latency testing, and dynamic region switching based on participant locations.

## Acceptance Criteria
- [ ] Multiple voice server regions
- [ ] Automatic region recommendation
- [ ] Latency testing to all regions
- [ ] Region selection per waddle
- [ ] Dynamic region optimization
- [ ] Region failover support
- [ ] Region usage analytics
- [ ] Migration between regions

## Technical Implementation

### 1. Voice Region Infrastructure
```typescript
// Region configuration
export interface VoiceRegion {
  id: string;
  name: string;
  endpoint: string;
  location: {
    city: string;
    country: string;
    continent: string;
    latitude: number;
    longitude: number;
  };
  capacity: {
    current: number;
    maximum: number;
  };
  features: string[];
  status: 'online' | 'degraded' | 'offline';
  averageLatency?: number;
}

export const VOICE_REGIONS: VoiceRegion[] = [
  {
    id: 'us-west',
    name: 'US West',
    endpoint: 'rtk-us-west.waddle.chat',
    location: {
      city: 'San Francisco',
      country: 'United States',
      continent: 'North America',
      latitude: 37.7749,
      longitude: -122.4194
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  },
  {
    id: 'us-east',
    name: 'US East',
    endpoint: 'rtk-us-east.waddle.chat',
    location: {
      city: 'New York',
      country: 'United States',
      continent: 'North America',
      latitude: 40.7128,
      longitude: -74.0060
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  },
  {
    id: 'eu-west',
    name: 'Europe West',
    endpoint: 'rtk-eu-west.waddle.chat',
    location: {
      city: 'Frankfurt',
      country: 'Germany',
      continent: 'Europe',
      latitude: 50.1109,
      longitude: 8.6821
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  },
  {
    id: 'eu-north',
    name: 'Europe North',
    endpoint: 'rtk-eu-north.waddle.chat',
    location: {
      city: 'Stockholm',
      country: 'Sweden',
      continent: 'Europe',
      latitude: 59.3293,
      longitude: 18.0686
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  },
  {
    id: 'asia-se',
    name: 'Asia Southeast',
    endpoint: 'rtk-asia-se.waddle.chat',
    location: {
      city: 'Singapore',
      country: 'Singapore',
      continent: 'Asia',
      latitude: 1.3521,
      longitude: 103.8198
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  },
  {
    id: 'asia-ne',
    name: 'Asia Northeast',
    endpoint: 'rtk-asia-ne.waddle.chat',
    location: {
      city: 'Tokyo',
      country: 'Japan',
      continent: 'Asia',
      latitude: 35.6762,
      longitude: 139.6503
    },
    capacity: { current: 0, maximum: 10000 },
    features: ['rtk', 'opus', 'h264'],
    status: 'online'
  }
];

// Region Manager
export class VoiceRegionManager {
  private regionStatus = new Map<string, VoiceRegion>();
  private latencyCache = new Map<string, Map<string, number>>();
  
  constructor(
    private env: Env,
    private geoip: GeoIPService,
    private analytics: AnalyticsService
  ) {
    this.initializeRegions();
  }
  
  private async initializeRegions() {
    // Load region status from KV
    for (const region of VOICE_REGIONS) {
      const status = await this.env.REGION_STATUS.get(region.id);
      if (status) {
        const regionData = JSON.parse(status);
        this.regionStatus.set(region.id, { ...region, ...regionData });
      } else {
        this.regionStatus.set(region.id, region);
      }
    }
    
    // Start health monitoring
    this.startHealthMonitoring();
  }
  
  async recommendRegion(
    waddleId: string,
    userLocation?: string
  ): Promise<VoiceRegion> {
    // Get waddle member locations
    const memberLocations = await this.getWaddleMemberLocations(waddleId);
    
    // Calculate optimal region based on member distribution
    const regionScores = new Map<string, number>();
    
    for (const region of this.regionStatus.values()) {
      if (region.status !== 'online') continue;
      
      let score = 100;
      
      // Factor 1: Average latency for all members
      const avgLatency = await this.calculateAverageLatency(
        region,
        memberLocations
      );
      score -= avgLatency * 0.5; // Penalize high latency
      
      // Factor 2: Capacity availability
      const capacityRatio = region.capacity.current / region.capacity.maximum;
      score -= capacityRatio * 20; // Penalize crowded regions
      
      // Factor 3: Geographic distribution
      const geoScore = this.calculateGeographicScore(region, memberLocations);
      score += geoScore * 0.3;
      
      regionScores.set(region.id, score);
    }
    
    // Select best region
    const bestRegionId = Array.from(regionScores.entries())
      .sort((a, b) => b[1] - a[1])[0][0];
      
    const selectedRegion = this.regionStatus.get(bestRegionId)!;
    
    // Track recommendation
    await this.analytics.track('voice_region_recommended', {
      waddleId,
      regionId: selectedRegion.id,
      score: regionScores.get(bestRegionId),
      memberCount: memberLocations.length
    });
    
    return selectedRegion;
  }
  
  async testLatency(
    regionId: string,
    userIp: string
  ): Promise<LatencyTestResult> {
    const region = this.regionStatus.get(regionId);
    if (!region) {
      throw new Error('Invalid region');
    }
    
    // Check cache first
    const cached = this.getCachedLatency(userIp, regionId);
    if (cached && cached.age < 300000) { // 5 minutes
      return cached;
    }
    
    // Perform latency test
    const results: number[] = [];
    
    for (let i = 0; i < 5; i++) {
      const start = Date.now();
      
      try {
        await fetch(`https://${region.endpoint}/ping`, {
          method: 'GET',
          signal: AbortSignal.timeout(5000)
        });
        
        const latency = Date.now() - start;
        results.push(latency);
        
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        results.push(9999); // Timeout or error
      }
    }
    
    // Calculate statistics
    const validResults = results.filter(r => r < 9999);
    const avgLatency = validResults.reduce((a, b) => a + b, 0) / validResults.length;
    const minLatency = Math.min(...validResults);
    const maxLatency = Math.max(...validResults);
    const jitter = this.calculateJitter(validResults);
    const packetLoss = ((results.length - validResults.length) / results.length) * 100;
    
    const result: LatencyTestResult = {
      regionId,
      averageLatency: avgLatency,
      minimumLatency: minLatency,
      maximumLatency: maxLatency,
      jitter,
      packetLoss,
      timestamp: Date.now()
    };
    
    // Cache result
    this.cacheLatency(userIp, regionId, result);
    
    return result;
  }
  
  private calculateJitter(latencies: number[]): number {
    if (latencies.length < 2) return 0;
    
    let jitterSum = 0;
    for (let i = 1; i < latencies.length; i++) {
      jitterSum += Math.abs(latencies[i] - latencies[i - 1]);
    }
    
    return jitterSum / (latencies.length - 1);
  }
  
  async getAllRegionsLatency(userIp: string): Promise<RegionLatencyMap> {
    const results = new Map<string, LatencyTestResult>();
    
    // Test all regions in parallel
    const promises = Array.from(this.regionStatus.values())
      .filter(region => region.status === 'online')
      .map(async region => {
        try {
          const result = await this.testLatency(region.id, userIp);
          results.set(region.id, result);
        } catch (error) {
          console.error(`Failed to test region ${region.id}:`, error);
        }
      });
      
    await Promise.all(promises);
    
    return results;
  }
}
```

### 2. Dynamic Region Optimization
```typescript
// Dynamic Region Optimizer
export class DynamicRegionOptimizer {
  private optimizationInterval: number = 3600000; // 1 hour
  private memberLocationCache = new Map<string, LocationData>();
  
  constructor(
    private regionManager: VoiceRegionManager,
    private waddleRepository: WaddleRepository,
    private voiceService: VoiceService
  ) {}
  
  async startOptimization() {
    // Periodic optimization
    setInterval(() => {
      this.optimizeAllWaddles();
    }, this.optimizationInterval);
    
    // Initial optimization
    await this.optimizeAllWaddles();
  }
  
  private async optimizeAllWaddles() {
    const waddles = await this.waddleRepository.getActiveWaddles();
    
    for (const waddle of waddles) {
      try {
        await this.optimizeWaddleRegion(waddle);
      } catch (error) {
        console.error(`Failed to optimize waddle ${waddle.id}:`, error);
      }
    }
  }
  
  async optimizeWaddleRegion(waddle: Waddle): Promise<OptimizationResult> {
    // Get current voice activity
    const activeVoiceChannels = await this.voiceService.getActiveChannels(waddle.id);
    if (activeVoiceChannels.length === 0) {
      return { optimized: false, reason: 'No active voice channels' };
    }
    
    // Get participant locations
    const participants = await this.getActiveParticipants(waddle.id);
    const locationGroups = this.groupParticipantsByLocation(participants);
    
    // Calculate current region performance
    const currentRegion = waddle.voiceRegion;
    const currentPerformance = await this.calculateRegionPerformance(
      currentRegion,
      locationGroups
    );
    
    // Find optimal region
    const optimalRegion = await this.findOptimalRegion(locationGroups);
    const optimalPerformance = await this.calculateRegionPerformance(
      optimalRegion.id,
      locationGroups
    );
    
    // Decide if migration is worth it
    const improvementThreshold = 0.2; // 20% improvement required
    const improvement = (currentPerformance.score - optimalPerformance.score) / currentPerformance.score;
    
    if (improvement > improvementThreshold) {
      // Migrate to new region
      await this.migrateWaddleRegion(waddle, optimalRegion);
      
      return {
        optimized: true,
        previousRegion: currentRegion,
        newRegion: optimalRegion.id,
        improvement: improvement * 100,
        affectedUsers: participants.length
      };
    }
    
    return {
      optimized: false,
      reason: 'Current region is optimal',
      improvement: improvement * 100
    };
  }
  
  private async calculateRegionPerformance(
    regionId: string,
    locationGroups: Map<string, ParticipantLocation[]>
  ): Promise<RegionPerformance> {
    let totalLatency = 0;
    let totalParticipants = 0;
    let maxLatency = 0;
    
    for (const [location, participants] of locationGroups) {
      const latencyToRegion = await this.estimateLatency(location, regionId);
      
      totalLatency += latencyToRegion * participants.length;
      totalParticipants += participants.length;
      maxLatency = Math.max(maxLatency, latencyToRegion);
    }
    
    const avgLatency = totalLatency / totalParticipants;
    
    // Score calculation (lower is better)
    // Weighted: 70% average latency, 30% max latency
    const score = (avgLatency * 0.7) + (maxLatency * 0.3);
    
    return {
      regionId,
      averageLatency: avgLatency,
      maxLatency,
      score,
      participantCount: totalParticipants
    };
  }
  
  private async migrateWaddleRegion(
    waddle: Waddle,
    newRegion: VoiceRegion
  ): Promise<void> {
    console.log(`Migrating waddle ${waddle.id} from ${waddle.voiceRegion} to ${newRegion.id}`);
    
    // Step 1: Prepare new region
    await this.voiceService.prepareRegion(waddle.id, newRegion.id);
    
    // Step 2: Notify clients about upcoming migration
    await this.notifyUpcomingMigration(waddle.id, newRegion.id);
    
    // Step 3: Graceful migration with minimal disruption
    await this.performGracefulMigration(waddle.id, waddle.voiceRegion, newRegion.id);
    
    // Step 4: Update waddle configuration
    await this.waddleRepository.updateVoiceRegion(waddle.id, newRegion.id);
    
    // Step 5: Clean up old region resources
    await this.voiceService.cleanupRegion(waddle.id, waddle.voiceRegion);
    
    // Track migration
    await this.analytics.track('voice_region_migrated', {
      waddleId: waddle.id,
      fromRegion: waddle.voiceRegion,
      toRegion: newRegion.id,
      reason: 'optimization'
    });
  }
}
```

### 3. Region Selection UI
```tsx
export function VoiceRegionSettings({ waddleId }: { waddleId: string }) {
  const [selectedRegion, setSelectedRegion] = useState<string>('');
  const [testResults, setTestResults] = useState<Map<string, LatencyTestResult>>();
  const [testing, setTesting] = useState(false);
  const [saving, setSaving] = useState(false);
  
  useEffect(() => {
    loadCurrentRegion();
  }, [waddleId]);
  
  const loadCurrentRegion = async () => {
    const waddle = await api.getWaddle(waddleId);
    setSelectedRegion(waddle.voiceRegion || 'auto');
  };
  
  const testAllRegions = async () => {
    setTesting(true);
    try {
      const results = await api.testVoiceRegions();
      setTestResults(results);
    } finally {
      setTesting(false);
    }
  };
  
  const saveRegion = async () => {
    setSaving(true);
    try {
      await api.updateWaddleVoiceRegion(waddleId, selectedRegion);
      toast.success('Voice region updated successfully');
    } catch (error) {
      toast.error('Failed to update voice region');
    } finally {
      setSaving(false);
    }
  };
  
  return (
    <div className="voice-region-settings">
      <div className="settings-header">
        <h3>Voice Region</h3>
        <p>Choose the server region closest to your members for the best voice quality</p>
      </div>
      
      <div className="region-selection">
        <RadioGroup value={selectedRegion} onChange={setSelectedRegion}>
          <Radio value="auto">
            <div className="region-option">
              <div className="region-info">
                <h4>Automatic</h4>
                <p>Let Waddle choose the best region based on member locations</p>
              </div>
              {selectedRegion === 'auto' && waddle.currentRegion && (
                <Badge>Currently: {VOICE_REGIONS.find(r => r.id === waddle.currentRegion)?.name}</Badge>
              )}
            </div>
          </Radio>
          
          {VOICE_REGIONS.map(region => (
            <Radio key={region.id} value={region.id}>
              <div className="region-option">
                <div className="region-info">
                  <h4>{region.name}</h4>
                  <p>{region.location.city}, {region.location.country}</p>
                </div>
                
                <div className="region-stats">
                  <RegionStatus status={region.status} />
                  {testResults?.has(region.id) && (
                    <LatencyBadge latency={testResults.get(region.id)!.averageLatency} />
                  )}
                </div>
              </div>
            </Radio>
          ))}
        </RadioGroup>
      </div>
      
      <div className="region-actions">
        <Button
          variant="secondary"
          onClick={testAllRegions}
          disabled={testing}
        >
          {testing ? 'Testing...' : 'Test All Regions'}
        </Button>
        
        <Button
          variant="primary"
          onClick={saveRegion}
          disabled={saving || !selectedRegion}
        >
          {saving ? 'Saving...' : 'Save Region'}
        </Button>
      </div>
      
      {testResults && (
        <LatencyTestResults results={testResults} />
      )}
    </div>
  );
}

function LatencyTestResults({ 
  results 
}: { 
  results: Map<string, LatencyTestResult> 
}) {
  const sortedResults = Array.from(results.entries())
    .sort((a, b) => a[1].averageLatency - b[1].averageLatency);
    
  return (
    <div className="latency-results">
      <h4>Latency Test Results</h4>
      
      <div className="results-grid">
        {sortedResults.map(([regionId, result]) => {
          const region = VOICE_REGIONS.find(r => r.id === regionId);
          if (!region) return null;
          
          return (
            <div key={regionId} className="result-card">
              <div className="result-header">
                <h5>{region.name}</h5>
                <QualityIndicator latency={result.averageLatency} />
              </div>
              
              <div className="result-stats">
                <div className="stat">
                  <span className="label">Avg Latency</span>
                  <span className="value">{result.averageLatency.toFixed(0)}ms</span>
                </div>
                <div className="stat">
                  <span className="label">Jitter</span>
                  <span className="value">{result.jitter.toFixed(1)}ms</span>
                </div>
                <div className="stat">
                  <span className="label">Packet Loss</span>
                  <span className="value">{result.packetLoss.toFixed(1)}%</span>
                </div>
              </div>
              
              <LatencyGraph
                min={result.minimumLatency}
                avg={result.averageLatency}
                max={result.maximumLatency}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
}

function QualityIndicator({ latency }: { latency: number }) {
  const quality = latency < 50 ? 'excellent' :
                 latency < 100 ? 'good' :
                 latency < 150 ? 'fair' : 'poor';
                 
  return (
    <div className={`quality-indicator quality-${quality}`}>
      <span className="quality-dot" />
      <span className="quality-label">{quality}</span>
    </div>
  );
}
```

### 4. Region Health Monitoring
```typescript
// Health Monitor
export class RegionHealthMonitor {
  private healthChecks = new Map<string, HealthCheckResult>();
  private subscribers = new Set<(update: HealthUpdate) => void>();
  
  constructor(
    private env: Env,
    private alerting: AlertingService
  ) {}
  
  async startMonitoring() {
    // Health check every 30 seconds
    setInterval(() => {
      this.performHealthChecks();
    }, 30000);
    
    // Detailed check every 5 minutes
    setInterval(() => {
      this.performDetailedHealthChecks();
    }, 300000);
  }
  
  private async performHealthChecks() {
    const checks = VOICE_REGIONS.map(region => this.checkRegionHealth(region));
    const results = await Promise.all(checks);
    
    for (const result of results) {
      const previous = this.healthChecks.get(result.regionId);
      this.healthChecks.set(result.regionId, result);
      
      // Detect status changes
      if (previous && previous.status !== result.status) {
        await this.handleStatusChange(result.regionId, previous.status, result.status);
      }
      
      // Notify subscribers
      this.notifySubscribers({
        type: 'health_update',
        regionId: result.regionId,
        health: result
      });
    }
  }
  
  private async checkRegionHealth(region: VoiceRegion): Promise<HealthCheckResult> {
    const checks = {
      endpoint: await this.checkEndpoint(region.endpoint),
      capacity: await this.checkCapacity(region.id),
      latency: await this.checkLatency(region.endpoint),
      errorRate: await this.checkErrorRate(region.id)
    };
    
    // Determine overall status
    let status: RegionStatus = 'online';
    
    if (!checks.endpoint.healthy) {
      status = 'offline';
    } else if (checks.capacity.utilizationPercent > 90 ||
               checks.latency.p99 > 200 ||
               checks.errorRate.rate > 5) {
      status = 'degraded';
    }
    
    return {
      regionId: region.id,
      timestamp: Date.now(),
      status,
      checks,
      score: this.calculateHealthScore(checks)
    };
  }
  
  private calculateHealthScore(checks: HealthChecks): number {
    let score = 100;
    
    // Endpoint availability (40 points)
    if (!checks.endpoint.healthy) {
      score -= 40;
    } else {
      score -= (checks.endpoint.responseTime / 1000) * 10; // Penalize slow responses
    }
    
    // Capacity (20 points)
    score -= (checks.capacity.utilizationPercent / 100) * 20;
    
    // Latency (20 points)
    if (checks.latency.p99 > 200) score -= 20;
    else if (checks.latency.p99 > 100) score -= 10;
    else if (checks.latency.p99 > 50) score -= 5;
    
    // Error rate (20 points)
    score -= Math.min(checks.errorRate.rate * 4, 20);
    
    return Math.max(0, score);
  }
  
  private async handleStatusChange(
    regionId: string,
    oldStatus: RegionStatus,
    newStatus: RegionStatus
  ) {
    console.log(`Region ${regionId} status changed: ${oldStatus} -> ${newStatus}`);
    
    // Update KV store
    await this.env.REGION_STATUS.put(regionId, JSON.stringify({
      status: newStatus,
      lastChange: Date.now()
    }));
    
    // Send alerts
    if (newStatus === 'offline') {
      await this.alerting.sendAlert({
        severity: 'critical',
        title: `Voice Region ${regionId} is offline`,
        description: `The voice region ${regionId} has gone offline and is not accepting connections.`,
        regionId
      });
    } else if (newStatus === 'degraded') {
      await this.alerting.sendAlert({
        severity: 'warning',
        title: `Voice Region ${regionId} is degraded`,
        description: `The voice region ${regionId} is experiencing performance issues.`,
        regionId
      });
    } else if (oldStatus === 'offline' && newStatus === 'online') {
      await this.alerting.sendAlert({
        severity: 'info',
        title: `Voice Region ${regionId} recovered`,
        description: `The voice region ${regionId} is back online.`,
        regionId
      });
    }
    
    // Trigger failover if needed
    if (newStatus === 'offline') {
      await this.triggerFailover(regionId);
    }
  }
}
```

### 5. Failover Management
```typescript
// Failover Manager
export class RegionFailoverManager {
  private failoverInProgress = new Set<string>();
  
  constructor(
    private voiceService: VoiceService,
    private waddleRepository: WaddleRepository,
    private notificationService: NotificationService
  ) {}
  
  async handleRegionFailure(failedRegionId: string): Promise<FailoverResult> {
    if (this.failoverInProgress.has(failedRegionId)) {
      return { inProgress: true };
    }
    
    this.failoverInProgress.add(failedRegionId);
    
    try {
      // Get affected waddles
      const affectedWaddles = await this.waddleRepository.getWaddlesByRegion(failedRegionId);
      
      console.log(`Starting failover for ${affectedWaddles.length} waddles from region ${failedRegionId}`);
      
      const results: WaddleFailoverResult[] = [];
      
      // Process waddles in batches
      const batchSize = 10;
      for (let i = 0; i < affectedWaddles.length; i += batchSize) {
        const batch = affectedWaddles.slice(i, i + batchSize);
        const batchResults = await Promise.all(
          batch.map(waddle => this.failoverWaddle(waddle, failedRegionId))
        );
        results.push(...batchResults);
      }
      
      // Summary
      const successful = results.filter(r => r.success).length;
      const failed = results.filter(r => !r.success).length;
      
      return {
        success: true,
        affectedWaddles: affectedWaddles.length,
        successfulFailovers: successful,
        failedFailovers: failed,
        results
      };
      
    } finally {
      this.failoverInProgress.delete(failedRegionId);
    }
  }
  
  private async failoverWaddle(
    waddle: Waddle,
    failedRegionId: string
  ): Promise<WaddleFailoverResult> {
    try {
      // Find best alternative region
      const alternativeRegion = await this.findBestAlternativeRegion(
        waddle,
        failedRegionId
      );
      
      if (!alternativeRegion) {
        throw new Error('No alternative region available');
      }
      
      // Perform failover
      await this.voiceService.failoverWaddle(
        waddle.id,
        failedRegionId,
        alternativeRegion.id
      );
      
      // Update waddle configuration
      await this.waddleRepository.updateVoiceRegion(
        waddle.id,
        alternativeRegion.id,
        { temporary: true, originalRegion: failedRegionId }
      );
      
      // Notify waddle members
      await this.notificationService.notifyWaddle(waddle.id, {
        type: 'voice_region_failover',
        message: `Voice region temporarily changed to ${alternativeRegion.name} due to technical issues`,
        priority: 'high'
      });
      
      return {
        success: true,
        waddleId: waddle.id,
        newRegion: alternativeRegion.id
      };
      
    } catch (error) {
      console.error(`Failed to failover waddle ${waddle.id}:`, error);
      
      return {
        success: false,
        waddleId: waddle.id,
        error: error.message
      };
    }
  }
  
  private async findBestAlternativeRegion(
    waddle: Waddle,
    excludeRegion: string
  ): Promise<VoiceRegion | null> {
    const availableRegions = VOICE_REGIONS.filter(
      r => r.id !== excludeRegion && r.status === 'online'
    );
    
    if (availableRegions.length === 0) {
      return null;
    }
    
    // Score regions based on:
    // 1. Geographic proximity to original region
    // 2. Current capacity
    // 3. Health score
    
    const originalRegion = VOICE_REGIONS.find(r => r.id === excludeRegion);
    if (!originalRegion) return availableRegions[0];
    
    const scoredRegions = await Promise.all(
      availableRegions.map(async region => {
        const distance = this.calculateDistance(
          originalRegion.location,
          region.location
        );
        
        const health = await this.getRegionHealth(region.id);
        const capacityScore = (region.capacity.maximum - region.capacity.current) / region.capacity.maximum;
        
        // Lower score is better
        const score = (distance / 1000) - (health.score * 10) - (capacityScore * 100);
        
        return { region, score };
      })
    );
    
    scoredRegions.sort((a, b) => a.score - b.score);
    
    return scoredRegions[0]?.region || null;
  }
}
```

### 6. Analytics and Monitoring
```typescript
// Region Analytics
export class VoiceRegionAnalytics {
  constructor(
    private analytics: AnalyticsService,
    private env: Env
  ) {}
  
  async trackRegionUsage(event: RegionUsageEvent) {
    await this.analytics.track('voice_region_usage', {
      regionId: event.regionId,
      waddleId: event.waddleId,
      channelId: event.channelId,
      participantCount: event.participantCount,
      duration: event.duration,
      quality: event.quality
    });
    
    // Update region metrics
    await this.updateRegionMetrics(event.regionId, {
      totalSessions: { increment: 1 },
      totalDuration: { increment: event.duration },
      totalParticipants: { increment: event.participantCount },
      averageQuality: { value: event.quality }
    });
  }
  
  async getRegionDashboard(regionId: string): Promise<RegionDashboard> {
    const metrics = await this.getRegionMetrics(regionId);
    const health = await this.getRegionHealth(regionId);
    const trends = await this.getRegionTrends(regionId);
    
    return {
      region: VOICE_REGIONS.find(r => r.id === regionId)!,
      metrics,
      health,
      trends,
      alerts: await this.getRegionAlerts(regionId)
    };
  }
  
  private async getRegionTrends(
    regionId: string
  ): Promise<RegionTrends> {
    const hourlyData = await this.analytics.query({
      metric: 'voice_region_usage',
      filters: { regionId },
      groupBy: 'hour',
      range: { start: Date.now() - 86400000, end: Date.now() }
    });
    
    return {
      usage: hourlyData.map(d => ({
        time: d.hour,
        sessions: d.count,
        participants: d.sum('participantCount'),
        avgQuality: d.avg('quality')
      })),
      capacity: await this.getCapacityTrend(regionId),
      latency: await this.getLatencyTrend(regionId)
    };
  }
}

// Dashboard UI Component
export function RegionDashboard({ regionId }: { regionId: string }) {
  const [dashboard, setDashboard] = useState<RegionDashboard>();
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadDashboard();
    const interval = setInterval(loadDashboard, 30000);
    return () => clearInterval(interval);
  }, [regionId]);
  
  const loadDashboard = async () => {
    try {
      const data = await api.getRegionDashboard(regionId);
      setDashboard(data);
    } finally {
      setLoading(false);
    }
  };
  
  if (loading) return <LoadingSpinner />;
  if (!dashboard) return <ErrorMessage />;
  
  return (
    <div className="region-dashboard">
      <div className="dashboard-header">
        <h2>{dashboard.region.name}</h2>
        <RegionStatus status={dashboard.health.status} />
      </div>
      
      <div className="dashboard-grid">
        <MetricCard
          title="Active Sessions"
          value={dashboard.metrics.activeSessions}
          trend={dashboard.trends.sessions}
        />
        
        <MetricCard
          title="Total Participants"
          value={dashboard.metrics.totalParticipants}
          trend={dashboard.trends.participants}
        />
        
        <MetricCard
          title="Avg Latency"
          value={`${dashboard.metrics.averageLatency}ms`}
          trend={dashboard.trends.latency}
        />
        
        <MetricCard
          title="Capacity Used"
          value={`${dashboard.metrics.capacityUsed}%`}
          trend={dashboard.trends.capacity}
        />
      </div>
      
      <div className="dashboard-charts">
        <UsageChart data={dashboard.trends.usage} />
        <QualityChart data={dashboard.trends.quality} />
        <LatencyDistribution data={dashboard.metrics.latencyDistribution} />
      </div>
      
      {dashboard.alerts.length > 0 && (
        <AlertsList alerts={dashboard.alerts} />
      )}
    </div>
  );
}
```

## Dependencies
- Cloudflare RealTimeKit regions
- GeoIP service for location detection  
- Analytics service for metrics
- D1 for region configuration storage

## Estimated Effort
**5 days**
- 1 day: Region infrastructure setup
- 1 day: Dynamic optimization logic
- 1 day: Region selection UI
- 1 day: Health monitoring system
- 1 day: Failover and analytics

## Notes
- Consider CDN integration for region selection
- Implement gradual rollout for new regions
- Monitor cross-region latency
- Plan for region-specific compliance
- Add region preference learning