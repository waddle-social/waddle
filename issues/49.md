# Issue #49: iOS Optimization

## User Story
As an **iOS user**, I want to **experience optimal performance and battery life** so that **I can use Waddle extensively without draining my device resources**.

## Description
Implement iOS-specific optimizations to enhance performance, reduce battery consumption, and leverage platform capabilities. This includes memory management, background processing optimization, and utilizing iOS-specific features for better user experience.

## Acceptance Criteria
- [ ] Memory usage optimization
- [ ] Battery life improvements
- [ ] App size reduction
- [ ] Launch time optimization
- [ ] Background task efficiency
- [ ] Network request optimization
- [ ] Image caching strategy
- [ ] Database query optimization

## Technical Implementation

### 1. Memory Management Optimization
```swift
// Memory-efficient image loading and caching
import UIKit
import Combine

class ImageCache {
    static let shared = ImageCache()
    
    private let memoryCache = NSCache<NSURL, UIImage>()
    private let diskCache: DiskCache
    private let downloadQueue = DispatchQueue(label: "com.waddle.imagedownload", attributes: .concurrent)
    
    init() {
        diskCache = DiskCache(name: "images")
        
        // Configure memory cache
        memoryCache.countLimit = 100
        memoryCache.totalCostLimit = 100 * 1024 * 1024 // 100 MB
        
        // Listen for memory warnings
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleMemoryWarning),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func handleMemoryWarning() {
        memoryCache.removeAllObjects()
        Logger.info("Image cache cleared due to memory warning")
    }
    
    func image(for url: URL) async -> UIImage? {
        let nsURL = url as NSURL
        
        // Check memory cache
        if let cachedImage = memoryCache.object(forKey: nsURL) {
            return cachedImage
        }
        
        // Check disk cache
        if let diskImage = await diskCache.image(for: url) {
            // Store in memory cache
            memoryCache.setObject(diskImage, forKey: nsURL, cost: diskImage.diskSize)
            return diskImage
        }
        
        // Download image
        return await downloadImage(from: url)
    }
    
    private func downloadImage(from url: URL) async -> UIImage? {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            
            guard let image = UIImage(data: data) else { return nil }
            
            // Resize if needed
            let resizedImage = await resizeImageIfNeeded(image)
            
            // Cache
            let nsURL = url as NSURL
            memoryCache.setObject(resizedImage, forKey: nsURL, cost: resizedImage.diskSize)
            await diskCache.store(resizedImage, for: url)
            
            return resizedImage
        } catch {
            Logger.error("Failed to download image: \(error)")
            return nil
        }
    }
    
    private func resizeImageIfNeeded(_ image: UIImage) async -> UIImage {
        let maxDimension: CGFloat = 1024
        
        guard image.size.width > maxDimension || image.size.height > maxDimension else {
            return image
        }
        
        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .utility).async {
                let scale = min(maxDimension / image.size.width, maxDimension / image.size.height)
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                let renderer = UIGraphicsImageRenderer(size: newSize)
                let resized = renderer.image { _ in
                    image.draw(in: CGRect(origin: .zero, size: newSize))
                }
                
                continuation.resume(returning: resized)
            }
        }
    }
}

// Memory-efficient data models
struct OptimizedMessage {
    let id: String
    let content: String
    let authorId: String
    let timestamp: Date
    
    // Lazy load additional data
    private var _author: User?
    var author: User? {
        mutating get {
            if _author == nil {
                _author = UserCache.shared.user(id: authorId)
            }
            return _author
        }
    }
    
    // Use compact storage
    private let flags: UInt8
    
    var isEdited: Bool { flags & 0x01 != 0 }
    var isPinned: Bool { flags & 0x02 != 0 }
    var hasReactions: Bool { flags & 0x04 != 0 }
    
    init(id: String, content: String, authorId: String, timestamp: Date, isEdited: Bool = false, isPinned: Bool = false, hasReactions: Bool = false) {
        self.id = id
        self.content = content
        self.authorId = authorId
        self.timestamp = timestamp
        
        var flags: UInt8 = 0
        if isEdited { flags |= 0x01 }
        if isPinned { flags |= 0x02 }
        if hasReactions { flags |= 0x04 }
        self.flags = flags
    }
}

// View recycling for large lists
struct OptimizedMessageList: View {
    let messages: [OptimizedMessage]
    @State private var visibleRange: Range<Int> = 0..<50
    
    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(spacing: 0) {
                    ForEach(visibleRange, id: \.self) { index in
                        if index < messages.count {
                            MessageRow(message: messages[index])
                                .id(index)
                                .onAppear {
                                    updateVisibleRange(around: index)
                                }
                        }
                    }
                }
            }
            .onAppear {
                // Scroll to bottom
                proxy.scrollTo(messages.count - 1, anchor: .bottom)
            }
        }
    }
    
    private func updateVisibleRange(around index: Int) {
        let bufferSize = 25
        let start = max(0, index - bufferSize)
        let end = min(messages.count, index + bufferSize)
        
        if start != visibleRange.lowerBound || end != visibleRange.upperBound {
            visibleRange = start..<end
        }
    }
}
```

### 2. Battery Optimization
```swift
// Battery-aware networking
class BatteryOptimizedNetworkManager {
    private let session: URLSession
    private var batteryMonitor: BatteryMonitor
    private var requestQueue: [PendingRequest] = []
    
    struct PendingRequest {
        let id: UUID
        let request: URLRequest
        let priority: RequestPriority
        let completion: (Result<Data, Error>) -> Void
    }
    
    enum RequestPriority {
        case critical   // Always send immediately
        case high       // Send unless battery < 20%
        case normal     // Batch with others
        case low        // Only on WiFi + charging
    }
    
    init() {
        let config = URLSessionConfiguration.default
        config.allowsCellularAccess = true
        config.isDiscretionary = false
        config.sessionSendsLaunchEvents = true
        
        self.session = URLSession(configuration: config)
        self.batteryMonitor = BatteryMonitor()
        
        setupBatteryMonitoring()
    }
    
    private func setupBatteryMonitoring() {
        batteryMonitor.onBatteryStateChange = { [weak self] state in
            self?.handleBatteryStateChange(state)
        }
    }
    
    func request(_ request: URLRequest, priority: RequestPriority = .normal) async throws -> Data {
        // Check if we should send immediately
        if shouldSendImmediately(priority: priority) {
            return try await performRequest(request)
        }
        
        // Queue the request
        return try await queueRequest(request, priority: priority)
    }
    
    private func shouldSendImmediately(priority: RequestPriority) -> Bool {
        switch priority {
        case .critical:
            return true
        case .high:
            return batteryMonitor.batteryLevel > 20
        case .normal:
            return batteryMonitor.batteryLevel > 30 && !batteryMonitor.isLowPowerModeEnabled
        case .low:
            return batteryMonitor.isCharging && NetworkMonitor.shared.isWiFi
        }
    }
    
    private func performRequest(_ request: URLRequest) async throws -> Data {
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return data
    }
    
    private func queueRequest(_ request: URLRequest, priority: RequestPriority) async throws -> Data {
        try await withCheckedThrowingContinuation { continuation in
            let pending = PendingRequest(
                id: UUID(),
                request: request,
                priority: priority,
                completion: { result in
                    continuation.resume(with: result)
                }
            )
            
            requestQueue.append(pending)
            processQueueIfNeeded()
        }
    }
    
    private func processQueueIfNeeded() {
        // Process critical requests immediately
        let criticalRequests = requestQueue.filter { $0.priority == .critical }
        for request in criticalRequests {
            Task {
                await processPendingRequest(request)
            }
        }
        
        // Batch process other requests based on conditions
        if batteryMonitor.batteryLevel > 50 || batteryMonitor.isCharging {
            batchProcessRequests()
        }
    }
    
    private func batchProcessRequests() {
        let batch = requestQueue.prefix(10) // Process up to 10 at a time
        
        Task {
            await withTaskGroup(of: Void.self) { group in
                for request in batch {
                    group.addTask {
                        await self.processPendingRequest(request)
                    }
                }
            }
        }
    }
    
    private func processPendingRequest(_ pending: PendingRequest) async {
        do {
            let data = try await performRequest(pending.request)
            pending.completion(.success(data))
        } catch {
            pending.completion(.failure(error))
        }
        
        requestQueue.removeAll { $0.id == pending.id }
    }
}

// Location services optimization
class OptimizedLocationManager: NSObject {
    private let locationManager = CLLocationManager()
    private var lastKnownLocation: CLLocation?
    private var locationUpdateTimer: Timer?
    
    override init() {
        super.init()
        locationManager.delegate = self
        configureLocationManager()
    }
    
    private func configureLocationManager() {
        // Use significant location changes for battery efficiency
        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
        locationManager.distanceFilter = 500 // Update every 500m
        locationManager.pausesLocationUpdatesAutomatically = true
        locationManager.activityType = .other
        locationManager.allowsBackgroundLocationUpdates = false
    }
    
    func startMonitoring() {
        locationManager.requestWhenInUseAuthorization()
        
        // Use different strategies based on battery
        if BatteryMonitor.shared.batteryLevel < 20 {
            // Ultra low power mode - significant changes only
            locationManager.startMonitoringSignificantLocationChanges()
        } else if BatteryMonitor.shared.batteryLevel < 50 {
            // Low power mode - reduced accuracy
            locationManager.desiredAccuracy = kCLLocationAccuracyKilometer
            locationManager.startUpdatingLocation()
        } else {
            // Normal mode
            locationManager.startUpdatingLocation()
        }
    }
    
    func stopMonitoring() {
        locationManager.stopUpdatingLocation()
        locationManager.stopMonitoringSignificantLocationChanges()
        locationUpdateTimer?.invalidate()
    }
}
```

### 3. App Size Reduction
```swift
// On-demand resource loading
class ResourceManager {
    static let shared = ResourceManager()
    
    private var loadedResources: Set<String> = []
    private let resourceQueue = DispatchQueue(label: "com.waddle.resources", attributes: .concurrent)
    
    enum ResourceTag: String {
        case onboarding = "onboarding"
        case themes = "themes"
        case soundEffects = "sounds"
        case animations = "animations"
        case languages = "languages"
    }
    
    func loadResource(tag: ResourceTag) async throws {
        guard !loadedResources.contains(tag.rawValue) else { return }
        
        let request = NSBundleResourceRequest(tags: [tag.rawValue])
        request.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent
        
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            request.beginAccessingResources { error in
                if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    self.loadedResources.insert(tag.rawValue)
                    continuation.resume()
                }
            }
        }
    }
    
    func unloadResource(tag: ResourceTag) {
        loadedResources.remove(tag.rawValue)
        // Resources are automatically unloaded when no longer referenced
    }
    
    func preloadEssentialResources() async {
        // Load only essential resources at launch
        do {
            try await loadResource(tag: .soundEffects)
        } catch {
            Logger.error("Failed to load essential resources: \(error)")
        }
    }
}

// Asset catalog optimization
struct OptimizedAssets {
    // Use SF Symbols where possible
    static let icons = IconSet()
    
    struct IconSet {
        let chat = Image(systemName: "message.fill")
        let voice = Image(systemName: "mic.fill")
        let settings = Image(systemName: "gear")
        let user = Image(systemName: "person.crop.circle.fill")
        let search = Image(systemName: "magnifyingglass")
        
        // Custom icons only when necessary
        let waddle = Image("waddle_icon")
            .resizable()
            .renderingMode(.template)
    }
    
    // Lazy load large assets
    static func loadAnimations() async -> LottieAnimations? {
        do {
            try await ResourceManager.shared.loadResource(tag: .animations)
            return LottieAnimations()
        } catch {
            return nil
        }
    }
}

// Code size optimization with generics
protocol Cacheable: Codable {
    static var cacheKey: String { get }
    var id: String { get }
}

class GenericCache<T: Cacheable> {
    private let cache = NSCache<NSString, CacheEntry>()
    private let diskCache: DiskCache
    
    private class CacheEntry {
        let value: T
        let timestamp: Date
        
        init(value: T) {
            self.value = value
            self.timestamp = Date()
        }
    }
    
    init() {
        self.diskCache = DiskCache(name: T.cacheKey)
        cache.countLimit = 100
    }
    
    func get(_ id: String) async -> T? {
        // Check memory cache
        if let entry = cache.object(forKey: id as NSString) {
            return entry.value
        }
        
        // Check disk cache
        return await diskCache.get(id, type: T.self)
    }
    
    func set(_ object: T) async {
        cache.setObject(CacheEntry(value: object), forKey: object.id as NSString)
        await diskCache.set(object, for: object.id)
    }
}
```

### 4. Launch Time Optimization
```swift
// App launch optimization
@main
struct WaddleApp: App {
    @StateObject private var appState = AppState()
    @State private var isInitialized = false
    
    init() {
        // Minimal setup in init
        configureAppearance()
    }
    
    var body: some Scene {
        WindowGroup {
            if isInitialized {
                ContentView()
                    .environmentObject(appState)
            } else {
                LaunchScreen()
                    .task {
                        await performAsyncSetup()
                        isInitialized = true
                    }
            }
        }
    }
    
    private func configureAppearance() {
        // Only essential UI configuration
        UINavigationBar.appearance().tintColor = .systemBlue
    }
    
    private func performAsyncSetup() async {
        // Defer non-critical setup
        async let auth = AuthManager.shared.initialize()
        async let cache = CacheManager.shared.warmup()
        async let resources = ResourceManager.shared.preloadEssentialResources()
        
        // Wait for critical components only
        _ = await auth
        
        // Continue with other setup in background
        Task.detached(priority: .background) {
            _ = await cache
            _ = await resources
            await DatabaseManager.shared.performMaintenance()
        }
    }
}

// Lazy view loading
struct LazyView<Content: View>: View {
    let build: () -> Content
    @State private var cache: Content?
    
    init(_ build: @autoclosure @escaping () -> Content) {
        self.build = build
    }
    
    var body: some View {
        Group {
            if let content = cache {
                content
            } else {
                ProgressView()
                    .onAppear {
                        cache = build()
                    }
            }
        }
    }
}

// Deferred module loading
class ModuleLoader {
    static let shared = ModuleLoader()
    
    private var loadedModules: Set<String> = []
    
    func loadModule<T>(_ type: T.Type) async throws -> T where T: Module {
        let moduleName = String(describing: type)
        
        guard !loadedModules.contains(moduleName) else {
            return try await instantiateModule(type)
        }
        
        // Dynamic loading
        let start = CFAbsoluteTimeGetCurrent()
        
        let module = try await instantiateModule(type)
        await module.initialize()
        
        loadedModules.insert(moduleName)
        
        let loadTime = CFAbsoluteTimeGetCurrent() - start
        Logger.debug("Loaded module \(moduleName) in \(loadTime)s")
        
        return module
    }
    
    private func instantiateModule<T: Module>(_ type: T.Type) async throws -> T {
        return type.init()
    }
}

protocol Module {
    init()
    func initialize() async
}
```

### 5. Background Task Optimization
```swift
// Efficient background processing
class BackgroundTaskManager {
    static let shared = BackgroundTaskManager()
    
    private let backgroundQueue = OperationQueue()
    private var activeTasks: [String: BGTask] = [:]
    
    init() {
        backgroundQueue.maxConcurrentOperationCount = 2
        backgroundQueue.qualityOfService = .background
        
        registerBackgroundTasks()
    }
    
    private func registerBackgroundTasks() {
        // Register background tasks
        BGTaskScheduler.shared.register(
            forTaskWithIdentifier: "com.waddle.refresh",
            using: nil
        ) { task in
            self.handleAppRefresh(task: task as! BGAppRefreshTask)
        }
        
        BGTaskScheduler.shared.register(
            forTaskWithIdentifier: "com.waddle.cleanup",
            using: nil
        ) { task in
            self.handleCleanup(task: task as! BGProcessingTask)
        }
    }
    
    func scheduleAppRefresh() {
        let request = BGAppRefreshTaskRequest(identifier: "com.waddle.refresh")
        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 minutes
        
        do {
            try BGTaskScheduler.shared.submit(request)
        } catch {
            Logger.error("Failed to schedule app refresh: \(error)")
        }
    }
    
    func scheduleCleanup() {
        let request = BGProcessingTaskRequest(identifier: "com.waddle.cleanup")
        request.requiresNetworkConnectivity = false
        request.requiresExternalPower = false
        request.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60) // 2 hours
        
        do {
            try BGTaskScheduler.shared.submit(request)
        } catch {
            Logger.error("Failed to schedule cleanup: \(error)")
        }
    }
    
    private func handleAppRefresh(task: BGAppRefreshTask) {
        scheduleAppRefresh() // Schedule next refresh
        
        let operation = RefreshOperation()
        
        task.expirationHandler = {
            operation.cancel()
        }
        
        operation.completionBlock = {
            task.setTaskCompleted(success: !operation.isCancelled)
        }
        
        backgroundQueue.addOperation(operation)
    }
    
    private func handleCleanup(task: BGProcessingTask) {
        scheduleCleanup() // Schedule next cleanup
        
        Task {
            do {
                // Clean old cache
                await CacheManager.shared.cleanExpiredItems()
                
                // Compact database
                await DatabaseManager.shared.vacuum()
                
                // Clear temp files
                await FileManager.default.clearTemporaryDirectory()
                
                task.setTaskCompleted(success: true)
            } catch {
                task.setTaskCompleted(success: false)
            }
        }
    }
}

// Efficient background downloads
class BackgroundDownloadManager: NSObject {
    private lazy var session: URLSession = {
        let config = URLSessionConfiguration.background(withIdentifier: "com.waddle.downloads")
        config.isDiscretionary = true
        config.sessionSendsLaunchEvents = true
        config.allowsCellularAccess = false
        config.shouldUseExtendedBackgroundIdleMode = true
        
        return URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }()
    
    func downloadFile(from url: URL, priority: Float = 0.5) -> URLSessionDownloadTask {
        var request = URLRequest(url: url)
        request.networkServiceType = .background
        
        let task = session.downloadTask(with: request)
        task.priority = priority
        task.resume()
        
        return task
    }
}
```

### 6. Database Query Optimization
```swift
// Core Data optimization
class OptimizedDataStore {
    private let container: NSPersistentContainer
    private let backgroundContext: NSManagedObjectContext
    
    init() {
        container = NSPersistentContainer(name: "WaddleModel")
        
        // Configure for performance
        let description = container.persistentStoreDescriptions.first!
        description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
        description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
        
        // Enable SQLite optimizations
        description.setOption(["journal_mode": "WAL"], forKey: NSSQLitePragmasOption)
        
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Failed to load store: \(error)")
            }
        }
        
        // Configure contexts
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.shouldDeleteInaccessibleFaults = true
        
        backgroundContext = container.newBackgroundContext()
        backgroundContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
    }
    
    // Batch fetch optimization
    func fetchMessages(channelId: String, limit: Int = 50) async throws -> [Message] {
        try await backgroundContext.perform {
            let request = Message.fetchRequest()
            request.predicate = NSPredicate(format: "channelId == %@", channelId)
            request.sortDescriptors = [NSSortDescriptor(key: "timestamp", ascending: false)]
            request.fetchLimit = limit
            request.fetchBatchSize = 20
            request.returnsObjectsAsFaults = false
            request.relationshipKeyPathsForPrefetching = ["author", "reactions"]
            
            return try self.backgroundContext.fetch(request)
        }
    }
    
    // Efficient count queries
    func unreadMessageCount() async throws -> Int {
        try await backgroundContext.perform {
            let request = NSFetchRequest<NSNumber>(entityName: "Message")
            request.predicate = NSPredicate(format: "isRead == NO")
            request.resultType = .countResultType
            
            let result = try self.backgroundContext.fetch(request)
            return result.first?.intValue ?? 0
        }
    }
    
    // Batch operations
    func markMessagesAsRead(channelId: String) async throws {
        try await backgroundContext.perform {
            let batchUpdate = NSBatchUpdateRequest(entityName: "Message")
            batchUpdate.predicate = NSPredicate(format: "channelId == %@ AND isRead == NO", channelId)
            batchUpdate.propertiesToUpdate = ["isRead": true]
            batchUpdate.resultType = .updatedObjectsCountResultType
            
            let result = try self.backgroundContext.execute(batchUpdate) as? NSBatchUpdateResult
            Logger.debug("Marked \(result?.result ?? 0) messages as read")
        }
    }
}
```

## Dependencies
- iOS 16+
- Core Data
- BackgroundTasks framework
- os.log for efficient logging
- Instruments for profiling

## Estimated Effort
**6 days**
- 1 day: Memory optimization implementation
- 1 day: Battery optimization
- 1 day: App size reduction
- 1 day: Launch time optimization
- 1 day: Background task efficiency
- 1 day: Testing and profiling

## Notes
- Profile before and after optimization
- Test on older devices
- Monitor crash reports
- Consider progressive optimization
- Document performance benchmarks