# Issue #07: Threading System (Zulip-style Topics)

## User Story
As a **user**, I want to **organize conversations into topics** so that **multiple discussions can happen simultaneously without confusion**.

## Description
Implement a Zulip-inspired threading system where messages can be organized into topics within channels. This allows for parallel conversations and better organization of discussions, especially in busy channels.

## Acceptance Criteria
- [ ] Messages can be posted to specific topics/threads
- [ ] Topics are auto-created when first message is sent
- [ ] Users can view all topics in a channel
- [ ] Topics show unread counts and last activity
- [ ] Users can mark entire topics as read
- [ ] Topics can be renamed by authorized users
- [ ] Search works within specific topics
- [ ] Topics auto-archive after inactivity period

## Technical Implementation

### 1. Thread Data Model
```typescript
interface Thread {
  id: string;
  channelId: string;
  title: string;
  createdBy: string;
  messageCount: number;
  participantCount: number;
  lastMessageAt: Date;
  isLocked: boolean;
  isPinned: boolean;
  autoArchiveAt?: Date;
  metadata?: {
    tags?: string[];
    color?: string;
    icon?: string;
  };
}

interface ThreadParticipant {
  threadId: string;
  userId: string;
  lastReadMessageId?: string;
  unreadCount: number;
  notificationLevel: 'all' | 'mentions' | 'none';
  joinedAt: Date;
}
```

### 2. Thread Management in Durable Objects
```javascript
export class ThreadManager {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    this.activeThreads = new Map(); // In-memory cache
  }
  
  async createOrGetThread(channelId, title, userId) {
    const threadId = this.generateThreadId(channelId, title);
    
    // Check cache first
    if (this.activeThreads.has(threadId)) {
      return this.activeThreads.get(threadId);
    }
    
    // Check database
    const db = this.getWaddleDb(channelId);
    let thread = await db.prepare(
      'SELECT * FROM threads WHERE id = ?'
    ).bind(threadId).first();
    
    if (!thread) {
      // Create new thread
      thread = {
        id: threadId,
        channel_id: channelId,
        title: title.trim(),
        created_by: userId,
        message_count: 0,
        participant_count: 0,
        last_message_at: new Date().toISOString(),
        is_locked: false,
        is_pinned: false,
        created_at: new Date().toISOString()
      };
      
      await db.prepare(`
        INSERT INTO threads (
          id, channel_id, title, created_by, message_count,
          participant_count, last_message_at, is_locked, is_pinned, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(...Object.values(thread)).run();
      
      // Broadcast thread creation
      await this.broadcastThreadUpdate('created', thread);
    }
    
    // Cache active thread
    this.activeThreads.set(threadId, thread);
    
    // Set cache expiry
    setTimeout(() => {
      this.activeThreads.delete(threadId);
    }, 300000); // 5 minutes
    
    return thread;
  }
  
  generateThreadId(channelId, title) {
    // Consistent ID generation for same channel+title
    const normalized = title.toLowerCase().trim().replace(/\s+/g, '-');
    return `${channelId}:${normalized}`;
  }
  
  async updateThreadActivity(threadId, messageId, userId) {
    const db = this.getWaddleDb(threadId);
    
    // Update thread stats
    await db.prepare(`
      UPDATE threads 
      SET message_count = message_count + 1,
          last_message_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).bind(threadId).run();
    
    // Update participant tracking
    await db.prepare(`
      INSERT INTO thread_participants (thread_id, user_id, last_activity)
      VALUES (?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT (thread_id, user_id) 
      DO UPDATE SET last_activity = CURRENT_TIMESTAMP
    `).bind(threadId, userId).run();
    
    // Update unread counts for other participants
    await db.prepare(`
      UPDATE thread_participants 
      SET unread_count = unread_count + 1
      WHERE thread_id = ? AND user_id != ?
    `).bind(threadId, userId).run();
    
    // Broadcast activity
    await this.broadcastThreadUpdate('activity', {
      threadId,
      messageId,
      userId,
      timestamp: Date.now()
    });
  }
}
```

### 3. Thread UI Components
```typescript
// React component for thread list
export function ThreadList({ channelId }: { channelId: string }) {
  const [threads, setThreads] = useState<Thread[]>([]);
  const [filter, setFilter] = useState<'all' | 'unread' | 'participating'>('all');
  
  useEffect(() => {
    const ws = new ThreadWebSocket(channelId);
    
    ws.on('threads', (data) => {
      setThreads(data.threads);
    });
    
    ws.on('thread:activity', (data) => {
      setThreads(prev => 
        prev.map(t => 
          t.id === data.threadId 
            ? { ...t, lastMessageAt: data.timestamp, unreadCount: t.unreadCount + 1 }
            : t
        ).sort((a, b) => b.lastMessageAt - a.lastMessageAt)
      );
    });
    
    return () => ws.close();
  }, [channelId]);
  
  const filteredThreads = threads.filter(thread => {
    switch (filter) {
      case 'unread':
        return thread.unreadCount > 0;
      case 'participating':
        return thread.isParticipating;
      default:
        return true;
    }
  });
  
  return (
    <div className="thread-list">
      <ThreadListHeader>
        <FilterTabs value={filter} onChange={setFilter} />
        <NewThreadButton channelId={channelId} />
      </ThreadListHeader>
      
      <VirtualList
        items={filteredThreads}
        renderItem={(thread) => (
          <ThreadItem
            key={thread.id}
            thread={thread}
            onClick={() => navigateToThread(thread.id)}
          />
        )}
      />
    </div>
  );
}

// Thread item component
function ThreadItem({ thread }: { thread: Thread }) {
  return (
    <div className="thread-item">
      <div className="thread-header">
        <h4 className="thread-title">
          {thread.isPinned && <PinIcon />}
          {thread.title}
        </h4>
        {thread.unreadCount > 0 && (
          <Badge>{thread.unreadCount}</Badge>
        )}
      </div>
      
      <div className="thread-meta">
        <span className="message-count">
          {thread.messageCount} messages
        </span>
        <span className="last-activity">
          {formatRelativeTime(thread.lastMessageAt)}
        </span>
      </div>
      
      <div className="thread-preview">
        {thread.lastMessage?.preview}
      </div>
    </div>
  );
}
```

### 4. Thread-aware Message Composer
```typescript
interface ComposerState {
  channelId: string;
  threadId?: string;
  threadTitle?: string;
  content: string;
}

export function MessageComposer({ channelId }: { channelId: string }) {
  const [state, setState] = useState<ComposerState>({
    channelId,
    content: ''
  });
  const [showThreadPicker, setShowThreadPicker] = useState(false);
  const [suggestedThreads, setSuggestedThreads] = useState<Thread[]>([]);
  
  const handleThreadInput = async (input: string) => {
    if (input.startsWith('#')) {
      // Search existing threads
      const threads = await searchThreads(channelId, input.slice(1));
      setSuggestedThreads(threads);
      setShowThreadPicker(true);
    }
  };
  
  const sendMessage = async () => {
    let threadId = state.threadId;
    
    // Auto-create thread if title provided but no ID
    if (!threadId && state.threadTitle) {
      const thread = await createThread(channelId, state.threadTitle);
      threadId = thread.id;
    }
    
    await api.sendMessage({
      channelId,
      threadId,
      content: state.content
    });
    
    // Reset composer
    setState({ channelId, content: '' });
  };
  
  return (
    <div className="message-composer">
      {state.threadTitle && (
        <div className="thread-indicator">
          <span>Topic: {state.threadTitle}</span>
          <button onClick={() => setState({ ...state, threadTitle: undefined })}>
            <CloseIcon />
          </button>
        </div>
      )}
      
      <div className="composer-input">
        <ThreadPicker
          show={showThreadPicker}
          threads={suggestedThreads}
          onSelect={(thread) => {
            setState({ ...state, threadId: thread.id, threadTitle: thread.title });
            setShowThreadPicker(false);
          }}
          onCreate={(title) => {
            setState({ ...state, threadTitle: title });
            setShowThreadPicker(false);
          }}
        />
        
        <textarea
          value={state.content}
          onChange={(e) => setState({ ...state, content: e.target.value })}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          }}
          placeholder={state.threadTitle 
            ? `Message in ${state.threadTitle}...` 
            : "Type a message or '#' for topic..."
          }
        />
        
        <button onClick={sendMessage} disabled={!state.content.trim()}>
          <SendIcon />
        </button>
      </div>
    </div>
  );
}
```

### 5. Thread Navigation and Unread Tracking
```javascript
export class ThreadNavigator {
  static async markThreadAsRead(threadId, userId, env) {
    const db = this.getWaddleDb(threadId);
    
    // Get last message in thread
    const lastMessage = await db.prepare(`
      SELECT id FROM messages 
      WHERE thread_id = ? 
      ORDER BY created_at DESC 
      LIMIT 1
    `).bind(threadId).first();
    
    if (lastMessage) {
      // Update read marker
      await db.prepare(`
        UPDATE thread_participants 
        SET last_read_message_id = ?,
            unread_count = 0,
            last_read_at = CURRENT_TIMESTAMP
        WHERE thread_id = ? AND user_id = ?
      `).bind(lastMessage.id, threadId, userId).run();
      
      // Broadcast read status
      await this.broadcastReadStatus(threadId, userId, lastMessage.id);
    }
  }
  
  static async getUnreadThreads(channelId, userId, env) {
    const db = this.getWaddleDb(channelId);
    
    const threads = await db.prepare(`
      SELECT 
        t.*,
        tp.unread_count,
        tp.last_read_message_id,
        tp.notification_level
      FROM threads t
      JOIN thread_participants tp ON t.id = tp.thread_id
      WHERE t.channel_id = ? 
        AND tp.user_id = ?
        AND tp.unread_count > 0
      ORDER BY t.last_message_at DESC
    `).bind(channelId, userId).all();
    
    return threads.results;
  }
  
  static async getThreadContext(threadId, messageId, env) {
    const db = this.getWaddleDb(threadId);
    
    // Get messages around the target message
    const context = await db.prepare(`
      WITH target AS (
        SELECT created_at 
        FROM messages 
        WHERE id = ?
      )
      SELECT m.*, u.username, u.avatar_url
      FROM messages m
      JOIN users u ON m.user_id = u.id
      WHERE m.thread_id = ?
        AND m.created_at BETWEEN 
          (SELECT datetime(created_at, '-1 minute') FROM target)
          AND 
          (SELECT datetime(created_at, '+1 minute') FROM target)
      ORDER BY m.created_at
      LIMIT 20
    `).bind(messageId, threadId).all();
    
    return context.results;
  }
}
```

### 6. Thread Search and Filtering
```javascript
export class ThreadSearch {
  static async searchThreads(channelId, query, options = {}, env) {
    const db = this.getWaddleDb(channelId);
    
    const {
      authorId,
      afterDate,
      beforeDate,
      hasAttachments,
      isUnread,
      limit = 20
    } = options;
    
    let sql = `
      SELECT DISTINCT
        t.*,
        COUNT(m.id) as match_count,
        MIN(m.created_at) as first_match,
        MAX(m.created_at) as last_match
      FROM threads t
      JOIN messages m ON t.id = m.thread_id
      WHERE t.channel_id = ?
    `;
    
    const params = [channelId];
    
    // Add search condition
    if (query) {
      sql += ` AND (t.title LIKE ? OR m.content LIKE ?)`;
      params.push(`%${query}%`, `%${query}%`);
    }
    
    // Add filters
    if (authorId) {
      sql += ` AND m.user_id = ?`;
      params.push(authorId);
    }
    
    if (afterDate) {
      sql += ` AND m.created_at > ?`;
      params.push(afterDate);
    }
    
    if (beforeDate) {
      sql += ` AND m.created_at < ?`;
      params.push(beforeDate);
    }
    
    if (hasAttachments) {
      sql += ` AND json_array_length(m.metadata, '$.attachments') > 0`;
    }
    
    sql += `
      GROUP BY t.id
      ORDER BY last_match DESC
      LIMIT ?
    `;
    params.push(limit);
    
    const results = await db.prepare(sql).bind(...params).all();
    
    // Add unread status if requested
    if (isUnread && options.userId) {
      // Join with participant data
      return this.enrichWithUnreadStatus(results.results, options.userId, env);
    }
    
    return results.results;
  }
}
```

### 7. Thread Auto-archival
```javascript
export class ThreadArchiver {
  static async archiveInactiveThreads(channelId, env) {
    const db = this.getWaddleDb(channelId);
    
    // Find threads inactive for 30 days
    const inactiveThreads = await db.prepare(`
      UPDATE threads
      SET is_archived = true,
          archived_at = CURRENT_TIMESTAMP
      WHERE channel_id = ?
        AND last_message_at < datetime('now', '-30 days')
        AND is_archived = false
        AND is_pinned = false
      RETURNING id, title
    `).bind(channelId).all();
    
    // Notify participants
    for (const thread of inactiveThreads.results) {
      await this.notifyArchival(thread, env);
    }
    
    return inactiveThreads.results;
  }
  
  static async scheduleArchival(env) {
    // Run daily via Cron Trigger
    const channels = await this.getActiveChannels(env);
    
    for (const channel of channels) {
      await this.archiveInactiveThreads(channel.id, env);
    }
  }
}
```

## Dependencies
- Message Flow (Issue #06) for message handling
- Database Schema (Issue #05) for thread tables
- WebSocket Architecture (Issue #04) for real-time updates

## Estimated Effort
**6 days**
- 1 day: Thread data model and database schema
- 2 days: Thread management and DO implementation
- 1 day: UI components for thread navigation
- 1 day: Thread search and filtering
- 1 day: Unread tracking and notifications

## Notes
- Consider thread templates for recurring topics
- Add thread analytics for popular discussions
- Implement thread merging for duplicate topics
- Plan for thread export functionality