# Issue #14: RealTimeKit Session Management

## User Story
As a **developer**, I want to **manage RealTimeKit sessions efficiently** so that **voice channels have reliable, low-latency audio with proper lifecycle management**.

## Description
Implement comprehensive session management for RealTimeKit, including session creation, participant management, error handling, and resource cleanup. This will coordinate between Durable Objects and RealTimeKit's infrastructure.

## Acceptance Criteria
- [ ] Sessions created on-demand when first user joins
- [ ] Session lifecycle tied to channel activity
- [ ] Automatic cleanup of idle sessions
- [ ] Participant tokens properly scoped
- [ ] Session state synchronized with DOs
- [ ] Graceful handling of RTK failures
- [ ] Session migration for long-running calls
- [ ] Metrics and monitoring integration

## Technical Implementation

### 1. RTK Session Manager
```javascript
export class RTKSessionManager {
  constructor(env) {
    this.env = env;
    this.sessions = new Map(); // channelId -> RTKSession
    this.sessionTimers = new Map(); // sessionId -> cleanup timer
  }
  
  async createSession(channelId, config = {}) {
    // Check if session already exists
    if (this.sessions.has(channelId)) {
      return this.sessions.get(channelId);
    }
    
    try {
      // Create RTK session configuration
      const sessionConfig = {
        sessionId: `waddle_${channelId}_${Date.now()}`,
        maxParticipants: config.maxParticipants || 100,
        features: {
          recording: config.recordingEnabled || false,
          transcription: config.transcriptionEnabled || false,
          noiseSupression: true,
          echoCancellation: true,
          automaticGainControl: true,
          ...config.features
        },
        webhooks: {
          participantJoined: `${this.env.WORKER_URL}/rtk/participant-joined`,
          participantLeft: `${this.env.WORKER_URL}/rtk/participant-left`,
          sessionEnded: `${this.env.WORKER_URL}/rtk/session-ended`,
          recordingReady: `${this.env.WORKER_URL}/rtk/recording-ready`
        },
        metadata: {
          channelId,
          waddleId: this.extractWaddleId(channelId),
          createdAt: Date.now()
        }
      };
      
      // Create session via RTK API
      const response = await fetch(`${this.env.RTK_API_URL}/sessions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.env.RTK_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(sessionConfig)
      });
      
      if (!response.ok) {
        throw new Error(`RTK session creation failed: ${response.statusText}`);
      }
      
      const rtkSession = await response.json();
      
      // Create session object
      const session = {
        id: rtkSession.id,
        channelId,
        rtkSessionId: rtkSession.sessionId,
        createdAt: Date.now(),
        config: sessionConfig,
        participants: new Map(),
        state: 'active',
        metrics: {
          peakParticipants: 0,
          totalParticipantTime: 0,
          lastActivity: Date.now()
        }
      };
      
      // Cache session
      this.sessions.set(channelId, session);
      
      // Store in database
      await this.persistSession(session);
      
      // Set idle cleanup timer
      this.scheduleIdleCleanup(session.id);
      
      return session;
      
    } catch (error) {
      console.error('Failed to create RTK session:', error);
      throw new Error('Voice session creation failed');
    }
  }
  
  async generateParticipantToken(sessionId, userId, permissions) {
    const session = this.getSessionById(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }
    
    // Token configuration based on permissions
    const tokenConfig = {
      sessionId: session.rtkSessionId,
      participantId: userId,
      permissions: {
        canPublish: permissions.canSpeak,
        canSubscribe: true,
        canRecord: permissions.canRecord || false,
        canScreenShare: permissions.canStream || false,
        maxVideoBitrate: permissions.canUseVideo ? 1500000 : 0,
        maxAudioBitrate: 96000
      },
      metadata: {
        userId,
        username: await this.getUsername(userId),
        joinedAt: Date.now()
      },
      expiresIn: 3600 // 1 hour
    };
    
    // Generate token via RTK API
    const response = await fetch(`${this.env.RTK_API_URL}/sessions/${session.rtkSessionId}/tokens`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.RTK_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(tokenConfig)
    });
    
    if (!response.ok) {
      throw new Error('Failed to generate participant token');
    }
    
    const { token } = await response.json();
    
    // Track participant
    session.participants.set(userId, {
      joinedAt: Date.now(),
      permissions,
      tokenIssuedAt: Date.now()
    });
    
    // Update metrics
    session.metrics.peakParticipants = Math.max(
      session.metrics.peakParticipants,
      session.participants.size
    );
    session.metrics.lastActivity = Date.now();
    
    // Reset idle timer
    this.resetIdleTimer(session.id);
    
    return token;
  }
  
  async handleParticipantLeft(sessionId, userId) {
    const session = this.getSessionById(sessionId);
    if (!session) return;
    
    const participant = session.participants.get(userId);
    if (participant) {
      // Update participant time metric
      const duration = Date.now() - participant.joinedAt;
      session.metrics.totalParticipantTime += duration;
      
      // Remove participant
      session.participants.delete(userId);
      
      // Check if session should end
      if (session.participants.size === 0) {
        this.scheduleIdleCleanup(session.id, 300000); // 5 minutes
      }
    }
  }
  
  scheduleIdleCleanup(sessionId, delay = 900000) { // 15 minutes default
    // Clear existing timer
    this.clearIdleTimer(sessionId);
    
    const timer = setTimeout(async () => {
      await this.checkAndCleanupSession(sessionId);
    }, delay);
    
    this.sessionTimers.set(sessionId, timer);
  }
  
  async checkAndCleanupSession(sessionId) {
    const session = this.getSessionById(sessionId);
    if (!session) return;
    
    // Check if truly idle
    const idleTime = Date.now() - session.metrics.lastActivity;
    const isEmpty = session.participants.size === 0;
    
    if (isEmpty && idleTime > 300000) { // 5 minutes
      await this.endSession(sessionId);
    }
  }
  
  async endSession(sessionId) {
    const session = this.getSessionById(sessionId);
    if (!session || session.state === 'ended') return;
    
    try {
      // End RTK session
      await fetch(`${this.env.RTK_API_URL}/sessions/${session.rtkSessionId}/end`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.env.RTK_API_KEY}`
        }
      });
      
      // Update state
      session.state = 'ended';
      session.endedAt = Date.now();
      
      // Save final metrics
      await this.saveSessionMetrics(session);
      
      // Clean up
      this.sessions.delete(session.channelId);
      this.clearIdleTimer(session.id);
      
      // Notify channel DO
      await this.notifyChannelSessionEnded(session.channelId);
      
    } catch (error) {
      console.error('Failed to end RTK session:', error);
    }
  }
}
```

### 2. Session State Synchronization
```javascript
export class RTKStateSynchronizer {
  constructor(sessionManager, durableObject) {
    this.sessionManager = sessionManager;
    this.durableObject = durableObject;
    this.syncInterval = null;
  }
  
  startSync() {
    // Sync every 30 seconds
    this.syncInterval = setInterval(() => {
      this.syncSessionState();
    }, 30000);
  }
  
  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
  }
  
  async syncSessionState() {
    const session = this.sessionManager.getActiveSession();
    if (!session) return;
    
    try {
      // Get RTK session state
      const rtkState = await this.fetchRTKState(session.rtkSessionId);
      
      // Compare with local state
      const discrepancies = this.compareStates(session, rtkState);
      
      if (discrepancies.length > 0) {
        await this.reconcileStates(session, rtkState, discrepancies);
      }
      
      // Update last sync time
      session.lastSyncAt = Date.now();
      
    } catch (error) {
      console.error('State sync failed:', error);
      this.handleSyncError(error);
    }
  }
  
  async fetchRTKState(rtkSessionId) {
    const response = await fetch(
      `${this.sessionManager.env.RTK_API_URL}/sessions/${rtkSessionId}/state`,
      {
        headers: {
          'Authorization': `Bearer ${this.sessionManager.env.RTK_API_KEY}`
        }
      }
    );
    
    if (!response.ok) {
      throw new Error('Failed to fetch RTK state');
    }
    
    return response.json();
  }
  
  compareStates(localSession, rtkState) {
    const discrepancies = [];
    
    // Check participant count
    if (localSession.participants.size !== rtkState.participantCount) {
      discrepancies.push({
        type: 'participant_count',
        local: localSession.participants.size,
        remote: rtkState.participantCount
      });
    }
    
    // Check participant list
    const localParticipants = new Set(localSession.participants.keys());
    const remoteParticipants = new Set(rtkState.participants.map(p => p.id));
    
    for (const pid of localParticipants) {
      if (!remoteParticipants.has(pid)) {
        discrepancies.push({
          type: 'missing_remote_participant',
          participantId: pid
        });
      }
    }
    
    for (const pid of remoteParticipants) {
      if (!localParticipants.has(pid)) {
        discrepancies.push({
          type: 'missing_local_participant',
          participantId: pid
        });
      }
    }
    
    return discrepancies;
  }
  
  async reconcileStates(session, rtkState, discrepancies) {
    for (const discrepancy of discrepancies) {
      switch (discrepancy.type) {
        case 'missing_local_participant':
          // Add participant to local state
          await this.addMissingParticipant(session, discrepancy.participantId);
          break;
          
        case 'missing_remote_participant':
          // Remove from local state
          await this.removeStaleParticipant(session, discrepancy.participantId);
          break;
          
        case 'participant_count':
          // Log for monitoring
          console.warn('Participant count mismatch:', discrepancy);
          break;
      }
    }
  }
}
```

### 3. Error Handling and Recovery
```javascript
export class RTKErrorHandler {
  static async handleError(error, context) {
    const errorHandlers = {
      'SESSION_NOT_FOUND': this.handleSessionNotFound,
      'TOKEN_EXPIRED': this.handleTokenExpired,
      'RATE_LIMITED': this.handleRateLimited,
      'SERVICE_UNAVAILABLE': this.handleServiceUnavailable,
      'PERMISSION_DENIED': this.handlePermissionDenied
    };
    
    const handler = errorHandlers[error.code] || this.handleGenericError;
    return handler.call(this, error, context);
  }
  
  static async handleSessionNotFound(error, context) {
    console.error('RTK session not found:', error);
    
    // Attempt to recreate session
    try {
      const newSession = await context.sessionManager.createSession(
        context.channelId,
        context.config
      );
      
      // Notify participants to rejoin
      await context.notifyParticipantsToRejoin(newSession);
      
      return { recovered: true, newSession };
    } catch (recreateError) {
      console.error('Failed to recreate session:', recreateError);
      return { recovered: false, error: 'Voice channel unavailable' };
    }
  }
  
  static async handleTokenExpired(error, context) {
    // Generate new token
    try {
      const newToken = await context.sessionManager.generateParticipantToken(
        context.sessionId,
        context.userId,
        context.permissions
      );
      
      return { recovered: true, token: newToken };
    } catch (tokenError) {
      return { recovered: false, error: 'Failed to refresh voice token' };
    }
  }
  
  static async handleRateLimited(error, context) {
    const retryAfter = error.retryAfter || 60;
    
    // Schedule retry
    setTimeout(() => {
      context.retry();
    }, retryAfter * 1000);
    
    return {
      recovered: false,
      error: `Rate limited. Please try again in ${retryAfter} seconds.`,
      retryAfter
    };
  }
  
  static async handleServiceUnavailable(error, context) {
    // Implement circuit breaker pattern
    if (!this.circuitBreaker) {
      this.circuitBreaker = new CircuitBreaker();
    }
    
    if (this.circuitBreaker.isOpen()) {
      return {
        recovered: false,
        error: 'Voice service temporarily unavailable'
      };
    }
    
    this.circuitBreaker.recordFailure();
    
    // Try fallback if available
    if (context.fallback) {
      return context.fallback();
    }
    
    return {
      recovered: false,
      error: 'Voice service unavailable. Please try again later.'
    };
  }
}
```

### 4. Session Migration
```javascript
export class RTKSessionMigration {
  static async migrateSession(oldSession, reason) {
    console.log(`Migrating session ${oldSession.id} due to: ${reason}`);
    
    try {
      // Create new session with same config
      const newSession = await this.createReplacementSession(oldSession);
      
      // Get current participants
      const participants = Array.from(oldSession.participants.entries());
      
      // Notify participants of migration
      await this.notifyMigration(participants, oldSession, newSession);
      
      // Wait for participants to join new session
      await this.waitForParticipantMigration(participants, newSession, 30000);
      
      // End old session
      await this.gracefullyEndSession(oldSession);
      
      return {
        success: true,
        newSession,
        migratedCount: newSession.participants.size
      };
      
    } catch (error) {
      console.error('Session migration failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  static async createReplacementSession(oldSession) {
    const newConfig = {
      ...oldSession.config,
      metadata: {
        ...oldSession.config.metadata,
        migratedFrom: oldSession.id,
        migrationReason: reason,
        migratedAt: Date.now()
      }
    };
    
    return this.sessionManager.createSession(
      oldSession.channelId,
      newConfig
    );
  }
  
  static async notifyMigration(participants, oldSession, newSession) {
    const notifications = participants.map(([userId, participant]) => {
      return this.sendMigrationNotice(userId, {
        oldSessionId: oldSession.id,
        newSessionId: newSession.id,
        reason: 'session_migration',
        action: 'rejoin_required'
      });
    });
    
    await Promise.all(notifications);
  }
}
```

### 5. Monitoring and Analytics
```javascript
export class RTKSessionMonitor {
  constructor(env) {
    this.env = env;
    this.metrics = new Map();
  }
  
  async collectMetrics(session) {
    const metrics = {
      sessionId: session.id,
      channelId: session.channelId,
      timestamp: Date.now(),
      participants: session.participants.size,
      duration: Date.now() - session.createdAt,
      state: session.state,
      health: await this.checkSessionHealth(session)
    };
    
    // Collect RTK-specific metrics
    try {
      const rtkMetrics = await this.fetchRTKMetrics(session.rtkSessionId);
      metrics.rtk = {
        packetsLost: rtkMetrics.packetsLost,
        jitter: rtkMetrics.jitter,
        latency: rtkMetrics.latency,
        bandwidth: rtkMetrics.bandwidth
      };
    } catch (error) {
      metrics.rtk = { error: error.message };
    }
    
    // Store metrics
    this.metrics.set(session.id, metrics);
    
    // Send to analytics
    await this.sendToAnalytics(metrics);
    
    return metrics;
  }
  
  async checkSessionHealth(session) {
    const checks = {
      hasParticipants: session.participants.size > 0,
      isActive: session.state === 'active',
      recentActivity: Date.now() - session.metrics.lastActivity < 300000,
      noErrors: !session.lastError
    };
    
    const healthScore = Object.values(checks).filter(Boolean).length / Object.keys(checks).length;
    
    return {
      score: healthScore,
      checks,
      status: healthScore > 0.75 ? 'healthy' : healthScore > 0.5 ? 'degraded' : 'unhealthy'
    };
  }
  
  async sendToAnalytics(metrics) {
    // Send to your analytics service
    await fetch(`${this.env.ANALYTICS_URL}/voice-metrics`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.env.ANALYTICS_KEY}`
      },
      body: JSON.stringify(metrics)
    });
  }
}
```

### 6. WebSocket Integration
```javascript
// In Durable Object
export class VoiceChannelDO {
  async handleRTKWebhook(request) {
    const event = await request.json();
    
    switch (event.type) {
      case 'participant.joined':
        await this.handleParticipantJoined(event);
        break;
        
      case 'participant.left':
        await this.handleParticipantLeft(event);
        break;
        
      case 'participant.speaking':
        await this.handleSpeakingUpdate(event);
        break;
        
      case 'session.ended':
        await this.handleSessionEnded(event);
        break;
        
      case 'recording.ready':
        await this.handleRecordingReady(event);
        break;
    }
    
    return new Response('OK');
  }
  
  async handleParticipantJoined(event) {
    const { participantId, sessionId, metadata } = event;
    
    // Update local state
    const participant = this.participants.get(participantId);
    if (participant) {
      participant.rtkState = 'connected';
      participant.connectedAt = Date.now();
    }
    
    // Broadcast to WebSocket clients
    this.broadcast({
      type: 'voice_state_update',
      userId: participantId,
      channelId: this.channelId,
      state: 'connected'
    });
  }
  
  async handleSpeakingUpdate(event) {
    const { participantId, isSpeaking } = event;
    
    // Throttle speaking updates
    const lastUpdate = this.lastSpeakingUpdate.get(participantId) || 0;
    if (Date.now() - lastUpdate < 250) return; // 250ms throttle
    
    this.lastSpeakingUpdate.set(participantId, Date.now());
    
    // Broadcast speaking indicator
    this.broadcast({
      type: 'speaking_update',
      userId: participantId,
      isSpeaking
    });
  }
}
```

## Dependencies
- RealTimeKit Setup (Issue #02) for RTK configuration
- Voice Channel Model (Issue #13) for data structures
- WebSocket Architecture (Issue #04) for real-time updates

## Estimated Effort
**5 days**
- 1 day: Core session manager implementation
- 1 day: State synchronization and monitoring
- 1 day: Error handling and recovery
- 1 day: Session migration and analytics
- 1 day: Testing and webhook integration

## Notes
- Monitor RTK API rate limits closely
- Implement session pooling for frequently used channels
- Consider pre-warming sessions for scheduled events
- Add detailed logging for debugging voice issues