# Issue #04: WebSocket Architecture

## User Story
As a **user**, I want to **receive messages instantly** so that **I can have real-time conversations without refreshing**.

## Description
Implement a scalable WebSocket architecture using Cloudflare Durable Objects with hibernation for cost-effective real-time messaging. This will handle message delivery, presence updates, and typing indicators.

## Acceptance Criteria
- [ ] WebSocket connections established through Durable Objects
- [ ] Messages broadcast to all channel participants in <100ms
- [ ] WebSocket hibernation reduces costs by 90%
- [ ] Automatic reconnection with message replay
- [ ] Connection state persisted across DO restarts
- [ ] Support for 1000+ concurrent connections per DO
- [ ] Graceful handling of connection limits

## Technical Implementation

### 1. WebSocket Connection Manager
```javascript
export class ChannelWebSocketDO {
  constructor(state, env) {
    this.state = state;
    this.env = env;
    // Don't store WebSockets in memory - use hibernation
  }
  
  async fetch(request) {
    const url = new URL(request.url);
    
    if (url.pathname === '/websocket') {
      return this.handleWebSocketUpgrade(request);
    }
    
    return new Response('Not found', { status: 404 });
  }
  
  async handleWebSocketUpgrade(request) {
    // Verify authentication
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await verifyToken(token, this.env);
    
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }
    
    // Check connection limit (Hibernation API supports 32,768)
    const connections = this.state.getWebSockets();
    if (connections.length >= 1000) { // Soft limit for performance
      return new Response('Channel full', { status: 503 });
    }
    
    // Create WebSocket pair
    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);
    
    // Accept WebSocket with hibernation
    this.state.acceptWebSocket(server, [`user:${user.id}`]);
    
    // Attach metadata for hibernation
    server.serializeAttachment({
      userId: user.id,
      username: user.username,
      joinedAt: Date.now(),
      permissions: user.permissions
    });
    
    // Send initial state
    this.sendInitialState(server);
    
    return new Response(null, {
      status: 101,
      webSocket: client,
    });
  }
  
  async sendInitialState(ws) {
    // Get recent messages from D1
    const messages = await this.getRecentMessages();
    
    ws.send(JSON.stringify({
      type: 'initial_state',
      messages,
      onlineUsers: this.getOnlineUsers()
    }));
  }
}
```

### 2. Message Broadcasting with Hibernation
```javascript
// Hibernation event handlers
export class ChannelWebSocketDO {
  async webSocketMessage(ws, message) {
    const attachment = ws.deserializeAttachment();
    const { userId, username, permissions } = attachment;
    
    try {
      const data = JSON.parse(message);
      
      switch (data.type) {
        case 'message':
          await this.handleMessage(ws, data, attachment);
          break;
          
        case 'typing':
          await this.handleTyping(ws, data, attachment);
          break;
          
        case 'presence':
          await this.handlePresence(ws, data, attachment);
          break;
          
        default:
          ws.send(JSON.stringify({
            type: 'error',
            message: 'Unknown message type'
          }));
      }
    } catch (error) {
      console.error('WebSocket message error:', error);
      ws.send(JSON.stringify({
        type: 'error',
        message: 'Invalid message format'
      }));
    }
  }
  
  async handleMessage(ws, data, attachment) {
    // Validate permissions
    if (!attachment.permissions.includes('write')) {
      ws.send(JSON.stringify({
        type: 'error',
        message: 'No write permission'
      }));
      return;
    }
    
    // Create message
    const message = {
      id: crypto.randomUUID(),
      channelId: this.state.id.toString(),
      userId: attachment.userId,
      username: attachment.username,
      content: data.content,
      timestamp: Date.now(),
      threadId: data.threadId
    };
    
    // Store in D1 (async, don't block)
    this.env.ctx.waitUntil(
      this.storeMessage(message)
    );
    
    // Broadcast to all connected clients
    const broadcastData = JSON.stringify({
      type: 'message',
      message
    });
    
    // Get all WebSockets with the same tag (channel subscribers)
    for (const client of this.state.getWebSockets()) {
      try {
        client.send(broadcastData);
      } catch (err) {
        // Client disconnected, will be cleaned up
      }
    }
  }
  
  async handleTyping(ws, data, attachment) {
    // Don't persist typing indicators
    const typingData = JSON.stringify({
      type: 'typing',
      userId: attachment.userId,
      username: attachment.username,
      isTyping: data.isTyping
    });
    
    // Broadcast to others (not sender)
    for (const client of this.state.getWebSockets()) {
      if (client !== ws) {
        try {
          client.send(typingData);
        } catch (err) {
          // Client disconnected
        }
      }
    }
  }
}
```

### 3. Connection State Management
```javascript
export class ChannelWebSocketDO {
  async webSocketClose(ws, code, reason, wasClean) {
    const attachment = ws.deserializeAttachment();
    
    // Notify others of disconnect
    const disconnectData = JSON.stringify({
      type: 'user_disconnected',
      userId: attachment.userId,
      username: attachment.username
    });
    
    for (const client of this.state.getWebSockets()) {
      try {
        client.send(disconnectData);
      } catch (err) {
        // Client disconnected
      }
    }
    
    // Log disconnection
    console.log(`User ${attachment.userId} disconnected: ${code} ${reason}`);
  }
  
  async webSocketError(ws, error) {
    const attachment = ws.deserializeAttachment();
    console.error(`WebSocket error for user ${attachment.userId}:`, error);
    
    // Close the connection
    ws.close(1011, 'Internal server error');
  }
  
  getOnlineUsers() {
    const users = [];
    
    for (const ws of this.state.getWebSockets()) {
      const attachment = ws.deserializeAttachment();
      users.push({
        userId: attachment.userId,
        username: attachment.username,
        joinedAt: attachment.joinedAt
      });
    }
    
    return users;
  }
}
```

### 4. Client Reconnection Logic
```javascript
// Web client
class WaddleWebSocket {
  constructor(channelId, token) {
    this.channelId = channelId;
    this.token = token;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.messageQueue = [];
    this.lastMessageId = null;
  }
  
  connect() {
    const wsUrl = `wss://waddle.chat/channel/${this.channelId}/websocket`;
    
    this.ws = new WebSocket(wsUrl, {
      headers: {
        'Authorization': `Bearer ${this.token}`
      }
    });
    
    this.ws.onopen = () => {
      console.log('Connected to channel');
      this.reconnectAttempts = 0;
      
      // Send queued messages
      this.flushMessageQueue();
      
      // Request missed messages
      if (this.lastMessageId) {
        this.ws.send(JSON.stringify({
          type: 'sync',
          afterMessageId: this.lastMessageId
        }));
      }
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'message') {
        this.lastMessageId = data.message.id;
      }
      
      this.emit(data.type, data);
    };
    
    this.ws.onclose = (event) => {
      console.log('Disconnected:', event.code, event.reason);
      
      // Reconnect with exponential backoff
      if (!event.wasClean) {
        this.scheduleReconnect();
      }
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }
  
  scheduleReconnect() {
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    this.reconnectAttempts++;
    
    setTimeout(() => {
      console.log(`Reconnecting... (attempt ${this.reconnectAttempts})`);
      this.connect();
    }, delay);
  }
  
  send(data) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    } else {
      // Queue message for later
      this.messageQueue.push(data);
    }
  }
  
  flushMessageQueue() {
    while (this.messageQueue.length > 0 && this.ws?.readyState === WebSocket.OPEN) {
      const data = this.messageQueue.shift();
      this.ws.send(JSON.stringify(data));
    }
  }
}
```

### 5. Message Persistence
```javascript
export class ChannelWebSocketDO {
  async storeMessage(message) {
    const waddleId = this.extractWaddleId(message.channelId);
    
    // Get waddle's D1 database
    const db = this.env[`WADDLE_DB_${waddleId}`];
    
    await db.prepare(`
      INSERT INTO messages (id, channel_id, user_id, content, thread_id, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `).bind(
      message.id,
      message.channelId,
      message.userId,
      message.content,
      message.threadId,
      new Date(message.timestamp).toISOString()
    ).run();
  }
  
  async getRecentMessages(limit = 50) {
    const waddleId = this.extractWaddleId(this.state.id.toString());
    const db = this.env[`WADDLE_DB_${waddleId}`];
    
    const results = await db.prepare(`
      SELECT m.*, u.username, u.avatar_url
      FROM messages m
      JOIN users u ON m.user_id = u.id
      WHERE m.channel_id = ?
      ORDER BY m.created_at DESC
      LIMIT ?
    `).bind(this.state.id.toString(), limit).all();
    
    return results.results.reverse(); // Oldest first
  }
}
```

### 6. Load Balancing for Large Channels
```javascript
// Worker routes to appropriate shard
export default {
  async fetch(request, env) {
    const { channelId } = parseChannelId(request);
    
    // Check if channel needs sharding
    const channelInfo = await env.CHANNELS_DB.prepare(
      'SELECT member_count, shard_count FROM channels WHERE id = ?'
    ).bind(channelId).first();
    
    if (channelInfo.shard_count > 1) {
      // Route to shard based on user ID for consistent connections
      const userId = await getUserIdFromToken(request, env);
      const shardIndex = hashUserId(userId) % channelInfo.shard_count;
      const doId = env.CHANNEL_DO.idFromName(`${channelId}-shard-${shardIndex}`);
      const stub = env.CHANNEL_DO.get(doId);
      
      return stub.fetch(request);
    }
    
    // Single DO for small channels
    const doId = env.CHANNEL_DO.idFromName(channelId);
    const stub = env.CHANNEL_DO.get(doId);
    
    return stub.fetch(request);
  }
};
```

## Dependencies
- Authentication system (Issue #03) for token validation
- Waddle entity model (Issue #01) for channel structure
- D1 database setup (Issue #05) for message persistence

## Estimated Effort
**4 days**
- 1 day: Basic WebSocket setup with hibernation
- 1 day: Message broadcasting and persistence
- 1 day: Client reconnection and state sync
- 1 day: Load testing and sharding logic

## Notes
- Hibernation API dramatically reduces costs
- Monitor WebSocket connection limits (32,768 max)
- Consider implementing message delivery receipts
- Plan for gradual migration to sharded channels