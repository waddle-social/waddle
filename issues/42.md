# Issue #42: Audience Features

## User Story
As a **stream viewer or voice channel listener**, I want to **interact with live content through reactions, polls, and participation features** so that **I can engage with broadcasters and other audience members in meaningful ways**.

## Description
Implement comprehensive audience interaction features for voice streams and broadcasts, including real-time reactions, polls, Q&A sessions, virtual hand raising, and audience participation modes. These features enhance engagement and create a more interactive experience for both content creators and viewers.

## Acceptance Criteria
- [ ] Real-time emoji reactions
- [ ] Interactive polls and surveys  
- [ ] Q&A queue management
- [ ] Virtual hand raising
- [ ] Audience chat with moderation
- [ ] Viewer rewards and badges
- [ ] Participation analytics
- [ ] Accessibility features

## Technical Implementation

### 1. Real-time Reactions System
```typescript
// Reaction types and management
export interface ReactionConfig {
  enabled: boolean;
  cooldown: number; // ms between reactions
  burstLimit: number; // max reactions in burst
  customEmojis: string[];
  animationStyle: 'bubble' | 'wave' | 'firework';
}

export class ReactionManager {
  private reactionQueue = new Map<string, ReactionBatch>();
  private userCooldowns = new Map<string, number>();
  private reactionStats = new Map<string, ReactionStats>();
  
  constructor(
    private config: ReactionConfig,
    private broadcaster: ReactionBroadcaster,
    private analytics: AnalyticsService
  ) {}
  
  async sendReaction(
    userId: string,
    streamId: string,
    reaction: string,
    metadata?: ReactionMetadata
  ): Promise<void> {
    // Check if reactions are enabled
    if (!this.config.enabled) {
      throw new Error('Reactions are disabled');
    }
    
    // Validate reaction
    if (!this.isValidReaction(reaction)) {
      throw new Error('Invalid reaction');
    }
    
    // Check cooldown
    if (this.isUserOnCooldown(userId)) {
      throw new Error('Please wait before reacting again');
    }
    
    // Check burst limit
    if (this.exceedsBurstLimit(userId)) {
      throw new Error('Too many reactions, please slow down');
    }
    
    // Create reaction event
    const reactionEvent: ReactionEvent = {
      id: crypto.randomUUID(),
      userId,
      streamId,
      reaction,
      timestamp: Date.now(),
      metadata: {
        ...metadata,
        userColor: await this.getUserColor(userId),
        position: this.calculatePosition()
      }
    };
    
    // Add to batch
    this.addToBatch(streamId, reactionEvent);
    
    // Update cooldown
    this.updateCooldown(userId);
    
    // Update stats
    this.updateStats(streamId, reaction);
    
    // Track analytics
    await this.analytics.track('reaction_sent', {
      streamId,
      reaction,
      userId
    });
  }
  
  private addToBatch(streamId: string, reaction: ReactionEvent) {
    let batch = this.reactionQueue.get(streamId);
    
    if (!batch) {
      batch = {
        streamId,
        reactions: [],
        scheduledTime: Date.now() + 50 // 50ms batching
      };
      this.reactionQueue.set(streamId, batch);
      
      // Schedule batch send
      setTimeout(() => this.sendBatch(streamId), 50);
    }
    
    batch.reactions.push(reaction);
  }
  
  private async sendBatch(streamId: string) {
    const batch = this.reactionQueue.get(streamId);
    if (!batch || batch.reactions.length === 0) return;
    
    // Remove from queue
    this.reactionQueue.delete(streamId);
    
    // Broadcast to all viewers
    await this.broadcaster.broadcastReactions(streamId, batch.reactions);
    
    // Emit local event for UI
    this.emit('reactions', {
      streamId,
      reactions: batch.reactions
    });
  }
  
  private isValidReaction(reaction: string): boolean {
    // Check if it's a standard emoji
    const standardEmojis = ['â¤ï¸', 'ðŸ‘', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ‘', 'ðŸ”¥', 'ðŸ’¯', 'ðŸŽ‰'];
    if (standardEmojis.includes(reaction)) return true;
    
    // Check if it's a custom emoji
    if (this.config.customEmojis.includes(reaction)) return true;
    
    // Check if it's a valid unicode emoji
    return this.isUnicodeEmoji(reaction);
  }
  
  private isUnicodeEmoji(str: string): boolean {
    const emojiRegex = /\p{Emoji}/u;
    return emojiRegex.test(str);
  }
  
  private calculatePosition(): { x: number; y: number } {
    // Random position for reaction animation
    return {
      x: Math.random() * 100, // 0-100% of container width
      y: 80 + Math.random() * 15 // 80-95% of container height
    };
  }
  
  getReactionStats(streamId: string): ReactionStats {
    return this.reactionStats.get(streamId) || {
      total: 0,
      byType: new Map(),
      peakRate: 0,
      uniqueReactors: new Set()
    };
  }
  
  private updateStats(streamId: string, reaction: string) {
    let stats = this.reactionStats.get(streamId);
    
    if (!stats) {
      stats = {
        total: 0,
        byType: new Map(),
        peakRate: 0,
        uniqueReactors: new Set(),
        timeline: []
      };
      this.reactionStats.set(streamId, stats);
    }
    
    stats.total++;
    stats.byType.set(reaction, (stats.byType.get(reaction) || 0) + 1);
    
    // Update timeline for peak rate calculation
    const now = Date.now();
    stats.timeline.push({ timestamp: now, reaction });
    
    // Remove old timeline entries (older than 1 minute)
    stats.timeline = stats.timeline.filter(
      e => e.timestamp > now - 60000
    );
    
    // Calculate current rate (reactions per second)
    const currentRate = stats.timeline.length / 60;
    stats.peakRate = Math.max(stats.peakRate, currentRate);
  }
}

// Reaction renderer for UI
export class ReactionRenderer {
  private activeAnimations = new Map<string, ReactionAnimation>();
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private animationFrame: number;
  
  constructor(
    container: HTMLElement,
    private style: 'bubble' | 'wave' | 'firework'
  ) {
    this.canvas = document.createElement('canvas');
    this.canvas.className = 'reaction-canvas';
    container.appendChild(this.canvas);
    
    this.ctx = this.canvas.getContext('2d')!;
    this.resizeCanvas();
    
    window.addEventListener('resize', () => this.resizeCanvas());
  }
  
  renderReactions(reactions: ReactionEvent[]) {
    for (const reaction of reactions) {
      const animation = this.createAnimation(reaction);
      this.activeAnimations.set(reaction.id, animation);
    }
    
    if (!this.animationFrame) {
      this.startAnimationLoop();
    }
  }
  
  private createAnimation(reaction: ReactionEvent): ReactionAnimation {
    switch (this.style) {
      case 'bubble':
        return new BubbleAnimation(reaction, this.canvas);
      case 'wave':
        return new WaveAnimation(reaction, this.canvas);
      case 'firework':
        return new FireworkAnimation(reaction, this.canvas);
      default:
        return new BubbleAnimation(reaction, this.canvas);
    }
  }
  
  private startAnimationLoop() {
    const animate = () => {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Update and render all animations
      for (const [id, animation] of this.activeAnimations) {
        animation.update();
        animation.render(this.ctx);
        
        // Remove completed animations
        if (animation.isComplete()) {
          this.activeAnimations.delete(id);
        }
      }
      
      // Continue loop if animations exist
      if (this.activeAnimations.size > 0) {
        this.animationFrame = requestAnimationFrame(animate);
      } else {
        this.animationFrame = 0;
      }
    };
    
    this.animationFrame = requestAnimationFrame(animate);
  }
  
  private resizeCanvas() {
    const rect = this.canvas.parentElement!.getBoundingClientRect();
    this.canvas.width = rect.width;
    this.canvas.height = rect.height;
  }
}
```

### 2. Interactive Polls System
```tsx
// Poll management and UI
export interface Poll {
  id: string;
  streamId: string;
  question: string;
  options: PollOption[];
  settings: {
    multipleChoice: boolean;
    showResults: 'live' | 'after' | 'never';
    duration: number; // seconds
    anonymous: boolean;
  };
  createdAt: number;
  endsAt: number;
  state: 'active' | 'ended';
  votes: Map<string, string[]>; // userId -> optionIds
}

export class PollManager {
  private activePolls = new Map<string, Poll>();
  private pollHistory = new Map<string, Poll[]>();
  
  constructor(
    private broadcaster: PollBroadcaster,
    private storage: PollStorage,
    private analytics: AnalyticsService
  ) {}
  
  async createPoll(
    streamId: string,
    pollData: CreatePollData
  ): Promise<Poll> {
    // Validate poll data
    if (pollData.options.length < 2 || pollData.options.length > 10) {
      throw new Error('Polls must have between 2 and 10 options');
    }
    
    const poll: Poll = {
      id: crypto.randomUUID(),
      streamId,
      question: pollData.question,
      options: pollData.options.map((text, index) => ({
        id: `option-${index}`,
        text,
        votes: 0,
        percentage: 0
      })),
      settings: {
        multipleChoice: pollData.multipleChoice || false,
        showResults: pollData.showResults || 'live',
        duration: pollData.duration || 60,
        anonymous: pollData.anonymous || false
      },
      createdAt: Date.now(),
      endsAt: Date.now() + (pollData.duration || 60) * 1000,
      state: 'active',
      votes: new Map()
    };
    
    // Store poll
    this.activePolls.set(poll.id, poll);
    
    // Schedule poll end
    setTimeout(() => this.endPoll(poll.id), poll.settings.duration * 1000);
    
    // Broadcast to viewers
    await this.broadcaster.broadcastPoll(streamId, poll);
    
    // Track analytics
    await this.analytics.track('poll_created', {
      pollId: poll.id,
      streamId,
      optionCount: poll.options.length,
      duration: poll.settings.duration
    });
    
    return poll;
  }
  
  async vote(
    pollId: string,
    userId: string,
    optionIds: string[]
  ): Promise<VoteResult> {
    const poll = this.activePolls.get(pollId);
    if (!poll) {
      throw new Error('Poll not found');
    }
    
    if (poll.state !== 'active') {
      throw new Error('Poll has ended');
    }
    
    if (Date.now() > poll.endsAt) {
      throw new Error('Poll has expired');
    }
    
    // Validate options
    if (!poll.settings.multipleChoice && optionIds.length > 1) {
      throw new Error('Only one option can be selected');
    }
    
    const validOptions = poll.options.map(o => o.id);
    if (!optionIds.every(id => validOptions.includes(id))) {
      throw new Error('Invalid option selected');
    }
    
    // Record vote
    poll.votes.set(userId, optionIds);
    
    // Update vote counts
    this.updateVoteCounts(poll);
    
    // Broadcast update if showing live results
    if (poll.settings.showResults === 'live') {
      await this.broadcaster.broadcastPollUpdate(poll.streamId, {
        pollId: poll.id,
        results: this.getResults(poll),
        totalVotes: poll.votes.size
      });
    }
    
    // Track vote
    await this.analytics.track('poll_vote', {
      pollId: poll.id,
      streamId: poll.streamId,
      userId: poll.settings.anonymous ? null : userId,
      optionCount: optionIds.length
    });
    
    return {
      success: true,
      message: 'Vote recorded',
      showResults: poll.settings.showResults === 'live'
    };
  }
  
  private updateVoteCounts(poll: Poll) {
    // Reset counts
    poll.options.forEach(option => {
      option.votes = 0;
    });
    
    // Count votes
    for (const optionIds of poll.votes.values()) {
      for (const optionId of optionIds) {
        const option = poll.options.find(o => o.id === optionId);
        if (option) {
          option.votes++;
        }
      }
    }
    
    // Calculate percentages
    const totalVotes = poll.votes.size;
    poll.options.forEach(option => {
      option.percentage = totalVotes > 0 
        ? (option.votes / totalVotes) * 100 
        : 0;
    });
  }
  
  async endPoll(pollId: string): Promise<void> {
    const poll = this.activePolls.get(pollId);
    if (!poll) return;
    
    poll.state = 'ended';
    
    // Move to history
    const history = this.pollHistory.get(poll.streamId) || [];
    history.push(poll);
    this.pollHistory.set(poll.streamId, history);
    
    // Remove from active
    this.activePolls.delete(pollId);
    
    // Broadcast final results
    await this.broadcaster.broadcastPollEnd(poll.streamId, {
      pollId: poll.id,
      results: this.getResults(poll),
      totalVotes: poll.votes.size
    });
    
    // Store results
    await this.storage.storePollResults(poll);
    
    // Track completion
    await this.analytics.track('poll_ended', {
      pollId: poll.id,
      streamId: poll.streamId,
      totalVotes: poll.votes.size,
      participationRate: this.calculateParticipationRate(poll)
    });
  }
  
  private getResults(poll: Poll): PollResults {
    return {
      options: poll.options.map(option => ({
        id: option.id,
        text: option.text,
        votes: option.votes,
        percentage: option.percentage
      })),
      totalVotes: poll.votes.size,
      topOption: this.getTopOption(poll)
    };
  }
}

// Poll UI Components
export function PollWidget({ 
  poll,
  onVote 
}: { 
  poll: Poll;
  onVote: (optionIds: string[]) => void;
}) {
  const [selected, setSelected] = useState<string[]>([]);
  const [voted, setVoted] = useState(false);
  const [timeLeft, setTimeLeft] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      const remaining = Math.max(0, poll.endsAt - Date.now());
      setTimeLeft(Math.floor(remaining / 1000));
      
      if (remaining === 0) {
        clearInterval(timer);
      }
    }, 1000);
    
    return () => clearInterval(timer);
  }, [poll.endsAt]);
  
  const handleOptionClick = (optionId: string) => {
    if (voted || poll.state === 'ended') return;
    
    if (poll.settings.multipleChoice) {
      setSelected(prev => 
        prev.includes(optionId)
          ? prev.filter(id => id !== optionId)
          : [...prev, optionId]
      );
    } else {
      setSelected([optionId]);
    }
  };
  
  const handleVote = async () => {
    if (selected.length === 0) return;
    
    try {
      await onVote(selected);
      setVoted(true);
    } catch (error) {
      toast.error('Failed to submit vote');
    }
  };
  
  const showResults = voted || 
    poll.state === 'ended' || 
    poll.settings.showResults === 'live';
  
  return (
    <div className="poll-widget">
      <div className="poll-header">
        <h4>{poll.question}</h4>
        {poll.state === 'active' && (
          <div className="poll-timer">
            <ClockIcon />
            <span>{formatTime(timeLeft)}</span>
          </div>
        )}
      </div>
      
      <div className="poll-options">
        {poll.options.map(option => (
          <PollOption
            key={option.id}
            option={option}
            selected={selected.includes(option.id)}
            showResults={showResults}
            voted={voted}
            onClick={() => handleOptionClick(option.id)}
          />
        ))}
      </div>
      
      {!voted && poll.state === 'active' && (
        <div className="poll-actions">
          <Button
            variant="primary"
            onClick={handleVote}
            disabled={selected.length === 0}
          >
            Vote
          </Button>
          {poll.settings.multipleChoice && (
            <p className="poll-hint">You can select multiple options</p>
          )}
        </div>
      )}
      
      {showResults && (
        <div className="poll-footer">
          <span className="total-votes">
            {poll.votes.size} {poll.votes.size === 1 ? 'vote' : 'votes'}
          </span>
        </div>
      )}
    </div>
  );
}

export function PollOption({
  option,
  selected,
  showResults,
  voted,
  onClick
}: {
  option: PollOption;
  selected: boolean;
  showResults: boolean;
  voted: boolean;
  onClick: () => void;
}) {
  return (
    <div
      className={`poll-option ${selected ? 'selected' : ''} ${voted ? 'voted' : ''}`}
      onClick={onClick}
    >
      <div className="option-content">
        <div className="option-selector">
          {selected && <CheckIcon />}
        </div>
        <span className="option-text">{option.text}</span>
        {showResults && (
          <span className="option-percentage">
            {option.percentage.toFixed(0)}%
          </span>
        )}
      </div>
      
      {showResults && (
        <div className="option-bar">
          <div
            className="option-fill"
            style={{ width: `${option.percentage}%` }}
          />
        </div>
      )}
    </div>
  );
}
```

### 3. Q&A and Hand Raising System
```typescript
// Q&A queue management
export interface Question {
  id: string;
  streamId: string;
  userId: string;
  userName: string;
  text: string;
  timestamp: number;
  upvotes: Set<string>;
  answered: boolean;
  featured: boolean;
}

export class QAManager {
  private questions = new Map<string, Question[]>();
  private handRaises = new Map<string, Set<string>>();
  private speakingQueue = new Map<string, string[]>();
  
  constructor(
    private broadcaster: QABroadcaster,
    private moderation: ModerationService,
    private analytics: AnalyticsService
  ) {}
  
  async submitQuestion(
    streamId: string,
    userId: string,
    text: string
  ): Promise<Question> {
    // Validate and moderate question
    const moderated = await this.moderation.moderateText(text);
    if (moderated.blocked) {
      throw new Error('Question contains inappropriate content');
    }
    
    const question: Question = {
      id: crypto.randomUUID(),
      streamId,
      userId,
      userName: await this.getUserName(userId),
      text: moderated.text,
      timestamp: Date.now(),
      upvotes: new Set(),
      answered: false,
      featured: false
    };
    
    // Add to queue
    const queue = this.questions.get(streamId) || [];
    queue.push(question);
    this.questions.set(streamId, queue);
    
    // Broadcast new question
    await this.broadcaster.broadcastNewQuestion(streamId, question);
    
    // Track submission
    await this.analytics.track('question_submitted', {
      streamId,
      questionId: question.id
    });
    
    return question;
  }
  
  async upvoteQuestion(
    questionId: string,
    userId: string
  ): Promise<void> {
    const question = this.findQuestion(questionId);
    if (!question) {
      throw new Error('Question not found');
    }
    
    // Toggle upvote
    if (question.upvotes.has(userId)) {
      question.upvotes.delete(userId);
    } else {
      question.upvotes.add(userId);
    }
    
    // Broadcast update
    await this.broadcaster.broadcastQuestionUpdate(
      question.streamId,
      question
    );
    
    // Re-sort queue by upvotes
    this.sortQuestionsByUpvotes(question.streamId);
  }
  
  async markAnswered(
    questionId: string,
    moderatorId: string
  ): Promise<void> {
    const question = this.findQuestion(questionId);
    if (!question) {
      throw new Error('Question not found');
    }
    
    question.answered = true;
    
    // Broadcast update
    await this.broadcaster.broadcastQuestionAnswered(
      question.streamId,
      question
    );
    
    // Track answer
    await this.analytics.track('question_answered', {
      streamId: question.streamId,
      questionId: question.id,
      moderatorId
    });
  }
  
  async raiseHand(
    streamId: string,
    userId: string
  ): Promise<void> {
    let raised = this.handRaises.get(streamId);
    if (!raised) {
      raised = new Set();
      this.handRaises.set(streamId, raised);
    }
    
    if (raised.has(userId)) {
      throw new Error('Hand already raised');
    }
    
    raised.add(userId);
    
    // Add to speaking queue
    const queue = this.speakingQueue.get(streamId) || [];
    queue.push(userId);
    this.speakingQueue.set(streamId, queue);
    
    // Broadcast hand raise
    await this.broadcaster.broadcastHandRaise(streamId, {
      userId,
      position: queue.length
    });
    
    // Track hand raise
    await this.analytics.track('hand_raised', {
      streamId,
      userId,
      queuePosition: queue.length
    });
  }
  
  async lowerHand(
    streamId: string,
    userId: string
  ): Promise<void> {
    const raised = this.handRaises.get(streamId);
    if (!raised || !raised.has(userId)) {
      return;
    }
    
    raised.delete(userId);
    
    // Remove from queue
    const queue = this.speakingQueue.get(streamId) || [];
    const index = queue.indexOf(userId);
    if (index > -1) {
      queue.splice(index, 1);
    }
    
    // Broadcast update
    await this.broadcaster.broadcastHandLower(streamId, userId);
  }
  
  async inviteToSpeak(
    streamId: string,
    userId: string,
    moderatorId: string
  ): Promise<void> {
    // Remove from queue
    await this.lowerHand(streamId, userId);
    
    // Send speaking invitation
    await this.broadcaster.sendSpeakingInvite(streamId, userId, {
      invitedBy: moderatorId,
      duration: 60 // seconds
    });
    
    // Track invitation
    await this.analytics.track('speaking_invite_sent', {
      streamId,
      userId,
      moderatorId
    });
  }
  
  private sortQuestionsByUpvotes(streamId: string) {
    const queue = this.questions.get(streamId);
    if (!queue) return;
    
    queue.sort((a, b) => {
      // Answered questions go to bottom
      if (a.answered && !b.answered) return 1;
      if (!a.answered && b.answered) return -1;
      
      // Sort by upvotes
      return b.upvotes.size - a.upvotes.size;
    });
  }
}
```

### 4. Audience Chat System
```tsx
// Stream chat with moderation
export function StreamChat({ 
  streamId 
}: { 
  streamId: string 
}) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [emotePickerOpen, setEmotePickerOpen] = useState(false);
  const [slowMode, setSlowMode] = useState(false);
  const [lastMessageTime, setLastMessageTime] = useState(0);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatClient = useRef<ChatClient>();
  
  useEffect(() => {
    initializeChat();
    
    return () => {
      chatClient.current?.disconnect();
    };
  }, [streamId]);
  
  const initializeChat = async () => {
    const client = new ChatClient({
      streamId,
      userId: getCurrentUserId(),
      onMessage: handleNewMessage,
      onModeration: handleModeration,
      onSlowMode: setSlowMode
    });
    
    await client.connect();
    chatClient.current = client;
    
    // Load recent messages
    const recent = await client.getRecentMessages();
    setMessages(recent);
  };
  
  const handleNewMessage = (message: ChatMessage) => {
    setMessages(prev => [...prev.slice(-99), message]); // Keep last 100
    scrollToBottom();
  };
  
  const handleModeration = (action: ModerationAction) => {
    switch (action.type) {
      case 'delete':
        setMessages(prev => prev.filter(m => m.id !== action.messageId));
        break;
      case 'timeout':
        if (action.userId === getCurrentUserId()) {
          toast.error(`You've been timed out for ${action.duration}s`);
        }
        break;
    }
  };
  
  const sendMessage = async () => {
    if (!input.trim()) return;
    
    // Check slow mode
    if (slowMode) {
      const timeSinceLast = Date.now() - lastMessageTime;
      const cooldown = 5000; // 5 seconds
      
      if (timeSinceLast < cooldown) {
        const remaining = Math.ceil((cooldown - timeSinceLast) / 1000);
        toast.error(`Slow mode: wait ${remaining}s`);
        return;
      }
    }
    
    try {
      await chatClient.current?.sendMessage(input);
      setInput('');
      setLastMessageTime(Date.now());
    } catch (error) {
      toast.error('Failed to send message');
    }
  };
  
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  
  return (
    <div className="stream-chat">
      <div className="chat-header">
        <h4>Stream Chat</h4>
        {slowMode && <Badge variant="warning">Slow Mode</Badge>}
      </div>
      
      <div className="chat-messages">
        {messages.map(message => (
          <ChatMessage
            key={message.id}
            message={message}
            onReport={(id) => reportMessage(id)}
          />
        ))}
        <div ref={messagesEndRef} />
      </div>
      
      <div className="chat-input-container">
        <div className="chat-input">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
            placeholder="Type a message..."
            maxLength={200}
          />
          
          <Button
            variant="ghost"
            size="small"
            onClick={() => setEmotePickerOpen(!emotePickerOpen)}
          >
            <EmoteIcon />
          </Button>
          
          <Button
            variant="primary"
            size="small"
            onClick={sendMessage}
            disabled={!input.trim()}
          >
            Send
          </Button>
        </div>
        
        {emotePickerOpen && (
          <EmotePicker
            onSelect={(emote) => {
              setInput(prev => prev + emote);
              setEmotePickerOpen(false);
            }}
          />
        )}
      </div>
    </div>
  );
}

export function ChatMessage({
  message,
  onReport
}: {
  message: ChatMessage;
  onReport: (id: string) => void;
}) {
  const [showActions, setShowActions] = useState(false);
  
  return (
    <div 
      className="chat-message"
      onMouseEnter={() => setShowActions(true)}
      onMouseLeave={() => setShowActions(false)}
    >
      <div className="message-header">
        <span 
          className="message-author"
          style={{ color: message.userColor }}
        >
          {message.userName}
        </span>
        
        {message.badges.map(badge => (
          <ChatBadge key={badge} type={badge} />
        ))}
        
        <span className="message-time">
          {formatTime(message.timestamp)}
        </span>
      </div>
      
      <div className="message-content">
        {parseMessageContent(message.text)}
      </div>
      
      {showActions && (
        <div className="message-actions">
          <Button
            variant="ghost"
            size="tiny"
            onClick={() => onReport(message.id)}
          >
            <FlagIcon />
          </Button>
        </div>
      )}
    </div>
  );
}
```

### 5. Viewer Rewards and Gamification
```typescript
// Viewer rewards system
export interface ViewerRewards {
  points: number;
  level: number;
  badges: Badge[];
  watchTime: number;
  engagement: {
    messages: number;
    reactions: number;
    polls: number;
    questions: number;
  };
}

export class RewardsManager {
  private userRewards = new Map<string, ViewerRewards>();
  private achievementEngine: AchievementEngine;
  
  constructor(
    private storage: RewardsStorage,
    private notifications: NotificationService
  ) {
    this.achievementEngine = new AchievementEngine();
  }
  
  async trackActivity(
    userId: string,
    streamId: string,
    activity: ViewerActivity
  ): Promise<RewardUpdate> {
    let rewards = await this.getUserRewards(userId);
    let pointsEarned = 0;
    const newBadges: Badge[] = [];
    
    switch (activity.type) {
      case 'watch_time':
        // 1 point per minute watched
        const minutes = Math.floor(activity.duration / 60000);
        pointsEarned = minutes;
        rewards.watchTime += activity.duration;
        break;
        
      case 'chat_message':
        // 5 points per message (with cooldown)
        if (this.canEarnChatPoints(userId)) {
          pointsEarned = 5;
          rewards.engagement.messages++;
        }
        break;
        
      case 'reaction':
        // 2 points per reaction
        pointsEarned = 2;
        rewards.engagement.reactions++;
        break;
        
      case 'poll_vote':
        // 10 points for participating in poll
        pointsEarned = 10;
        rewards.engagement.polls++;
        break;
        
      case 'question_submit':
        // 15 points for asking a question
        pointsEarned = 15;
        rewards.engagement.questions++;
        break;
        
      case 'question_upvote':
        // 3 points for upvoting
        pointsEarned = 3;
        break;
    }
    
    // Update points
    rewards.points += pointsEarned;
    
    // Check for level up
    const newLevel = this.calculateLevel(rewards.points);
    if (newLevel > rewards.level) {
      rewards.level = newLevel;
      await this.handleLevelUp(userId, newLevel);
    }
    
    // Check for new badges
    const earnedBadges = await this.achievementEngine.checkAchievements(
      userId,
      rewards,
      activity
    );
    
    if (earnedBadges.length > 0) {
      rewards.badges.push(...earnedBadges);
      newBadges.push(...earnedBadges);
      
      // Notify user
      for (const badge of earnedBadges) {
        await this.notifications.notify(userId, {
          type: 'badge_earned',
          title: 'New Badge Earned!',
          description: `You've earned the ${badge.name} badge!`,
          icon: badge.icon
        });
      }
    }
    
    // Save rewards
    await this.storage.saveUserRewards(userId, rewards);
    
    return {
      pointsEarned,
      totalPoints: rewards.points,
      level: rewards.level,
      newBadges
    };
  }
  
  private calculateLevel(points: number): number {
    // Level formula: level = floor(sqrt(points / 100))
    return Math.floor(Math.sqrt(points / 100));
  }
  
  private async handleLevelUp(userId: string, level: number) {
    await this.notifications.notify(userId, {
      type: 'level_up',
      title: 'Level Up!',
      description: `Congratulations! You've reached level ${level}!`,
      icon: 'ðŸŽ‰'
    });
    
    // Unlock level-based perks
    const perks = this.getLevelPerks(level);
    if (perks.length > 0) {
      await this.unlockPerks(userId, perks);
    }
  }
  
  private getLevelPerks(level: number): Perk[] {
    const perks: Perk[] = [];
    
    if (level >= 5) {
      perks.push({ id: 'custom_emotes', name: 'Custom Emotes' });
    }
    if (level >= 10) {
      perks.push({ id: 'vip_badge', name: 'VIP Badge' });
    }
    if (level >= 20) {
      perks.push({ id: 'priority_questions', name: 'Priority Q&A' });
    }
    
    return perks;
  }
}

// Achievement definitions
export class AchievementEngine {
  private achievements: Achievement[] = [
    {
      id: 'first_message',
      name: 'First Words',
      description: 'Send your first chat message',
      icon: 'ðŸ’¬',
      condition: (rewards) => rewards.engagement.messages >= 1
    },
    {
      id: 'active_chatter',
      name: 'Active Chatter',
      description: 'Send 100 chat messages',
      icon: 'ðŸ—£ï¸',
      condition: (rewards) => rewards.engagement.messages >= 100
    },
    {
      id: 'poll_participant',
      name: 'Voice Your Opinion',
      description: 'Vote in 10 polls',
      icon: 'ðŸ“Š',
      condition: (rewards) => rewards.engagement.polls >= 10
    },
    {
      id: 'curious_mind',
      name: 'Curious Mind',
      description: 'Ask 5 questions',
      icon: 'â“',
      condition: (rewards) => rewards.engagement.questions >= 5
    },
    {
      id: 'loyal_viewer',
      name: 'Loyal Viewer',
      description: 'Watch for 10 hours total',
      icon: 'ðŸ‘ï¸',
      condition: (rewards) => rewards.watchTime >= 36000000 // 10 hours
    },
    {
      id: 'reaction_master',
      name: 'Reaction Master',
      description: 'Send 500 reactions',
      icon: 'ðŸ˜„',
      condition: (rewards) => rewards.engagement.reactions >= 500
    }
  ];
  
  async checkAchievements(
    userId: string,
    rewards: ViewerRewards,
    activity: ViewerActivity
  ): Promise<Badge[]> {
    const newBadges: Badge[] = [];
    
    for (const achievement of this.achievements) {
      // Skip if already earned
      if (rewards.badges.some(b => b.id === achievement.id)) {
        continue;
      }
      
      // Check if condition is met
      if (achievement.condition(rewards, activity)) {
        newBadges.push({
          id: achievement.id,
          name: achievement.name,
          description: achievement.description,
          icon: achievement.icon,
          earnedAt: Date.now()
        });
      }
    }
    
    return newBadges;
  }
}
```

### 6. Audience Analytics
```typescript
// Audience behavior analytics
export class AudienceAnalytics {
  private sessionData = new Map<string, AudienceSession>();
  
  constructor(
    private analytics: AnalyticsService,
    private storage: AnalyticsStorage
  ) {}
  
  async trackAudienceEvent(
    streamId: string,
    userId: string,
    event: AudienceEvent
  ) {
    let session = this.sessionData.get(`${streamId}:${userId}`);
    
    if (!session) {
      session = {
        streamId,
        userId,
        startTime: Date.now(),
        events: [],
        engagement: {
          reactions: 0,
          messages: 0,
          polls: 0,
          questions: 0,
          watchTime: 0
        }
      };
      this.sessionData.set(`${streamId}:${userId}`, session);
    }
    
    // Record event
    session.events.push({
      type: event.type,
      timestamp: Date.now(),
      data: event.data
    });
    
    // Update engagement metrics
    switch (event.type) {
      case 'reaction_sent':
        session.engagement.reactions++;
        break;
      case 'message_sent':
        session.engagement.messages++;
        break;
      case 'poll_voted':
        session.engagement.polls++;
        break;
      case 'question_asked':
        session.engagement.questions++;
        break;
    }
    
    // Track in analytics
    await this.analytics.track('audience_event', {
      streamId,
      userId,
      eventType: event.type,
      ...event.data
    });
  }
  
  async generateAudienceReport(
    streamId: string
  ): Promise<AudienceReport> {
    const sessions = Array.from(this.sessionData.entries())
      .filter(([key]) => key.startsWith(streamId))
      .map(([, session]) => session);
    
    const report: AudienceReport = {
      totalViewers: sessions.length,
      engagement: {
        averageWatchTime: this.calculateAverageWatchTime(sessions),
        totalReactions: sessions.reduce((sum, s) => sum + s.engagement.reactions, 0),
        totalMessages: sessions.reduce((sum, s) => sum + s.engagement.messages, 0),
        totalPollVotes: sessions.reduce((sum, s) => sum + s.engagement.polls, 0),
        totalQuestions: sessions.reduce((sum, s) => sum + s.engagement.questions, 0),
        engagementRate: this.calculateEngagementRate(sessions)
      },
      participation: {
        activeParticipants: sessions.filter(s => 
          s.engagement.reactions > 0 || 
          s.engagement.messages > 0 ||
          s.engagement.polls > 0 ||
          s.engagement.questions > 0
        ).length,
        topContributors: this.getTopContributors(sessions),
        participationTimeline: this.generateParticipationTimeline(sessions)
      },
      sentiment: await this.analyzeSentiment(sessions)
    };
    
    return report;
  }
  
  private calculateEngagementRate(sessions: AudienceSession[]): number {
    const totalEvents = sessions.reduce((sum, s) => 
      sum + s.engagement.reactions + 
      s.engagement.messages + 
      s.engagement.polls + 
      s.engagement.questions, 0
    );
    
    const totalMinutes = sessions.reduce((sum, s) => 
      sum + (s.engagement.watchTime / 60000), 0
    );
    
    return totalMinutes > 0 ? totalEvents / totalMinutes : 0;
  }
  
  private async analyzeSentiment(
    sessions: AudienceSession[]
  ): Promise<SentimentAnalysis> {
    // Collect all messages and reactions
    const messages: string[] = [];
    const reactions: string[] = [];
    
    for (const session of sessions) {
      for (const event of session.events) {
        if (event.type === 'message_sent' && event.data.text) {
          messages.push(event.data.text);
        } else if (event.type === 'reaction_sent' && event.data.reaction) {
          reactions.push(event.data.reaction);
        }
      }
    }
    
    // Analyze sentiment
    const messageSentiment = await this.analyzeTextSentiment(messages);
    const reactionSentiment = this.analyzeReactionSentiment(reactions);
    
    return {
      overall: (messageSentiment.score + reactionSentiment.score) / 2,
      messages: messageSentiment,
      reactions: reactionSentiment,
      trend: this.calculateSentimentTrend(sessions)
    };
  }
}
```

## Dependencies
- Real-time messaging infrastructure
- Animation rendering system
- Moderation service
- Analytics platform
- Achievement/gamification engine
- Storage for user rewards

## Estimated Effort
**6 days**
- 1 day: Reaction system and animations
- 1 day: Interactive polls
- 1 day: Q&A and hand raising
- 1 day: Chat system with moderation
- 1 day: Rewards and gamification
- 1 day: Analytics and reporting

## Notes
- Ensure real-time synchronization
- Implement rate limiting for spam prevention
- Add accessibility features
- Consider mobile experience
- Support custom emotes/reactions
- Enable audience replay features
- Plan for large audience scaling