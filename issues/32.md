# Issue #32: Push Notifications

## User Story
As a **waddle member**, I want to **receive push notifications for important messages and events** so that **I stay connected with my community even when not actively using the app**.

## Description
Implement push notification system using Firebase Cloud Messaging (FCM) to deliver real-time notifications across web, iOS, and Android platforms. This includes message notifications, @mentions, voice channel invites, and community updates with granular preference controls.

## Acceptance Criteria
- [ ] FCM integration for all platforms
- [ ] Notification preferences per waddle
- [ ] Message notifications with preview
- [ ] @mention notifications
- [ ] Voice channel invite notifications
- [ ] Notification grouping and stacking
- [ ] Do Not Disturb scheduling
- [ ] Notification sound customization
- [ ] Badge count management
- [ ] Notification history

## Technical Implementation

### 1. FCM Setup and Configuration
```typescript
// FCM Service Configuration
export interface FCMConfig {
  projectId: string;
  apiKey: string;
  messagingSenderId: string;
  appId: string;
  vapidKey: string; // For web push
  serviceAccount: ServiceAccount; // For server SDK
}

// Notification Types
export enum NotificationType {
  MESSAGE = 'message',
  MENTION = 'mention',
  REPLY = 'reply',
  VOICE_INVITE = 'voice_invite',
  WADDLE_UPDATE = 'waddle_update',
  FRIEND_REQUEST = 'friend_request',
  SYSTEM = 'system'
}

export interface PushNotification {
  id: string;
  type: NotificationType;
  title: string;
  body: string;
  data: Record<string, any>;
  icon?: string;
  image?: string;
  badge?: number;
  sound?: string;
  priority: 'high' | 'normal';
  ttl?: number;
  collapseKey?: string;
  channelId?: string; // Android notification channels
}

// FCM Service
export class FCMService {
  private messaging: Messaging;
  private admin: FirebaseAdmin;
  
  constructor(
    private config: FCMConfig,
    private env: Env
  ) {
    this.initializeFirebase();
  }
  
  private initializeFirebase() {
    // Initialize Firebase Admin SDK
    this.admin = initializeApp({
      credential: cert(this.config.serviceAccount),
      projectId: this.config.projectId
    });
    
    this.messaging = getMessaging(this.admin);
  }
  
  async sendNotification(
    userId: string,
    notification: PushNotification
  ): Promise<void> {
    // Get user's FCM tokens
    const tokens = await this.getUserTokens(userId);
    if (tokens.length === 0) return;
    
    // Check user preferences
    const preferences = await this.getUserNotificationPreferences(userId);
    if (!this.shouldSendNotification(notification, preferences)) {
      return;
    }
    
    // Build FCM message
    const message: MulticastMessage = {
      tokens,
      notification: {
        title: notification.title,
        body: notification.body,
        imageUrl: notification.image
      },
      data: {
        ...notification.data,
        notificationId: notification.id,
        type: notification.type,
        timestamp: Date.now().toString()
      },
      android: {
        priority: notification.priority,
        ttl: notification.ttl || 86400, // 24 hours default
        collapseKey: notification.collapseKey,
        notification: {
          icon: notification.icon || 'ic_notification',
          sound: notification.sound || 'default',
          channelId: notification.channelId || this.getChannelForType(notification.type),
          tag: notification.collapseKey
        }
      },
      apns: {
        payload: {
          aps: {
            alert: {
              title: notification.title,
              body: notification.body
            },
            badge: notification.badge,
            sound: notification.sound || 'default.caf',
            threadId: notification.data.waddleId || notification.data.channelId,
            mutableContent: true,
            contentAvailable: true
          }
        },
        headers: {
          'apns-priority': notification.priority === 'high' ? '10' : '5',
          'apns-expiration': Math.floor(Date.now() / 1000 + (notification.ttl || 86400)).toString()
        }
      },
      webpush: {
        headers: {
          TTL: (notification.ttl || 86400).toString(),
          Urgency: notification.priority
        },
        notification: {
          icon: notification.icon || '/icon-192.png',
          badge: '/badge-72.png',
          vibrate: [200, 100, 200],
          requireInteraction: notification.priority === 'high',
          actions: this.getActionsForType(notification.type),
          tag: notification.collapseKey,
          renotify: true
        },
        fcmOptions: {
          link: this.getDeepLink(notification)
        }
      }
    };
    
    // Send notification
    const response = await this.messaging.sendMulticast(message);
    
    // Handle failed tokens
    if (response.failureCount > 0) {
      const failedTokens: string[] = [];
      response.responses.forEach((resp, idx) => {
        if (!resp.success) {
          failedTokens.push(tokens[idx]);
        }
      });
      
      await this.handleFailedTokens(userId, failedTokens);
    }
    
    // Track notification
    await this.trackNotification(userId, notification, response);
  }
  
  async sendBatchNotifications(
    notifications: Array<{ userId: string; notification: PushNotification }>
  ): Promise<void> {
    // Group by notification content for multicast
    const groups = new Map<string, { notification: PushNotification; userIds: string[] }>();
    
    for (const { userId, notification } of notifications) {
      const key = JSON.stringify({
        title: notification.title,
        body: notification.body,
        type: notification.type
      });
      
      if (!groups.has(key)) {
        groups.set(key, { notification, userIds: [] });
      }
      groups.get(key)!.userIds.push(userId);
    }
    
    // Send each group
    const promises = Array.from(groups.values()).map(async ({ notification, userIds }) => {
      // Collect all tokens
      const allTokens: string[] = [];
      const tokenToUser = new Map<string, string>();
      
      for (const userId of userIds) {
        const tokens = await this.getUserTokens(userId);
        for (const token of tokens) {
          allTokens.push(token);
          tokenToUser.set(token, userId);
        }
      }
      
      if (allTokens.length === 0) return;
      
      // Send multicast
      const response = await this.messaging.sendMulticast({
        tokens: allTokens,
        notification: {
          title: notification.title,
          body: notification.body
        },
        data: notification.data
      });
      
      // Handle responses
      response.responses.forEach((resp, idx) => {
        if (!resp.success) {
          const userId = tokenToUser.get(allTokens[idx]);
          if (userId) {
            this.handleFailedTokens(userId, [allTokens[idx]]);
          }
        }
      });
    });
    
    await Promise.all(promises);
  }
  
  private getActionsForType(type: NotificationType): NotificationAction[] {
    switch (type) {
      case NotificationType.MESSAGE:
        return [
          { action: 'reply', title: 'Reply', type: 'text', placeholder: 'Type a message...' },
          { action: 'mark-read', title: 'Mark as Read' }
        ];
      case NotificationType.VOICE_INVITE:
        return [
          { action: 'join', title: 'Join' },
          { action: 'decline', title: 'Decline' }
        ];
      case NotificationType.FRIEND_REQUEST:
        return [
          { action: 'accept', title: 'Accept' },
          { action: 'ignore', title: 'Ignore' }
        ];
      default:
        return [];
    }
  }
  
  private getDeepLink(notification: PushNotification): string {
    const baseUrl = 'https://waddle.chat';
    
    switch (notification.type) {
      case NotificationType.MESSAGE:
        return `${baseUrl}/waddle/${notification.data.waddleId}/channel/${notification.data.channelId}`;
      case NotificationType.VOICE_INVITE:
        return `${baseUrl}/waddle/${notification.data.waddleId}/voice/${notification.data.channelId}`;
      case NotificationType.FRIEND_REQUEST:
        return `${baseUrl}/friends/pending`;
      default:
        return baseUrl;
    }
  }
}
```

### 2. Notification Preferences Management
```typescript
// User Notification Preferences
export interface NotificationPreferences {
  userId: string;
  global: {
    enabled: boolean;
    doNotDisturb: {
      enabled: boolean;
      schedule?: {
        start: string; // "22:00"
        end: string;   // "08:00"
        timezone: string;
      };
    };
    sound: boolean;
    vibration: boolean;
    preview: boolean;
  };
  waddles: Record<string, WaddleNotificationPreferences>;
  types: Record<NotificationType, boolean>;
}

export interface WaddleNotificationPreferences {
  enabled: boolean;
  muteUntil?: number; // Timestamp
  channels: Record<string, ChannelNotificationPreferences>;
  mentions: 'all' | 'direct' | 'none';
  replies: boolean;
  voiceInvites: boolean;
}

export interface ChannelNotificationPreferences {
  enabled: boolean;
  mentions: boolean;
}

// Preferences Service
export class NotificationPreferencesService {
  constructor(
    private db: D1Database,
    private cache: KVNamespace
  ) {}
  
  async getUserPreferences(userId: string): Promise<NotificationPreferences> {
    // Check cache first
    const cached = await this.cache.get(`preferences:${userId}`);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Load from database
    const result = await this.db
      .prepare('SELECT * FROM notification_preferences WHERE user_id = ?')
      .bind(userId)
      .first();
      
    if (!result) {
      // Return defaults
      return this.getDefaultPreferences(userId);
    }
    
    const preferences = JSON.parse(result.preferences);
    
    // Cache for 1 hour
    await this.cache.put(
      `preferences:${userId}`,
      JSON.stringify(preferences),
      { expirationTtl: 3600 }
    );
    
    return preferences;
  }
  
  async updatePreferences(
    userId: string,
    updates: Partial<NotificationPreferences>
  ): Promise<void> {
    const current = await this.getUserPreferences(userId);
    const updated = this.mergePreferences(current, updates);
    
    // Save to database
    await this.db
      .prepare(`
        INSERT INTO notification_preferences (user_id, preferences, updated_at)
        VALUES (?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
          preferences = excluded.preferences,
          updated_at = excluded.updated_at
      `)
      .bind(userId, JSON.stringify(updated), new Date().toISOString())
      .run();
      
    // Invalidate cache
    await this.cache.delete(`preferences:${userId}`);
    
    // Emit preference update event
    await this.emitPreferenceUpdate(userId, updated);
  }
  
  async shouldNotify(
    userId: string,
    notification: PushNotification
  ): Promise<boolean> {
    const preferences = await this.getUserPreferences(userId);
    
    // Global enabled check
    if (!preferences.global.enabled) return false;
    
    // Do Not Disturb check
    if (this.isInDoNotDisturb(preferences.global.doNotDisturb)) {
      return false;
    }
    
    // Type preference check
    if (!preferences.types[notification.type]) return false;
    
    // Waddle-specific check
    if (notification.data.waddleId) {
      const waddlePrefs = preferences.waddles[notification.data.waddleId];
      if (!waddlePrefs?.enabled) return false;
      
      // Check mute
      if (waddlePrefs.muteUntil && Date.now() < waddlePrefs.muteUntil) {
        return false;
      }
      
      // Channel-specific check
      if (notification.data.channelId) {
        const channelPrefs = waddlePrefs.channels[notification.data.channelId];
        if (channelPrefs && !channelPrefs.enabled) return false;
      }
      
      // Mention preferences
      if (notification.type === NotificationType.MENTION) {
        if (waddlePrefs.mentions === 'none') return false;
        if (waddlePrefs.mentions === 'direct' && !notification.data.isDirect) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  private isInDoNotDisturb(dnd: NotificationPreferences['global']['doNotDisturb']): boolean {
    if (!dnd.enabled || !dnd.schedule) return false;
    
    const now = new Date();
    const timezone = dnd.schedule.timezone || 'UTC';
    const currentTime = new Intl.DateTimeFormat('en-US', {
      timeZone: timezone,
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    }).format(now);
    
    const start = dnd.schedule.start;
    const end = dnd.schedule.end;
    
    // Handle overnight schedules
    if (start > end) {
      return currentTime >= start || currentTime < end;
    } else {
      return currentTime >= start && currentTime < end;
    }
  }
}
```

### 3. Token Management
```typescript
// FCM Token Manager
export class FCMTokenManager {
  constructor(
    private db: D1Database,
    private cache: KVNamespace
  ) {}
  
  async registerToken(
    userId: string,
    token: string,
    platform: 'web' | 'ios' | 'android',
    deviceInfo?: DeviceInfo
  ): Promise<void> {
    // Validate token
    if (!this.isValidToken(token)) {
      throw new Error('Invalid FCM token');
    }
    
    // Store token
    await this.db
      .prepare(`
        INSERT INTO fcm_tokens (user_id, token, platform, device_info, created_at, last_used_at)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(token) DO UPDATE SET
          user_id = excluded.user_id,
          platform = excluded.platform,
          device_info = excluded.device_info,
          last_used_at = excluded.last_used_at
      `)
      .bind(
        userId,
        token,
        platform,
        JSON.stringify(deviceInfo || {}),
        new Date().toISOString(),
        new Date().toISOString()
      )
      .run();
      
    // Invalidate cache
    await this.cache.delete(`tokens:${userId}`);
    
    // Send test notification
    await this.sendWelcomeNotification(userId, token);
  }
  
  async removeToken(token: string): Promise<void> {
    const result = await this.db
      .prepare('DELETE FROM fcm_tokens WHERE token = ? RETURNING user_id')
      .bind(token)
      .first();
      
    if (result) {
      await this.cache.delete(`tokens:${result.user_id}`);
    }
  }
  
  async getUserTokens(userId: string): Promise<string[]> {
    // Check cache
    const cached = await this.cache.get(`tokens:${userId}`);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Query database
    const results = await this.db
      .prepare(`
        SELECT token FROM fcm_tokens 
        WHERE user_id = ? 
        AND last_used_at > datetime('now', '-30 days')
        ORDER BY last_used_at DESC
      `)
      .bind(userId)
      .all();
      
    const tokens = results.results.map(r => r.token as string);
    
    // Cache for 5 minutes
    await this.cache.put(
      `tokens:${userId}`,
      JSON.stringify(tokens),
      { expirationTtl: 300 }
    );
    
    return tokens;
  }
  
  async handleFailedTokens(userId: string, tokens: string[]): Promise<void> {
    // Remove invalid tokens
    for (const token of tokens) {
      await this.removeToken(token);
    }
    
    // Check if user has any remaining tokens
    const remainingTokens = await this.getUserTokens(userId);
    if (remainingTokens.length === 0) {
      // Mark user as having no push capability
      await this.markUserNoPush(userId);
    }
  }
  
  async refreshToken(oldToken: string, newToken: string): Promise<void> {
    await this.db
      .prepare(`
        UPDATE fcm_tokens 
        SET token = ?, last_used_at = ?
        WHERE token = ?
      `)
      .bind(newToken, new Date().toISOString(), oldToken)
      .run();
  }
  
  private isValidToken(token: string): boolean {
    // Basic validation
    return token.length > 0 && token.length < 256 && /^[a-zA-Z0-9\-_:]+$/.test(token);
  }
}
```

### 4. Client-Side Implementation
```typescript
// Web Push Implementation
export class WebPushManager {
  private messaging: Messaging;
  private registration?: ServiceWorkerRegistration;
  
  constructor(
    private api: WaddleAPI,
    private store: Store
  ) {}
  
  async initialize() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
      console.warn('Push notifications not supported');
      return;
    }
    
    // Register service worker
    this.registration = await navigator.serviceWorker.register('/sw.js');
    
    // Initialize Firebase Messaging
    const app = initializeApp(firebaseConfig);
    this.messaging = getMessaging(app);
    
    // Handle token refresh
    onTokenRefresh(this.messaging, async () => {
      const token = await getToken(this.messaging);
      if (token) {
        await this.updateToken(token);
      }
    });
    
    // Handle foreground messages
    onMessage(this.messaging, (payload) => {
      this.handleForegroundMessage(payload);
    });
    
    // Check permission and get token
    await this.checkPermissionAndGetToken();
  }
  
  async requestPermission(): Promise<boolean> {
    try {
      const permission = await Notification.requestPermission();
      
      if (permission === 'granted') {
        const token = await this.getToken();
        if (token) {
          await this.registerToken(token);
          return true;
        }
      }
      
      return false;
    } catch (error) {
      console.error('Failed to request permission:', error);
      return false;
    }
  }
  
  private async getToken(): Promise<string | null> {
    try {
      const token = await getToken(this.messaging, {
        vapidKey: VAPID_KEY,
        serviceWorkerRegistration: this.registration
      });
      
      return token;
    } catch (error) {
      console.error('Failed to get FCM token:', error);
      return null;
    }
  }
  
  private async registerToken(token: string) {
    await this.api.registerFCMToken({
      token,
      platform: 'web',
      deviceInfo: {
        userAgent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform
      }
    });
    
    this.store.dispatch(setPushToken(token));
  }
  
  private handleForegroundMessage(payload: any) {
    // Don't show notification if app is focused
    if (document.hasFocus()) {
      // Update UI directly
      this.store.dispatch(handleNotification(payload));
      return;
    }
    
    // Show notification
    if (this.registration) {
      this.registration.showNotification(payload.notification.title, {
        body: payload.notification.body,
        icon: payload.notification.icon,
        badge: '/badge-72.png',
        data: payload.data,
        tag: payload.data.notificationId,
        requireInteraction: false,
        actions: this.getActionsForType(payload.data.type)
      });
    }
  }
}

// Service Worker (sw.js)
importScripts('https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/9.0.0/firebase-messaging-compat.js');

firebase.initializeApp(firebaseConfig);

const messaging = firebase.messaging();

// Background message handler
messaging.onBackgroundMessage((payload) => {
  console.log('Received background message:', payload);
  
  const { title, body, icon, image } = payload.notification;
  const { notificationId, type, ...data } = payload.data;
  
  const notificationOptions = {
    body,
    icon: icon || '/icon-192.png',
    badge: '/badge-72.png',
    image,
    data,
    tag: notificationId,
    requireInteraction: type === 'voice_invite',
    actions: getActionsForType(type),
    vibrate: [200, 100, 200],
    renotify: true
  };
  
  return self.registration.showNotification(title, notificationOptions);
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  const { action } = event;
  const { type, waddleId, channelId } = event.notification.data;
  
  if (action === 'reply') {
    // Handle inline reply
    event.waitUntil(handleInlineReply(event));
  } else if (action === 'join') {
    // Open voice channel
    event.waitUntil(
      clients.openWindow(`/waddle/${waddleId}/voice/${channelId}`)
    );
  } else {
    // Default click - open relevant page
    const url = getUrlForNotificationType(type, event.notification.data);
    event.waitUntil(clients.openWindow(url));
  }
});

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  // Track notification dismissal
  trackNotificationEvent('dismissed', event.notification.data);
});
```

### 5. Notification UI Components
```tsx
// Notification Settings Component
export function NotificationSettings({ userId }: { userId: string }) {
  const [preferences, setPreferences] = useState<NotificationPreferences>();
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  
  useEffect(() => {
    loadPreferences();
  }, [userId]);
  
  const loadPreferences = async () => {
    try {
      const prefs = await api.getNotificationPreferences();
      setPreferences(prefs);
    } finally {
      setLoading(false);
    }
  };
  
  const updatePreference = async (path: string, value: any) => {
    if (!preferences) return;
    
    const updated = { ...preferences };
    setNestedValue(updated, path, value);
    setPreferences(updated);
    
    // Debounced save
    debouncedSave(updated);
  };
  
  const debouncedSave = useMemo(
    () => debounce(async (prefs: NotificationPreferences) => {
      setSaving(true);
      try {
        await api.updateNotificationPreferences(prefs);
        toast.success('Notification preferences updated');
      } catch (error) {
        toast.error('Failed to save preferences');
      } finally {
        setSaving(false);
      }
    }, 1000),
    []
  );
  
  const requestPermission = async () => {
    const granted = await pushManager.requestPermission();
    if (granted) {
      toast.success('Push notifications enabled');
      await loadPreferences();
    } else {
      toast.error('Push notification permission denied');
    }
  };
  
  if (loading) return <LoadingSpinner />;
  if (!preferences) return null;
  
  return (
    <div className="notification-settings">
      <div className="settings-section">
        <h3>Push Notifications</h3>
        
        {!preferences.global.enabled && (
          <Alert>
            <p>Enable push notifications to stay connected</p>
            <Button onClick={requestPermission}>Enable Notifications</Button>
          </Alert>
        )}
        
        <Toggle
          label="Enable push notifications"
          checked={preferences.global.enabled}
          onChange={(v) => updatePreference('global.enabled', v)}
          disabled={!hasPermission}
        />
        
        <Toggle
          label="Show message preview"
          checked={preferences.global.preview}
          onChange={(v) => updatePreference('global.preview', v)}
          disabled={!preferences.global.enabled}
        />
        
        <Toggle
          label="Play notification sound"
          checked={preferences.global.sound}
          onChange={(v) => updatePreference('global.sound', v)}
          disabled={!preferences.global.enabled}
        />
      </div>
      
      <div className="settings-section">
        <h3>Do Not Disturb</h3>
        
        <Toggle
          label="Enable Do Not Disturb"
          checked={preferences.global.doNotDisturb.enabled}
          onChange={(v) => updatePreference('global.doNotDisturb.enabled', v)}
        />
        
        {preferences.global.doNotDisturb.enabled && (
          <DoNotDisturbSchedule
            schedule={preferences.global.doNotDisturb.schedule}
            onChange={(schedule) => updatePreference('global.doNotDisturb.schedule', schedule)}
          />
        )}
      </div>
      
      <div className="settings-section">
        <h3>Notification Types</h3>
        
        {Object.entries(preferences.types).map(([type, enabled]) => (
          <Toggle
            key={type}
            label={getNotificationTypeLabel(type as NotificationType)}
            checked={enabled}
            onChange={(v) => updatePreference(`types.${type}`, v)}
          />
        ))}
      </div>
      
      <div className="settings-section">
        <h3>Waddle Notifications</h3>
        
        <WaddleNotificationList
          waddles={preferences.waddles}
          onChange={(waddleId, prefs) => 
            updatePreference(`waddles.${waddleId}`, prefs)
          }
        />
      </div>
      
      {saving && <SavingIndicator />}
    </div>
  );
}

// Notification Center Component
export function NotificationCenter() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [filter, setFilter] = useState<NotificationType | 'all'>('all');
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    loadNotifications();
    subscribeToNotifications();
  }, []);
  
  const loadNotifications = async () => {
    try {
      const data = await api.getNotificationHistory();
      setNotifications(data);
    } finally {
      setLoading(false);
    }
  };
  
  const subscribeToNotifications = () => {
    return api.subscribeToNotifications((notification) => {
      setNotifications(prev => [notification, ...prev]);
      
      // Update badge count
      updateBadgeCount();
    });
  };
  
  const markAsRead = async (notificationId: string) => {
    await api.markNotificationAsRead(notificationId);
    setNotifications(prev =>
      prev.map(n => n.id === notificationId ? { ...n, read: true } : n)
    );
  };
  
  const markAllAsRead = async () => {
    await api.markAllNotificationsAsRead();
    setNotifications(prev => prev.map(n => ({ ...n, read: true })));
  };
  
  const clearNotification = async (notificationId: string) => {
    await api.clearNotification(notificationId);
    setNotifications(prev => prev.filter(n => n.id !== notificationId));
  };
  
  const filteredNotifications = filter === 'all' 
    ? notifications 
    : notifications.filter(n => n.type === filter);
  
  return (
    <div className="notification-center">
      <div className="notification-header">
        <h2>Notifications</h2>
        <div className="notification-actions">
          <Button variant="text" onClick={markAllAsRead}>
            Mark all as read
          </Button>
        </div>
      </div>
      
      <NotificationFilter
        value={filter}
        onChange={setFilter}
        counts={getNotificationCounts(notifications)}
      />
      
      {loading ? (
        <LoadingSpinner />
      ) : filteredNotifications.length === 0 ? (
        <EmptyState message="No notifications" />
      ) : (
        <NotificationList
          notifications={filteredNotifications}
          onRead={markAsRead}
          onClear={clearNotification}
        />
      )}
    </div>
  );
}
```

### 6. Analytics and Monitoring
```typescript
// Notification Analytics
export class NotificationAnalytics {
  constructor(
    private analytics: AnalyticsService,
    private db: D1Database
  ) {}
  
  async trackNotification(
    userId: string,
    notification: PushNotification,
    result: SendResult
  ): Promise<void> {
    await this.analytics.track('notification_sent', {
      userId,
      notificationId: notification.id,
      type: notification.type,
      platform: result.platform,
      success: result.success,
      tokenCount: result.tokenCount,
      failureCount: result.failureCount
    });
    
    // Store notification history
    await this.db
      .prepare(`
        INSERT INTO notification_history 
        (id, user_id, type, title, body, data, sent_at, success)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        notification.id,
        userId,
        notification.type,
        notification.title,
        notification.body,
        JSON.stringify(notification.data),
        new Date().toISOString(),
        result.success
      )
      .run();
  }
  
  async trackInteraction(
    notificationId: string,
    action: 'clicked' | 'dismissed' | 'action',
    actionType?: string
  ): Promise<void> {
    await this.analytics.track('notification_interaction', {
      notificationId,
      action,
      actionType,
      timestamp: Date.now()
    });
    
    // Update notification history
    await this.db
      .prepare(`
        UPDATE notification_history 
        SET interaction = ?, interacted_at = ?
        WHERE id = ?
      `)
      .bind(action, new Date().toISOString(), notificationId)
      .run();
  }
  
  async getNotificationMetrics(
    timeRange: TimeRange
  ): Promise<NotificationMetrics> {
    const sent = await this.analytics.query({
      metric: 'notification_sent',
      groupBy: ['type', 'platform'],
      range: timeRange
    });
    
    const interactions = await this.analytics.query({
      metric: 'notification_interaction',
      groupBy: ['action'],
      range: timeRange
    });
    
    return {
      totalSent: sent.reduce((sum, s) => sum + s.count, 0),
      byType: groupBy(sent, 'type'),
      byPlatform: groupBy(sent, 'platform'),
      deliveryRate: this.calculateDeliveryRate(sent),
      interactionRate: this.calculateInteractionRate(sent, interactions),
      clickThroughRate: this.calculateCTR(sent, interactions)
    };
  }
}
```

## Dependencies
- Firebase Cloud Messaging SDK
- Firebase Admin SDK
- Service Worker support
- D1 for token and preference storage
- KV for caching
- Analytics service

## Estimated Effort
**5 days**
- 1 day: FCM setup and server integration
- 1 day: Token management and preferences
- 1 day: Client implementations (web, iOS, Android)
- 1 day: UI components and settings
- 1 day: Analytics and testing

## Notes
- Consider notification throttling for high-volume channels
- Implement notification grouping for better UX
- Add support for rich notifications with images
- Consider implementing notification channels for Android
- Plan for iOS provisional notifications
- Add notification sound customization options