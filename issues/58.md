# Issue #58: Cost Optimization

## User Story
As a **business owner**, I want to **optimize infrastructure costs while maintaining performance** so that **Waddle can scale efficiently without excessive operational expenses**.

## Description
Implement comprehensive cost optimization strategies across all infrastructure components. This includes resource right-sizing, intelligent caching, usage-based scaling, and efficient data storage patterns to reduce operational costs by 30-40% while maintaining or improving performance.

## Acceptance Criteria
- [ ] Reduce infrastructure costs by 30-40%
- [ ] Implement usage-based resource allocation
- [ ] Optimize data transfer and storage costs
- [ ] Add cost monitoring and alerting
- [ ] Implement intelligent caching strategies
- [ ] Right-size all compute resources
- [ ] Optimize WebRTC relay usage
- [ ] Create cost analysis dashboards

## Technical Implementation

### 1. Resource Optimization Engine
```typescript
// Cost optimization engine
export class CostOptimizationEngine {
  private analyzers: Map<string, ResourceAnalyzer> = new Map();
  private optimizer: ResourceOptimizer;
  private costTracker: CostTracker;
  
  constructor(
    private env: Env,
    private monitoring: MonitoringService,
    private analytics: AnalyticsService
  ) {
    this.optimizer = new ResourceOptimizer();
    this.costTracker = new CostTracker();
    this.initializeAnalyzers();
  }
  
  async analyzeAndOptimize(): Promise<OptimizationReport> {
    const startTime = Date.now();
    const currentCosts = await this.calculateCurrentCosts();
    
    // Analyze each resource type
    const analyses: ResourceAnalysis[] = [];
    for (const [resourceType, analyzer] of this.analyzers) {
      const analysis = await analyzer.analyze();
      analyses.push(analysis);
    }
    
    // Generate optimization recommendations
    const recommendations = await this.generateRecommendations(analyses);
    
    // Apply automatic optimizations
    const appliedOptimizations = await this.applyOptimizations(
      recommendations.filter(r => r.autoApply)
    );
    
    // Calculate projected savings
    const projectedCosts = await this.calculateProjectedCosts(recommendations);
    const savings = currentCosts.total - projectedCosts.total;
    const savingsPercentage = (savings / currentCosts.total) * 100;
    
    return {
      timestamp: Date.now(),
      duration: Date.now() - startTime,
      currentCosts,
      projectedCosts,
      savings,
      savingsPercentage,
      analyses,
      recommendations,
      appliedOptimizations
    };
  }
  
  private initializeAnalyzers() {
    this.analyzers.set('compute', new ComputeAnalyzer(this.env));
    this.analyzers.set('storage', new StorageAnalyzer(this.env));
    this.analyzers.set('network', new NetworkAnalyzer(this.env));
    this.analyzers.set('webrtc', new WebRTCAnalyzer(this.env));
    this.analyzers.set('database', new DatabaseAnalyzer(this.env));
  }
  
  private async generateRecommendations(
    analyses: ResourceAnalysis[]
  ): Promise<CostRecommendation[]> {
    const recommendations: CostRecommendation[] = [];
    
    for (const analysis of analyses) {
      // Compute optimizations
      if (analysis.type === 'compute') {
        if (analysis.utilization.cpu < 40) {
          recommendations.push({
            type: 'downsize',
            resource: 'compute',
            description: 'Downsize compute instances due to low CPU utilization',
            estimatedSavings: analysis.cost * 0.3,
            autoApply: true,
            risk: 'low'
          });
        }
        
        if (analysis.patterns.predictable) {
          recommendations.push({
            type: 'scheduled_scaling',
            resource: 'compute',
            description: 'Implement scheduled scaling based on usage patterns',
            estimatedSavings: analysis.cost * 0.25,
            autoApply: false,
            risk: 'medium'
          });
        }
      }
      
      // Storage optimizations
      if (analysis.type === 'storage') {
        if (analysis.coldDataPercentage > 60) {
          recommendations.push({
            type: 'tiered_storage',
            resource: 'storage',
            description: 'Move cold data to cheaper storage tiers',
            estimatedSavings: analysis.cost * 0.4,
            autoApply: true,
            risk: 'low'
          });
        }
        
        if (analysis.duplicateDataSize > 1024 * 1024 * 1024) { // 1GB
          recommendations.push({
            type: 'deduplication',
            resource: 'storage',
            description: 'Implement data deduplication',
            estimatedSavings: analysis.cost * 0.15,
            autoApply: false,
            risk: 'medium'
          });
        }
      }
      
      // Network optimizations
      if (analysis.type === 'network') {
        if (analysis.crossRegionTransfer > analysis.totalTransfer * 0.3) {
          recommendations.push({
            type: 'edge_caching',
            resource: 'network',
            description: 'Implement edge caching to reduce cross-region transfers',
            estimatedSavings: analysis.cost * 0.35,
            autoApply: false,
            risk: 'low'
          });
        }
      }
      
      // WebRTC optimizations
      if (analysis.type === 'webrtc') {
        if (analysis.relayUsagePercentage > 50) {
          recommendations.push({
            type: 'turn_optimization',
            resource: 'webrtc',
            description: 'Optimize TURN server usage with better STUN configuration',
            estimatedSavings: analysis.cost * 0.3,
            autoApply: true,
            risk: 'medium'
          });
        }
      }
    }
    
    return recommendations.sort((a, b) => b.estimatedSavings - a.estimatedSavings);
  }
}

// Compute resource analyzer
export class ComputeAnalyzer implements ResourceAnalyzer {
  constructor(private env: Env) {}
  
  async analyze(): Promise<ComputeAnalysis> {
    const instances = await this.getRunningInstances();
    const metrics = await this.collectMetrics(instances);
    
    // Analyze utilization patterns
    const utilizationAnalysis = this.analyzeUtilization(metrics);
    
    // Identify optimization opportunities
    const opportunities: OptimizationOpportunity[] = [];
    
    for (const instance of instances) {
      const instanceMetrics = metrics.get(instance.id);
      if (!instanceMetrics) continue;
      
      // Check for oversized instances
      if (instanceMetrics.avgCPU < 30 && instanceMetrics.avgMemory < 40) {
        opportunities.push({
          type: 'rightsize',
          instanceId: instance.id,
          currentSize: instance.type,
          recommendedSize: this.recommendInstanceSize(instanceMetrics),
          estimatedSavings: this.calculateSizingSavings(instance)
        });
      }
      
      // Check for idle instances
      if (instanceMetrics.avgCPU < 5 && instanceMetrics.connectionCount === 0) {
        opportunities.push({
          type: 'terminate',
          instanceId: instance.id,
          reason: 'Idle instance with no connections',
          estimatedSavings: instance.hourlyCost * 24 * 30
        });
      }
      
      // Check for spot instance eligibility
      if (!instance.isSpot && instance.workloadType === 'stateless') {
        opportunities.push({
          type: 'convert_to_spot',
          instanceId: instance.id,
          estimatedSavings: instance.hourlyCost * 0.7 * 24 * 30
        });
      }
    }
    
    return {
      type: 'compute',
      totalInstances: instances.length,
      totalCost: this.calculateTotalCost(instances),
      utilization: utilizationAnalysis,
      opportunities,
      patterns: await this.analyzeUsagePatterns()
    };
  }
  
  private async analyzeUsagePatterns(): Promise<UsagePattern> {
    const hourlyUsage = await this.analytics.getHourlyUsage(7); // Last 7 days
    
    // Detect patterns
    const peakHours = this.identifyPeakHours(hourlyUsage);
    const quietHours = this.identifyQuietHours(hourlyUsage);
    const weekdayPattern = this.analyzeWeekdayPattern(hourlyUsage);
    
    return {
      predictable: this.isPredictable(hourlyUsage),
      peakHours,
      quietHours,
      weekdayVariation: weekdayPattern.variation,
      seasonality: await this.detectSeasonality()
    };
  }
  
  private recommendInstanceSize(metrics: InstanceMetrics): string {
    const cpuRequired = metrics.p95CPU * 1.2; // 20% headroom
    const memoryRequired = metrics.p95Memory * 1.2;
    
    // Map to instance types
    const instanceTypes = [
      { type: 't3.micro', cpu: 10, memory: 1024, cost: 0.01 },
      { type: 't3.small', cpu: 20, memory: 2048, cost: 0.02 },
      { type: 't3.medium', cpu: 40, memory: 4096, cost: 0.04 },
      { type: 't3.large', cpu: 80, memory: 8192, cost: 0.08 },
      { type: 't3.xlarge', cpu: 160, memory: 16384, cost: 0.16 }
    ];
    
    // Find smallest instance that meets requirements
    for (const instance of instanceTypes) {
      if (instance.cpu >= cpuRequired && instance.memory >= memoryRequired) {
        return instance.type;
      }
    }
    
    return 't3.xlarge'; // Default to largest if requirements exceed
  }
}
```

### 2. Intelligent Caching System
```typescript
// Multi-tier caching system
export class IntelligentCachingSystem {
  private cacheAnalyzer: CacheAnalyzer;
  private cacheLayers: Map<string, CacheLayer> = new Map();
  private costCalculator: CacheCostCalculator;
  
  constructor(
    private env: Env,
    private analytics: AnalyticsService
  ) {
    this.cacheAnalyzer = new CacheAnalyzer();
    this.costCalculator = new CacheCostCalculator();
    this.initializeCacheLayers();
  }
  
  private initializeCacheLayers() {
    // Edge cache (Cloudflare)
    this.cacheLayers.set('edge', new EdgeCacheLayer({
      ttl: 3600, // 1 hour
      maxSize: 10 * 1024 * 1024 * 1024, // 10GB
      costPerGB: 0.02
    }));
    
    // Application cache (Redis)
    this.cacheLayers.set('app', new AppCacheLayer({
      ttl: 300, // 5 minutes
      maxSize: 5 * 1024 * 1024 * 1024, // 5GB
      costPerGB: 0.05
    }));
    
    // Database cache
    this.cacheLayers.set('db', new DatabaseCacheLayer({
      ttl: 60, // 1 minute
      maxSize: 1 * 1024 * 1024 * 1024, // 1GB
      costPerGB: 0.1
    }));
  }
  
  async optimizeCaching(): Promise<CacheOptimizationResult> {
    // Analyze current cache performance
    const analysis = await this.cacheAnalyzer.analyze();
    
    // Identify cacheable content
    const cacheableContent = await this.identifyCacheableContent();
    
    // Calculate optimal cache distribution
    const distribution = this.calculateOptimalDistribution(
      cacheableContent,
      analysis
    );
    
    // Apply caching rules
    const appliedRules = await this.applyCachingRules(distribution);
    
    // Calculate cost savings
    const savings = await this.calculateSavings(appliedRules);
    
    return {
      analysis,
      cacheableContent,
      distribution,
      appliedRules,
      savings,
      recommendations: this.generateCacheRecommendations(analysis)
    };
  }
  
  private async identifyCacheableContent(): Promise<CacheableContent[]> {
    const content: CacheableContent[] = [];
    
    // Static assets
    const staticAssets = await this.analyzeStaticAssets();
    content.push(...staticAssets.map(asset => ({
      type: 'static',
      path: asset.path,
      size: asset.size,
      accessFrequency: asset.accessCount,
      currentCost: this.calculateTransferCost(asset),
      cacheability: 'high',
      recommendedTTL: 86400 // 24 hours
    })));
    
    // API responses
    const apiEndpoints = await this.analyzeAPIEndpoints();
    for (const endpoint of apiEndpoints) {
      if (this.isIdempotent(endpoint) && !this.hasPersonalData(endpoint)) {
        content.push({
          type: 'api',
          path: endpoint.path,
          size: endpoint.avgResponseSize,
          accessFrequency: endpoint.requestsPerMinute,
          currentCost: this.calculateComputeCost(endpoint),
          cacheability: this.calculateCacheability(endpoint),
          recommendedTTL: this.recommendTTL(endpoint)
        });
      }
    }
    
    // Database queries
    const queries = await this.analyzeDatabaseQueries();
    for (const query of queries) {
      if (query.isReadOnly && query.executionTime > 100) {
        content.push({
          type: 'query',
          path: query.hash,
          size: query.avgResultSize,
          accessFrequency: query.executionsPerMinute,
          currentCost: this.calculateQueryCost(query),
          cacheability: 'medium',
          recommendedTTL: this.calculateQueryTTL(query)
        });
      }
    }
    
    return content.sort((a, b) => 
      (b.currentCost * b.cacheability) - (a.currentCost * a.cacheability)
    );
  }
  
  private calculateOptimalDistribution(
    content: CacheableContent[],
    analysis: CacheAnalysis
  ): CacheDistribution {
    const distribution = new CacheDistribution();
    
    for (const item of content) {
      // Calculate cost-benefit for each cache layer
      const layerScores = new Map<string, number>();
      
      for (const [layerName, layer] of this.cacheLayers) {
        const hitRate = this.predictHitRate(item, layer);
        const costSaving = this.calculateLayerSaving(item, layer, hitRate);
        const score = costSaving - layer.costPerGB * (item.size / 1024 / 1024 / 1024);
        layerScores.set(layerName, score);
      }
      
      // Select best layer(s)
      const sortedLayers = Array.from(layerScores.entries())
        .sort((a, b) => b[1] - a[1])
        .filter(([_, score]) => score > 0);
      
      if (sortedLayers.length > 0) {
        distribution.add(item, sortedLayers[0][0]);
        
        // Consider multi-layer caching for high-value content
        if (item.currentCost > 100 && sortedLayers.length > 1) {
          distribution.add(item, sortedLayers[1][0]);
        }
      }
    }
    
    return distribution;
  }
}

// Automatic cost-based scaling
export class CostBasedScaler {
  private costThresholds: CostThresholds;
  private scalingPolicies: Map<string, ScalingPolicy> = new Map();
  
  constructor(
    private env: Env,
    private scaler: AutoScaler,
    private costTracker: CostTracker
  ) {
    this.costThresholds = this.loadCostThresholds();
    this.initializePolicies();
  }
  
  async evaluateAndScale(): Promise<ScalingDecision[]> {
    const decisions: ScalingDecision[] = [];
    const currentCosts = await this.costTracker.getCurrentCosts();
    const projectedCosts = await this.projectCosts(1); // 1 hour ahead
    
    for (const [service, policy] of this.scalingPolicies) {
      const serviceCost = currentCosts.services[service];
      const serviceMetrics = await this.getServiceMetrics(service);
      
      // Check if scaling is needed based on cost
      if (serviceCost > policy.maxHourlyCost) {
        // Scale down if possible without impacting performance
        if (serviceMetrics.utilization < policy.minUtilization) {
          decisions.push({
            service,
            action: 'scale_down',
            reason: 'Cost exceeds threshold with low utilization',
            targetInstances: this.calculateTargetInstances(
              service,
              serviceMetrics,
              'down'
            )
          });
        }
      }
      
      // Predictive scaling based on cost trends
      if (projectedCosts.services[service] > serviceCost * 1.2) {
        // Proactive optimization
        decisions.push({
          service,
          action: 'optimize',
          reason: 'Projected cost increase',
          optimizations: await this.getOptimizations(service)
        });
      }
    }
    
    // Apply decisions
    for (const decision of decisions) {
      await this.applyScalingDecision(decision);
    }
    
    return decisions;
  }
  
  private async getOptimizations(service: string): Promise<Optimization[]> {
    const optimizations: Optimization[] = [];
    
    // Service-specific optimizations
    switch (service) {
      case 'webrtc':
        optimizations.push({
          type: 'connection_pooling',
          description: 'Enable connection pooling to reduce TURN usage',
          estimatedSaving: 0.2 // 20%
        });
        break;
        
      case 'storage':
        optimizations.push({
          type: 'compression',
          description: 'Enable automatic compression for media files',
          estimatedSaving: 0.3 // 30%
        });
        break;
        
      case 'database':
        optimizations.push({
          type: 'query_optimization',
          description: 'Optimize top 10 expensive queries',
          estimatedSaving: 0.25 // 25%
        });
        break;
    }
    
    return optimizations;
  }
}
```

### 3. Storage Optimization
```typescript
// Intelligent storage tiering
export class StorageOptimizer {
  private tiers: StorageTier[] = [
    { name: 'hot', costPerGB: 0.023, accessTime: 1 },
    { name: 'cool', costPerGB: 0.01, accessTime: 10 },
    { name: 'archive', costPerGB: 0.004, accessTime: 1000 }
  ];
  
  constructor(
    private env: Env,
    private storage: StorageService
  ) {}
  
  async optimizeStorage(): Promise<StorageOptimizationResult> {
    // Analyze access patterns
    const accessPatterns = await this.analyzeAccessPatterns();
    
    // Classify data by access frequency
    const dataClassification = await this.classifyData(accessPatterns);
    
    // Calculate optimal tier placement
    const tieringPlan = this.calculateTieringPlan(dataClassification);
    
    // Execute data movement
    const movements = await this.executeTiering(tieringPlan);
    
    // Implement lifecycle policies
    const policies = await this.createLifecyclePolicies(dataClassification);
    
    return {
      currentCost: await this.calculateCurrentStorageCost(),
      optimizedCost: await this.calculateOptimizedCost(tieringPlan),
      savings: this.calculateSavings(tieringPlan),
      movements,
      policies
    };
  }
  
  private async analyzeAccessPatterns(): Promise<AccessPatternAnalysis> {
    const objects = await this.storage.listAllObjects();
    const patterns: Map<string, AccessPattern> = new Map();
    
    for (const object of objects) {
      const accessLog = await this.storage.getAccessLog(object.key);
      
      patterns.set(object.key, {
        lastAccess: accessLog.lastAccess,
        accessCount: accessLog.count,
        accessFrequency: this.calculateFrequency(accessLog),
        size: object.size,
        age: Date.now() - object.created,
        type: this.detectContentType(object)
      });
    }
    
    return {
      totalObjects: objects.length,
      totalSize: objects.reduce((sum, obj) => sum + obj.size, 0),
      patterns,
      summary: this.summarizePatterns(patterns)
    };
  }
  
  private calculateTieringPlan(
    classification: DataClassification
  ): TieringPlan {
    const plan = new TieringPlan();
    
    // Hot data stays in hot tier
    for (const item of classification.hot) {
      plan.keep(item, 'hot');
    }
    
    // Warm data moves to cool tier after 30 days
    for (const item of classification.warm) {
      if (item.age > 30 * 24 * 60 * 60 * 1000) {
        plan.move(item, 'hot', 'cool');
      }
    }
    
    // Cold data moves to archive after 90 days
    for (const item of classification.cold) {
      if (item.age > 90 * 24 * 60 * 60 * 1000) {
        plan.move(item, 'cool', 'archive');
      }
    }
    
    // Calculate cost impact
    plan.calculateCostImpact(this.tiers);
    
    return plan;
  }
  
  // Implement smart compression
  async implementCompression(): Promise<CompressionResult> {
    const compressibleTypes = ['text', 'json', 'log', 'csv'];
    const mediaTypes = ['image', 'video', 'audio'];
    
    const results: CompressionResult = {
      originalSize: 0,
      compressedSize: 0,
      savings: 0,
      compressionRatio: 0
    };
    
    // Text compression
    const textFiles = await this.storage.findByTypes(compressibleTypes);
    for (const file of textFiles) {
      const compressed = await this.compressText(file);
      results.originalSize += file.size;
      results.compressedSize += compressed.size;
    }
    
    // Media optimization
    const mediaFiles = await this.storage.findByTypes(mediaTypes);
    for (const file of mediaFiles) {
      const optimized = await this.optimizeMedia(file);
      results.originalSize += file.size;
      results.compressedSize += optimized.size;
    }
    
    results.savings = results.originalSize - results.compressedSize;
    results.compressionRatio = results.compressedSize / results.originalSize;
    
    return results;
  }
}
```

### 4. WebRTC Cost Optimization
```typescript
// WebRTC relay optimization
export class WebRTCCostOptimizer {
  private relayAnalyzer: RelayUsageAnalyzer;
  private turnOptimizer: TURNOptimizer;
  
  constructor(
    private env: Env,
    private rtc: WebRTCService
  ) {
    this.relayAnalyzer = new RelayUsageAnalyzer();
    this.turnOptimizer = new TURNOptimizer();
  }
  
  async optimizeRelayUsage(): Promise<RelayOptimizationResult> {
    // Analyze current relay usage
    const usage = await this.relayAnalyzer.analyze();
    
    // Optimize STUN/TURN configuration
    const turnConfig = await this.optimizeTURNConfiguration(usage);
    
    // Implement intelligent relay selection
    const relayStrategy = this.createRelayStrategy(usage);
    
    // Enable P2P optimization
    const p2pOptimization = await this.enableP2POptimization();
    
    // Calculate savings
    const currentCost = usage.totalRelayCost;
    const optimizedCost = await this.calculateOptimizedCost(
      turnConfig,
      relayStrategy,
      p2pOptimization
    );
    
    return {
      currentUsage: usage,
      optimizations: {
        turnConfig,
        relayStrategy,
        p2pOptimization
      },
      currentCost,
      optimizedCost,
      savings: currentCost - optimizedCost,
      savingsPercentage: ((currentCost - optimizedCost) / currentCost) * 100
    };
  }
  
  private async optimizeTURNConfiguration(
    usage: RelayUsageAnalysis
  ): Promise<TURNConfiguration> {
    // Analyze connection success rates
    const successRates = await this.analyzeConnectionSuccess();
    
    // Optimize TURN server locations
    const optimalLocations = this.selectOptimalTURNLocations(
      usage.connectionsByRegion
    );
    
    // Configure aggressive ICE gathering
    const iceConfig: RTCConfiguration = {
      iceServers: [
        // Prioritize STUN for P2P
        { urls: 'stun:stun.waddle.chat:3478' },
        // Regional TURN servers as fallback
        ...optimalLocations.map(loc => ({
          urls: `turn:${loc.region}.turn.waddle.chat:3478`,
          username: 'dynamic',
          credential: 'dynamic',
          credentialType: 'password' as RTCIceCredentialType
        }))
      ],
      iceTransportPolicy: 'all',
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    };
    
    return {
      iceConfig,
      turnAllocation: {
        strategy: 'on-demand',
        timeout: 30000, // 30 seconds
        maxBandwidth: 1000000 // 1 Mbps default
      },
      relayPolicy: {
        preferP2P: true,
        fallbackDelay: 5000, // 5 seconds
        bandwidthAdaptive: true
      }
    };
  }
  
  private createRelayStrategy(usage: RelayUsageAnalysis): RelayStrategy {
    return {
      // Intelligent relay selection
      selectRelay: async (connection: RTCConnection) => {
        // Check if P2P is likely to succeed
        const p2pLikelihood = await this.predictP2PSuccess(connection);
        
        if (p2pLikelihood > 0.8) {
          // Delay relay allocation
          return {
            action: 'delay',
            delayMs: 5000,
            reason: 'High P2P success probability'
          };
        }
        
        // Select optimal relay based on location and load
        const optimalRelay = await this.selectOptimalRelay(
          connection.participants
        );
        
        return {
          action: 'allocate',
          relay: optimalRelay,
          bandwidth: this.calculateOptimalBandwidth(connection)
        };
      },
      
      // Dynamic bandwidth allocation
      adjustBandwidth: async (session: RelaySession) => {
        const quality = await this.measureConnectionQuality(session);
        
        if (quality.packetLoss < 0.01 && quality.jitter < 30) {
          // Reduce bandwidth allocation for stable connections
          return {
            action: 'reduce',
            newBandwidth: session.bandwidth * 0.8
          };
        }
        
        return { action: 'maintain' };
      }
    };
  }
}
```

### 5. Cost Monitoring Dashboard
```typescript
// Real-time cost monitoring
export class CostMonitoringDashboard {
  private costMetrics: Map<string, CostMetric> = new Map();
  private alerts: CostAlertManager;
  
  constructor(
    private env: Env,
    private billing: BillingService
  ) {
    this.alerts = new CostAlertManager();
    this.initializeMetrics();
  }
  
  async generateDashboard(): Promise<CostDashboard> {
    const timeRange = { start: Date.now() - 24 * 60 * 60 * 1000, end: Date.now() };
    
    return {
      summary: await this.generateSummary(timeRange),
      breakdown: await this.generateCostBreakdown(),
      trends: await this.analyzeTrends(),
      projections: await this.generateProjections(),
      alerts: await this.getActiveAlerts(),
      recommendations: await this.getRecommendations()
    };
  }
  
  private async generateSummary(timeRange: TimeRange): Promise<CostSummary> {
    const costs = await this.billing.getCosts(timeRange);
    
    return {
      total: costs.total,
      byService: {
        compute: costs.compute,
        storage: costs.storage,
        network: costs.network,
        webrtc: costs.webrtc,
        database: costs.database
      },
      change: {
        daily: this.calculateChange(costs, 'daily'),
        weekly: this.calculateChange(costs, 'weekly'),
        monthly: this.calculateChange(costs, 'monthly')
      },
      runRate: {
        hourly: costs.total / 24,
        daily: costs.total,
        monthly: costs.total * 30,
        yearly: costs.total * 365
      }
    };
  }
  
  private async generateCostBreakdown(): Promise<CostBreakdown> {
    const breakdown = new Map<string, ServiceCost>();
    
    // Compute breakdown
    const computeCosts = await this.analyzeComputeCosts();
    breakdown.set('compute', {
      total: computeCosts.total,
      components: [
        { name: 'Workers', cost: computeCosts.workers, percentage: computeCosts.workers / computeCosts.total * 100 },
        { name: 'Durable Objects', cost: computeCosts.durableObjects, percentage: computeCosts.durableObjects / computeCosts.total * 100 },
        { name: 'Pages', cost: computeCosts.pages, percentage: computeCosts.pages / computeCosts.total * 100 }
      ]
    });
    
    // Storage breakdown
    const storageCosts = await this.analyzeStorageCosts();
    breakdown.set('storage', {
      total: storageCosts.total,
      components: [
        { name: 'R2', cost: storageCosts.r2, percentage: storageCosts.r2 / storageCosts.total * 100 },
        { name: 'D1', cost: storageCosts.d1, percentage: storageCosts.d1 / storageCosts.total * 100 },
        { name: 'KV', cost: storageCosts.kv, percentage: storageCosts.kv / storageCosts.total * 100 }
      ]
    });
    
    return breakdown;
  }
}

// Cost alert manager
export class CostAlertManager {
  private thresholds: Map<string, CostThreshold> = new Map();
  
  constructor() {
    this.initializeThresholds();
  }
  
  private initializeThresholds() {
    // Service-level thresholds
    this.thresholds.set('compute_hourly', {
      warning: 10,
      critical: 20,
      action: 'scale_down'
    });
    
    this.thresholds.set('storage_daily', {
      warning: 50,
      critical: 100,
      action: 'tier_optimization'
    });
    
    this.thresholds.set('network_daily', {
      warning: 100,
      critical: 200,
      action: 'enable_caching'
    });
    
    // Total cost thresholds
    this.thresholds.set('total_daily', {
      warning: 500,
      critical: 1000,
      action: 'emergency_optimization'
    });
  }
  
  async checkThresholds(costs: CurrentCosts): Promise<CostAlert[]> {
    const alerts: CostAlert[] = [];
    
    for (const [metric, threshold] of this.thresholds) {
      const value = this.getMetricValue(costs, metric);
      
      if (value > threshold.critical) {
        alerts.push({
          severity: 'critical',
          metric,
          value,
          threshold: threshold.critical,
          message: `${metric} cost exceeded critical threshold`,
          recommendedAction: threshold.action
        });
      } else if (value > threshold.warning) {
        alerts.push({
          severity: 'warning',
          metric,
          value,
          threshold: threshold.warning,
          message: `${metric} cost exceeded warning threshold`,
          recommendedAction: threshold.action
        });
      }
    }
    
    return alerts;
  }
}

// Cost optimization UI
export function CostOptimizationDashboard() {
  const [dashboard, setDashboard] = useState<CostDashboard>();
  const [selectedTimeRange, setSelectedTimeRange] = useState('24h');
  const [activeTab, setActiveTab] = useState('overview');
  
  useEffect(() => {
    loadDashboard();
    const interval = setInterval(loadDashboard, 60000); // Update every minute
    return () => clearInterval(interval);
  }, [selectedTimeRange]);
  
  const loadDashboard = async () => {
    const data = await api.getCostDashboard(selectedTimeRange);
    setDashboard(data);
  };
  
  if (!dashboard) return <LoadingSpinner />;
  
  return (
    <div className="cost-dashboard">
      <div className="dashboard-header">
        <h1>Cost Optimization</h1>
        <TimeRangeSelector
          value={selectedTimeRange}
          onChange={setSelectedTimeRange}
        />
      </div>
      
      {dashboard.alerts.length > 0 && (
        <div className="cost-alerts">
          {dashboard.alerts.map(alert => (
            <Alert
              key={alert.metric}
              severity={alert.severity}
              action={
                <Button
                  size="small"
                  onClick={() => executeAction(alert.recommendedAction)}
                >
                  {alert.recommendedAction.replace('_', ' ')}
                </Button>
              }
            >
              {alert.message}
            </Alert>
          ))}
        </div>
      )}
      
      <div className="cost-summary">
        <MetricCard
          title="Current Run Rate"
          value={`$${dashboard.summary.runRate.daily.toFixed(2)}`}
          subtitle="per day"
          trend={dashboard.summary.change.daily}
        />
        
        <MetricCard
          title="Monthly Projection"
          value={`$${dashboard.summary.runRate.monthly.toFixed(2)}`}
          subtitle="estimated"
          trend={dashboard.summary.change.monthly}
        />
        
        <MetricCard
          title="Potential Savings"
          value={`$${dashboard.recommendations.totalSavings.toFixed(2)}`}
          subtitle="per month"
          highlight={true}
        />
      </div>
      
      <Tabs value={activeTab} onChange={setActiveTab}>
        <Tab value="overview">Overview</Tab>
        <Tab value="breakdown">Cost Breakdown</Tab>
        <Tab value="trends">Trends</Tab>
        <Tab value="optimization">Optimization</Tab>
      </Tabs>
      
      <div className="dashboard-content">
        {activeTab === 'overview' && (
          <CostOverview summary={dashboard.summary} />
        )}
        
        {activeTab === 'breakdown' && (
          <CostBreakdownView breakdown={dashboard.breakdown} />
        )}
        
        {activeTab === 'trends' && (
          <CostTrendsView trends={dashboard.trends} />
        )}
        
        {activeTab === 'optimization' && (
          <OptimizationView recommendations={dashboard.recommendations} />
        )}
      </div>
    </div>
  );
}
```

## Dependencies
- Cloudflare Analytics API
- Cost tracking infrastructure
- Resource monitoring tools
- Automated optimization scripts
- Billing APIs

## Estimated Effort
**4 days**
- 1 day: Cost analysis infrastructure
- 1 day: Resource optimization engine
- 1 day: Caching and storage optimization
- 1 day: Monitoring dashboard and alerts

## Notes
- Start with non-critical optimizations
- Monitor performance impact closely
- Implement gradual rollout
- Set up cost anomaly detection
- Regular review of optimization rules