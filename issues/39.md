# Issue #39: Voice Analytics

## User Story
As a **waddle owner or moderator**, I want to **view detailed voice channel usage analytics** so that **I can understand member engagement, optimize channel configuration, and identify usage patterns**.

## Description
Implement comprehensive voice analytics for Waddle, providing insights into voice channel usage, member participation, call quality metrics, and engagement patterns. The system should track real-time and historical data, generate reports, and provide actionable insights through interactive dashboards.

## Acceptance Criteria
- [ ] Real-time voice metrics collection
- [ ] Historical data aggregation
- [ ] Member participation tracking
- [ ] Call quality monitoring
- [ ] Usage pattern analysis
- [ ] Interactive analytics dashboard
- [ ] Exportable reports
- [ ] Privacy-compliant data handling

## Technical Implementation

### 1. Analytics Data Collection
```typescript
// Voice analytics event types
export interface VoiceAnalyticsEvent {
  type: 'session_start' | 'session_end' | 'quality_sample' | 
        'participant_join' | 'participant_leave' | 'speaking_time' |
        'network_issue' | 'device_change' | 'feature_used';
  timestamp: number;
  sessionId: string;
  channelId: string;
  waddleId: string;
  userId?: string;
  data: Record<string, any>;
}

export class VoiceAnalyticsCollector {
  private eventQueue: VoiceAnalyticsEvent[] = [];
  private batchTimer: NodeJS.Timeout | null = null;
  private metricsCollectors = new Map<string, MetricsCollector>();
  
  constructor(
    private storage: AnalyticsStorage,
    private privacy: PrivacyManager,
    private config: AnalyticsConfig
  ) {
    this.startBatchProcessing();
  }
  
  async trackSessionStart(session: VoiceSession) {
    const event: VoiceAnalyticsEvent = {
      type: 'session_start',
      timestamp: Date.now(),
      sessionId: session.id,
      channelId: session.channelId,
      waddleId: session.waddleId,
      userId: session.userId,
      data: {
        device: await this.getDeviceInfo(),
        location: await this.privacy.getAnonymizedLocation(session.userId),
        joinMethod: session.joinMethod,
        initialQuality: session.initialQuality
      }
    };
    
    await this.queueEvent(event);
    
    // Start metrics collection for this session
    const collector = new MetricsCollector(session);
    this.metricsCollectors.set(session.id, collector);
    collector.start();
  }
  
  async trackSessionEnd(session: VoiceSession, reason: string) {
    const collector = this.metricsCollectors.get(session.id);
    if (collector) {
      collector.stop();
      const metrics = await collector.getMetrics();
      
      const event: VoiceAnalyticsEvent = {
        type: 'session_end',
        timestamp: Date.now(),
        sessionId: session.id,
        channelId: session.channelId,
        waddleId: session.waddleId,
        userId: session.userId,
        data: {
          duration: Date.now() - session.startTime,
          reason,
          metrics: {
            avgBitrate: metrics.avgBitrate,
            avgPacketLoss: metrics.avgPacketLoss,
            avgJitter: metrics.avgJitter,
            avgRtt: metrics.avgRtt,
            speakingTime: metrics.speakingTime,
            listeningTime: metrics.listeningTime,
            mutedTime: metrics.mutedTime,
            videoTime: metrics.videoTime,
            screenShareTime: metrics.screenShareTime
          },
          qualityScore: this.calculateQualityScore(metrics),
          issues: metrics.issues
        }
      };
      
      await this.queueEvent(event);
      this.metricsCollectors.delete(session.id);
    }
  }
  
  async trackQualitySample(
    sessionId: string,
    stats: RTCStatsReport
  ) {
    const processed = await this.processRTCStats(stats);
    
    const event: VoiceAnalyticsEvent = {
      type: 'quality_sample',
      timestamp: Date.now(),
      sessionId,
      channelId: processed.channelId,
      waddleId: processed.waddleId,
      data: {
        audio: {
          bitrate: processed.audio.bitrate,
          packetLoss: processed.audio.packetLoss,
          jitter: processed.audio.jitter,
          level: processed.audio.level,
          codec: processed.audio.codec
        },
        video: processed.video ? {
          bitrate: processed.video.bitrate,
          packetLoss: processed.video.packetLoss,
          frameRate: processed.video.frameRate,
          resolution: processed.video.resolution,
          codec: processed.video.codec
        } : null,
        network: {
          rtt: processed.network.rtt,
          availableBandwidth: processed.network.availableBandwidth,
          connectionType: processed.network.connectionType
        }
      }
    };
    
    // Only queue if significant change or interval elapsed
    if (this.shouldTrackQualitySample(sessionId, processed)) {
      await this.queueEvent(event);
    }
  }
  
  async trackSpeakingTime(
    sessionId: string,
    userId: string,
    duration: number
  ) {
    const event: VoiceAnalyticsEvent = {
      type: 'speaking_time',
      timestamp: Date.now(),
      sessionId,
      channelId: this.getChannelId(sessionId),
      waddleId: this.getWaddleId(sessionId),
      userId,
      data: {
        duration,
        energy: await this.getAverageAudioEnergy(sessionId, userId)
      }
    };
    
    await this.queueEvent(event);
  }
  
  async trackFeatureUsage(
    sessionId: string,
    feature: string,
    details?: any
  ) {
    const event: VoiceAnalyticsEvent = {
      type: 'feature_used',
      timestamp: Date.now(),
      sessionId,
      channelId: this.getChannelId(sessionId),
      waddleId: this.getWaddleId(sessionId),
      data: {
        feature,
        details: this.privacy.sanitizeData(details)
      }
    };
    
    await this.queueEvent(event);
  }
  
  private async queueEvent(event: VoiceAnalyticsEvent) {
    // Apply privacy filters
    const filtered = await this.privacy.filterEvent(event);
    if (!filtered) return;
    
    this.eventQueue.push(filtered);
    
    // Batch processing
    if (this.eventQueue.length >= this.config.batchSize) {
      await this.processBatch();
    }
  }
  
  private startBatchProcessing() {
    this.batchTimer = setInterval(async () => {
      if (this.eventQueue.length > 0) {
        await this.processBatch();
      }
    }, this.config.batchInterval);
  }
  
  private async processBatch() {
    const events = this.eventQueue.splice(0, this.config.batchSize);
    if (events.length === 0) return;
    
    try {
      await this.storage.storeEvents(events);
      
      // Real-time aggregation
      await this.updateRealTimeMetrics(events);
      
    } catch (error) {
      console.error('Failed to process analytics batch:', error);
      // Re-queue events for retry
      this.eventQueue.unshift(...events);
    }
  }
  
  private calculateQualityScore(metrics: SessionMetrics): number {
    let score = 100;
    
    // Deduct points for quality issues
    score -= Math.min(metrics.avgPacketLoss * 10, 30); // Max -30 for packet loss
    score -= Math.min(metrics.avgJitter / 10, 20); // Max -20 for jitter
    score -= Math.min(metrics.avgRtt / 100, 20); // Max -20 for RTT
    score -= metrics.issues.length * 5; // -5 per issue
    
    // Bonus for consistent quality
    if (metrics.qualityVariance < 0.1) {
      score += 10;
    }
    
    return Math.max(0, Math.min(100, score));
  }
}
```

### 2. Real-time Analytics Processing
```typescript
// Real-time analytics aggregator
export class RealTimeAnalyticsProcessor {
  private activeMetrics = new Map<string, ChannelMetrics>();
  private aggregationWindows = new Map<string, AggregationWindow>();
  
  constructor(
    private storage: AnalyticsStorage,
    private pubsub: PubSubService
  ) {
    this.startAggregation();
  }
  
  async processEvents(events: VoiceAnalyticsEvent[]) {
    for (const event of events) {
      await this.processEvent(event);
    }
    
    // Update real-time dashboards
    await this.broadcastUpdates();
  }
  
  private async processEvent(event: VoiceAnalyticsEvent) {
    const channelKey = `${event.waddleId}:${event.channelId}`;
    
    let metrics = this.activeMetrics.get(channelKey);
    if (!metrics) {
      metrics = await this.initializeChannelMetrics(
        event.waddleId,
        event.channelId
      );
      this.activeMetrics.set(channelKey, metrics);
    }
    
    switch (event.type) {
      case 'session_start':
        metrics.activeSessions++;
        metrics.totalSessions++;
        if (event.userId) {
          metrics.uniqueUsers.add(event.userId);
        }
        break;
        
      case 'session_end':
        metrics.activeSessions--;
        metrics.totalDuration += event.data.duration;
        metrics.qualityScores.push(event.data.qualityScore);
        this.updateQualityDistribution(metrics, event.data.qualityScore);
        break;
        
      case 'quality_sample':
        this.updateQualityMetrics(metrics, event.data);
        break;
        
      case 'speaking_time':
        metrics.totalSpeakingTime += event.data.duration;
        if (event.userId) {
          const userMetrics = metrics.userMetrics.get(event.userId) || {
            speakingTime: 0,
            listeningTime: 0,
            sessions: 0
          };
          userMetrics.speakingTime += event.data.duration;
          metrics.userMetrics.set(event.userId, userMetrics);
        }
        break;
        
      case 'feature_used':
        const count = metrics.featureUsage.get(event.data.feature) || 0;
        metrics.featureUsage.set(event.data.feature, count + 1);
        break;
    }
    
    metrics.lastUpdated = Date.now();
  }
  
  private updateQualityMetrics(
    metrics: ChannelMetrics,
    data: any
  ) {
    // Update moving averages
    metrics.currentQuality.bitrate = this.updateMovingAverage(
      metrics.currentQuality.bitrate,
      data.audio.bitrate
    );
    
    metrics.currentQuality.packetLoss = this.updateMovingAverage(
      metrics.currentQuality.packetLoss,
      data.audio.packetLoss
    );
    
    metrics.currentQuality.jitter = this.updateMovingAverage(
      metrics.currentQuality.jitter,
      data.audio.jitter
    );
    
    metrics.currentQuality.rtt = this.updateMovingAverage(
      metrics.currentQuality.rtt,
      data.network.rtt
    );
    
    // Track quality issues
    if (data.audio.packetLoss > 5) {
      metrics.qualityIssues.highPacketLoss++;
    }
    if (data.network.rtt > 150) {
      metrics.qualityIssues.highLatency++;
    }
    if (data.audio.jitter > 30) {
      metrics.qualityIssues.highJitter++;
    }
  }
  
  private updateMovingAverage(
    current: number,
    sample: number,
    weight: number = 0.1
  ): number {
    return current * (1 - weight) + sample * weight;
  }
  
  async getChannelAnalytics(
    waddleId: string,
    channelId: string
  ): Promise<ChannelAnalytics> {
    const key = `${waddleId}:${channelId}`;
    const metrics = this.activeMetrics.get(key);
    
    if (!metrics) {
      return this.getHistoricalAnalytics(waddleId, channelId);
    }
    
    return {
      channel: {
        id: channelId,
        waddleId,
        name: metrics.channelName
      },
      realTime: {
        activeSessions: metrics.activeSessions,
        activeUsers: metrics.uniqueUsers.size,
        currentQuality: metrics.currentQuality
      },
      today: {
        totalSessions: metrics.totalSessions,
        uniqueUsers: metrics.uniqueUsers.size,
        totalDuration: metrics.totalDuration,
        avgSessionDuration: metrics.totalDuration / Math.max(1, metrics.totalSessions),
        avgQualityScore: this.calculateAverage(metrics.qualityScores),
        peakConcurrentUsers: metrics.peakConcurrentUsers,
        featureUsage: Object.fromEntries(metrics.featureUsage)
      },
      trends: await this.calculateTrends(waddleId, channelId),
      userEngagement: this.calculateUserEngagement(metrics)
    };
  }
  
  private calculateUserEngagement(
    metrics: ChannelMetrics
  ): UserEngagement {
    const userStats = Array.from(metrics.userMetrics.entries())
      .map(([userId, stats]) => ({
        userId,
        speakingTime: stats.speakingTime,
        listeningTime: stats.listeningTime,
        participationRate: stats.speakingTime / (stats.speakingTime + stats.listeningTime),
        sessions: stats.sessions
      }))
      .sort((a, b) => b.speakingTime - a.speakingTime);
    
    const totalSpeakingTime = userStats.reduce((sum, s) => sum + s.speakingTime, 0);
    
    return {
      topSpeakers: userStats.slice(0, 10),
      participationDistribution: this.calculateParticipationDistribution(userStats),
      avgParticipationRate: userStats.reduce((sum, s) => sum + s.participationRate, 0) / userStats.length,
      speakingTimeDistribution: userStats.map(s => ({
        userId: s.userId,
        percentage: (s.speakingTime / totalSpeakingTime) * 100
      }))
    };
  }
  
  private async broadcastUpdates() {
    for (const [key, metrics] of this.activeMetrics) {
      const [waddleId, channelId] = key.split(':');
      
      await this.pubsub.publish(`analytics:${waddleId}:${channelId}`, {
        type: 'metrics_update',
        data: {
          activeSessions: metrics.activeSessions,
          activeUsers: metrics.uniqueUsers.size,
          currentQuality: metrics.currentQuality,
          recentIssues: this.getRecentIssues(metrics)
        }
      });
    }
  }
}
```

### 3. Analytics Dashboard Components
```tsx
export function VoiceAnalyticsDashboard({ 
  waddleId 
}: { 
  waddleId: string 
}) {
  const [timeRange, setTimeRange] = useState<TimeRange>('today');
  const [selectedChannel, setSelectedChannel] = useState<string | null>(null);
  const [analytics, setAnalytics] = useState<WaddleAnalytics>();
  const [realTimeData, setRealTimeData] = useState<RealTimeMetrics>();
  
  useEffect(() => {
    loadAnalytics();
    const subscription = subscribeToRealTimeUpdates();
    
    return () => {
      subscription.unsubscribe();
    };
  }, [waddleId, timeRange, selectedChannel]);
  
  const loadAnalytics = async () => {
    const data = await api.getVoiceAnalytics({
      waddleId,
      timeRange,
      channelId: selectedChannel
    });
    setAnalytics(data);
  };
  
  const subscribeToRealTimeUpdates = () => {
    return api.subscribeToAnalytics(waddleId, selectedChannel)
      .subscribe(update => {
        setRealTimeData(update);
      });
  };
  
  if (!analytics) return <LoadingSpinner />;
  
  return (
    <div className="voice-analytics-dashboard">
      <div className="dashboard-header">
        <h2>Voice Analytics</h2>
        
        <div className="header-controls">
          <ChannelSelector
            waddleId={waddleId}
            value={selectedChannel}
            onChange={setSelectedChannel}
            includeAll={true}
          />
          
          <TimeRangeSelector
            value={timeRange}
            onChange={setTimeRange}
            options={['today', '7days', '30days', 'custom']}
          />
          
          <Button
            variant="secondary"
            leftIcon={<DownloadIcon />}
            onClick={() => exportAnalytics()}
          >
            Export
          </Button>
        </div>
      </div>
      
      <div className="analytics-grid">
        <RealTimeMetricsCard data={realTimeData} />
        
        <MetricCard
          title="Total Sessions"
          value={analytics.summary.totalSessions}
          change={analytics.summary.sessionsChange}
          icon={<PhoneIcon />}
        />
        
        <MetricCard
          title="Unique Users"
          value={analytics.summary.uniqueUsers}
          change={analytics.summary.usersChange}
          icon={<UsersIcon />}
        />
        
        <MetricCard
          title="Avg Duration"
          value={formatDuration(analytics.summary.avgDuration)}
          change={analytics.summary.durationChange}
          icon={<ClockIcon />}
        />
        
        <MetricCard
          title="Quality Score"
          value={`${analytics.summary.avgQualityScore}/100`}
          change={analytics.summary.qualityChange}
          icon={<SignalIcon />}
          color={getQualityColor(analytics.summary.avgQualityScore)}
        />
      </div>
      
      <div className="analytics-charts">
        <UsageChart
          data={analytics.usage}
          timeRange={timeRange}
        />
        
        <QualityChart
          data={analytics.quality}
          timeRange={timeRange}
        />
        
        <ParticipationChart
          data={analytics.participation}
        />
        
        <FeatureUsageChart
          data={analytics.featureUsage}
        />
      </div>
      
      <div className="analytics-tables">
        <TopUsersTable
          users={analytics.topUsers}
          timeRange={timeRange}
        />
        
        <QualityIssuesTable
          issues={analytics.qualityIssues}
          onIssueClick={(issue) => showIssueDetails(issue)}
        />
      </div>
    </div>
  );
}

export function RealTimeMetricsCard({ 
  data 
}: { 
  data?: RealTimeMetrics 
}) {
  if (!data) {
    return (
      <div className="realtime-metrics-card loading">
        <h3>Real-Time Activity</h3>
        <p>Waiting for data...</p>
      </div>
    );
  }
  
  return (
    <div className="realtime-metrics-card">
      <h3>Real-Time Activity</h3>
      
      <div className="realtime-grid">
        <div className="realtime-metric">
          <div className="metric-value">{data.activeSessions}</div>
          <div className="metric-label">Active Calls</div>
        </div>
        
        <div className="realtime-metric">
          <div className="metric-value">{data.activeUsers}</div>
          <div className="metric-label">Connected Users</div>
        </div>
        
        <div className="realtime-metric">
          <div className="metric-value">
            <QualityIndicator score={data.currentQuality.score} />
          </div>
          <div className="metric-label">Call Quality</div>
        </div>
        
        <div className="realtime-metric">
          <div className="metric-value">{formatBitrate(data.totalBandwidth)}</div>
          <div className="metric-label">Bandwidth</div>
        </div>
      </div>
      
      <LiveActivityFeed activities={data.recentActivities} />
    </div>
  );
}

export function UsageChart({ 
  data, 
  timeRange 
}: { 
  data: UsageData[];
  timeRange: TimeRange;
}) {
  const chartConfig = {
    xAxis: {
      dataKey: 'time',
      tickFormatter: (time: number) => formatTimeForRange(time, timeRange)
    },
    yAxis: [
      { dataKey: 'sessions', name: 'Sessions', color: '#3b82f6' },
      { dataKey: 'users', name: 'Users', color: '#10b981' }
    ],
    tooltip: {
      formatter: (value: number, name: string) => [value, name]
    }
  };
  
  return (
    <div className="usage-chart">
      <h3>Usage Over Time</h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis {...chartConfig.xAxis} />
          <YAxis />
          <Tooltip {...chartConfig.tooltip} />
          <Legend />
          
          {chartConfig.yAxis.map(axis => (
            <Line
              key={axis.dataKey}
              type="monotone"
              dataKey={axis.dataKey}
              stroke={axis.color}
              name={axis.name}
              strokeWidth={2}
            />
          ))}
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}

export function QualityChart({ 
  data, 
  timeRange 
}: { 
  data: QualityData[];
  timeRange: TimeRange;
}) {
  return (
    <div className="quality-chart">
      <h3>Call Quality Metrics</h3>
      
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis 
            dataKey="time"
            tickFormatter={(time) => formatTimeForRange(time, timeRange)}
          />
          <YAxis />
          <Tooltip />
          <Legend />
          
          <Area
            type="monotone"
            dataKey="excellentCalls"
            stackId="1"
            stroke="#10b981"
            fill="#10b981"
            name="Excellent"
          />
          <Area
            type="monotone"
            dataKey="goodCalls"
            stackId="1"
            stroke="#3b82f6"
            fill="#3b82f6"
            name="Good"
          />
          <Area
            type="monotone"
            dataKey="fairCalls"
            stackId="1"
            stroke="#f59e0b"
            fill="#f59e0b"
            name="Fair"
          />
          <Area
            type="monotone"
            dataKey="poorCalls"
            stackId="1"
            stroke="#ef4444"
            fill="#ef4444"
            name="Poor"
          />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}
```

### 4. Analytics Aggregation Engine
```typescript
// Historical data aggregation
export class AnalyticsAggregationEngine {
  private aggregationJobs = new Map<string, AggregationJob>();
  
  constructor(
    private storage: AnalyticsStorage,
    private compute: ComputeService
  ) {
    this.scheduleAggregations();
  }
  
  private scheduleAggregations() {
    // Hourly aggregations
    cron.schedule('0 * * * *', () => {
      this.runAggregation('hourly');
    });
    
    // Daily aggregations
    cron.schedule('0 0 * * *', () => {
      this.runAggregation('daily');
    });
    
    // Weekly aggregations
    cron.schedule('0 0 * * 0', () => {
      this.runAggregation('weekly');
    });
    
    // Monthly aggregations
    cron.schedule('0 0 1 * *', () => {
      this.runAggregation('monthly');
    });
  }
  
  async runAggregation(period: AggregationPeriod) {
    console.log(`Running ${period} aggregation`);
    
    const waddles = await this.storage.getActiveWaddles();
    
    for (const waddleId of waddles) {
      const job: AggregationJob = {
        id: crypto.randomUUID(),
        waddleId,
        period,
        startTime: Date.now(),
        status: 'running'
      };
      
      this.aggregationJobs.set(job.id, job);
      
      try {
        await this.aggregateWaddleData(waddleId, period);
        job.status = 'completed';
      } catch (error) {
        console.error(`Aggregation failed for waddle ${waddleId}:`, error);
        job.status = 'failed';
        job.error = error.message;
      }
      
      job.endTime = Date.now();
    }
  }
  
  private async aggregateWaddleData(
    waddleId: string,
    period: AggregationPeriod
  ) {
    const timeRange = this.getTimeRange(period);
    const events = await this.storage.getEvents({
      waddleId,
      startTime: timeRange.start,
      endTime: timeRange.end
    });
    
    // Parallel processing for different metrics
    const [
      usageMetrics,
      qualityMetrics,
      participationMetrics,
      featureMetrics
    ] = await Promise.all([
      this.compute.calculateUsageMetrics(events),
      this.compute.calculateQualityMetrics(events),
      this.compute.calculateParticipationMetrics(events),
      this.compute.calculateFeatureMetrics(events)
    ]);
    
    // Store aggregated data
    const aggregation: AggregatedAnalytics = {
      waddleId,
      period,
      timeRange,
      metrics: {
        usage: usageMetrics,
        quality: qualityMetrics,
        participation: participationMetrics,
        features: featureMetrics
      },
      summary: this.generateSummary(
        usageMetrics,
        qualityMetrics,
        participationMetrics
      )
    };
    
    await this.storage.storeAggregation(aggregation);
    
    // Update caches
    await this.updateCaches(waddleId, aggregation);
    
    // Generate insights
    const insights = await this.generateInsights(aggregation);
    if (insights.length > 0) {
      await this.storage.storeInsights(waddleId, insights);
    }
  }
  
  private async generateInsights(
    aggregation: AggregatedAnalytics
  ): Promise<AnalyticsInsight[]> {
    const insights: AnalyticsInsight[] = [];
    
    // Usage pattern insights
    if (aggregation.metrics.usage.peakHour) {
      insights.push({
        type: 'usage_pattern',
        title: 'Peak Usage Time',
        description: `Most voice calls occur at ${formatHour(aggregation.metrics.usage.peakHour)}`,
        severity: 'info',
        data: {
          peakHour: aggregation.metrics.usage.peakHour,
          avgUsersAtPeak: aggregation.metrics.usage.avgUsersAtPeak
        }
      });
    }
    
    // Quality insights
    if (aggregation.metrics.quality.avgScore < 70) {
      insights.push({
        type: 'quality_issue',
        title: 'Low Call Quality',
        description: 'Average call quality is below acceptable levels',
        severity: 'warning',
        data: {
          avgScore: aggregation.metrics.quality.avgScore,
          mainIssues: aggregation.metrics.quality.topIssues
        },
        recommendations: [
          'Check network infrastructure',
          'Review concurrent user limits',
          'Consider upgrading server capacity'
        ]
      });
    }
    
    // Participation insights
    const participationRate = aggregation.metrics.participation.avgParticipationRate;
    if (participationRate < 0.2) {
      insights.push({
        type: 'engagement',
        title: 'Low Member Participation',
        description: 'Most members are passive listeners',
        severity: 'info',
        data: {
          participationRate,
          activeSpeakers: aggregation.metrics.participation.activeSpeakers
        },
        recommendations: [
          'Encourage more interactive discussions',
          'Consider smaller group sessions',
          'Implement speaking queue features'
        ]
      });
    }
    
    // Feature adoption insights
    const unusedFeatures = aggregation.metrics.features.available
      .filter(f => !aggregation.metrics.features.used.includes(f));
      
    if (unusedFeatures.length > 0) {
      insights.push({
        type: 'feature_adoption',
        title: 'Unused Voice Features',
        description: 'Some voice features are not being utilized',
        severity: 'info',
        data: {
          unusedFeatures,
          mostUsedFeatures: aggregation.metrics.features.topUsed
        },
        recommendations: [
          'Provide feature tutorials',
          'Highlight features in UI',
          'Send feature announcement'
        ]
      });
    }
    
    return insights;
  }
}
```

### 5. Privacy and Compliance
```typescript
// Privacy-compliant analytics
export class AnalyticsPrivacyManager {
  private anonymizationRules: AnonymizationRule[] = [];
  private retentionPolicies: RetentionPolicy[] = [];
  
  constructor(
    private config: PrivacyConfig,
    private crypto: CryptoService
  ) {
    this.loadPrivacyRules();
  }
  
  async filterEvent(
    event: VoiceAnalyticsEvent
  ): Promise<VoiceAnalyticsEvent | null> {
    // Check if analytics are enabled for this user
    if (event.userId) {
      const consent = await this.checkUserConsent(event.userId);
      if (!consent.analytics) {
        return null;
      }
    }
    
    // Apply anonymization
    const anonymized = await this.anonymizeEvent(event);
    
    // Remove sensitive data
    const sanitized = this.sanitizeEvent(anonymized);
    
    return sanitized;
  }
  
  private async anonymizeEvent(
    event: VoiceAnalyticsEvent
  ): Promise<VoiceAnalyticsEvent> {
    const anonymized = { ...event };
    
    // Anonymize user ID
    if (event.userId && this.config.anonymizeUsers) {
      anonymized.userId = await this.hashUserId(event.userId);
    }
    
    // Anonymize location data
    if (event.data.location) {
      anonymized.data.location = this.anonymizeLocation(event.data.location);
    }
    
    // Remove IP addresses
    delete anonymized.data.ipAddress;
    delete anonymized.data.deviceId;
    
    return anonymized;
  }
  
  private anonymizeLocation(location: Location): Location {
    // Reduce precision to city level
    return {
      country: location.country,
      region: location.region,
      city: location.city
      // Remove street-level data
    };
  }
  
  private sanitizeEvent(
    event: VoiceAnalyticsEvent
  ): VoiceAnalyticsEvent {
    const sanitized = { ...event };
    
    // Remove any PII from data fields
    if (sanitized.data) {
      sanitized.data = this.removePII(sanitized.data);
    }
    
    return sanitized;
  }
  
  private removePII(data: any): any {
    const piiPatterns = [
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, // Email
      /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, // Phone
      /\b\d{3}-\d{2}-\d{4}\b/g, // SSN
      /\b(?:\d{4}[-\s]?){3}\d{4}\b/g // Credit card
    ];
    
    let serialized = JSON.stringify(data);
    
    for (const pattern of piiPatterns) {
      serialized = serialized.replace(pattern, '[REDACTED]');
    }
    
    return JSON.parse(serialized);
  }
  
  async applyRetentionPolicies() {
    for (const policy of this.retentionPolicies) {
      const cutoffDate = Date.now() - policy.retentionDays * 24 * 60 * 60 * 1000;
      
      await this.storage.deleteEvents({
        type: policy.eventType,
        before: cutoffDate
      });
    }
  }
  
  async exportUserData(userId: string): Promise<UserAnalyticsExport> {
    const hashedId = await this.hashUserId(userId);
    
    const events = await this.storage.getEvents({
      userId: hashedId
    });
    
    return {
      userId,
      exportDate: new Date().toISOString(),
      data: {
        events: events.map(e => this.sanitizeForExport(e)),
        aggregations: await this.getUserAggregations(hashedId),
        insights: await this.getUserInsights(hashedId)
      }
    };
  }
  
  async deleteUserData(userId: string): Promise<void> {
    const hashedId = await this.hashUserId(userId);
    
    // Delete all events
    await this.storage.deleteEvents({ userId: hashedId });
    
    // Delete aggregations
    await this.storage.deleteAggregations({ userId: hashedId });
    
    // Delete insights
    await this.storage.deleteInsights({ userId: hashedId });
    
    // Log deletion for compliance
    await this.logDeletion(userId);
  }
}
```

### 6. Export and Reporting
```typescript
// Analytics export functionality
export class AnalyticsExporter {
  constructor(
    private storage: AnalyticsStorage,
    private formatter: DataFormatter
  ) {}
  
  async exportAnalytics(
    params: ExportParams
  ): Promise<ExportResult> {
    // Validate permissions
    await this.validateExportPermissions(params.requesterId, params.waddleId);
    
    // Gather data
    const data = await this.gatherExportData(params);
    
    // Format data
    const formatted = await this.formatData(data, params.format);
    
    // Generate file
    const file = await this.generateFile(formatted, params);
    
    // Track export
    await this.trackExport(params, file);
    
    return {
      fileUrl: file.url,
      fileName: file.name,
      format: params.format,
      size: file.size,
      expiresAt: file.expiresAt
    };
  }
  
  private async gatherExportData(
    params: ExportParams
  ): Promise<ExportData> {
    const [events, aggregations, insights] = await Promise.all([
      this.storage.getEvents({
        waddleId: params.waddleId,
        channelId: params.channelId,
        startTime: params.timeRange.start,
        endTime: params.timeRange.end
      }),
      this.storage.getAggregations({
        waddleId: params.waddleId,
        channelId: params.channelId,
        period: params.aggregationPeriod
      }),
      this.storage.getInsights({
        waddleId: params.waddleId,
        channelId: params.channelId
      })
    ]);
    
    return {
      metadata: {
        waddleId: params.waddleId,
        channelId: params.channelId,
        timeRange: params.timeRange,
        exportDate: new Date().toISOString(),
        recordCount: events.length
      },
      events: params.includeRawData ? events : undefined,
      summary: this.generateSummary(events, aggregations),
      aggregations,
      insights,
      charts: params.includeCharts ? 
        await this.generateCharts(events, aggregations) : undefined
    };
  }
  
  private async formatData(
    data: ExportData,
    format: ExportFormat
  ): Promise<FormattedData> {
    switch (format) {
      case 'csv':
        return this.formatter.toCSV(data);
      case 'json':
        return this.formatter.toJSON(data);
      case 'pdf':
        return this.formatter.toPDF(data);
      case 'excel':
        return this.formatter.toExcel(data);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  
  private async generateCharts(
    events: VoiceAnalyticsEvent[],
    aggregations: AggregatedAnalytics[]
  ): Promise<ChartData[]> {
    return [
      {
        type: 'line',
        title: 'Usage Over Time',
        data: this.generateUsageChartData(events)
      },
      {
        type: 'bar',
        title: 'Quality Distribution',
        data: this.generateQualityChartData(aggregations)
      },
      {
        type: 'pie',
        title: 'Feature Usage',
        data: this.generateFeatureChartData(events)
      },
      {
        type: 'heatmap',
        title: 'Activity Heatmap',
        data: this.generateActivityHeatmap(events)
      }
    ];
  }
}
```

## Dependencies
- Analytics storage (time-series database)
- Real-time processing engine
- Data visualization libraries
- Privacy compliance framework
- Export generation service

## Estimated Effort
**6 days**
- 1 day: Data collection infrastructure
- 1 day: Real-time processing
- 1 day: Analytics dashboard UI
- 1 day: Aggregation engine
- 1 day: Privacy and compliance
- 1 day: Export and reporting

## Notes
- Ensure GDPR/privacy compliance
- Implement data retention policies
- Consider analytics performance impact
- Add anomaly detection
- Support custom metrics
- Enable alerting on thresholds
- Plan for data archival strategy