# RFC-001: Channel-less Conversation Model

**Status:** Proposed

**Author:** System

**Created:** 2025-09-30

## Abstract

This RFC proposes a channel-less conversation model for Waddle that replaces traditional fixed channels with flexible, AI-powered conversation grouping. Messages are organized by conversations (topics/threads) rather than predetermined channels, with AI and human hints driving the grouping.

## Motivation

Traditional chat platforms (Discord, Slack) organize messages into fixed channels. This has limitations:

- **Channel proliferation**: Communities create dozens of channels, overwhelming users
- **Cross-channel discussions**: Topics span multiple channels, fragmenting conversations
- **Onboarding complexity**: New users must learn channel structure
- **Context switching**: Users miss conversations in inactive channels

Waddle aims to solve this by organizing messages into conversations dynamically, allowing users to filter and group messages according to their needs.

## Design

### Core Concepts

#### 1. Messages
The atomic unit. Every message is:
- Posted to a Waddle (not a channel)
- Optionally includes human hashtags for grouping hints
- Analyzed by AI for automatic tagging
- Linked to zero or more conversations

#### 2. Conversations
Logical groupings of related messages:
- Created automatically by AI or manually by users
- Have tags, participants, and time ranges
- Can overlap (one message in multiple conversations)
- Evolve over time as new messages arrive

#### 3. Tags
Metadata for messages and conversations:
- Extracted from human hashtags (e.g., #help, #sg1)
- Generated by AI analysis
- Used for filtering and searching
- Have confidence scores (AI-generated only)

#### 4. Views
User-defined lenses on the message stream:
- Filter by tags, users, time, content
- Group by conversation, time, or user
- Saved per-user for quick switching
- Shared views created by admins

### Data Model

```typescript
interface Message {
  id: string;
  waddleId: string;
  userId: string;
  content: string;
  rawContent: string;        // Before hashtag removal
  threadId?: string;         // Optional reply threading
  createdAt: Date;
  editedAt?: Date;
  deletedAt?: Date;
  attachments: Attachment[];
}

interface MessageTag {
  messageId: string;
  tag: string;
  source: 'human' | 'ai';
  confidence?: number;       // 0-1 for AI tags
  createdAt: Date;
}

interface Conversation {
  id: string;
  waddleId: string;
  title?: string;            // Auto-generated or user-set
  tags: string[];
  startedAt: Date;
  lastMessageAt: Date;
  messageCount: number;
  participantIds: string[];
  metadata: {
    createdBy?: 'ai' | 'user';
    confidence?: number;
  };
}

interface ConversationMessage {
  conversationId: string;
  messageId: string;
  relevanceScore: number;    // How relevant is this message?
  addedAt: Date;
  addedBy: 'ai' | 'user';
}
```

### Database Schema

```sql
-- Messages table (per-Waddle D1)
CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  content TEXT NOT NULL,
  raw_content TEXT NOT NULL,
  thread_id TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  edited_at DATETIME,
  deleted_at DATETIME,

  INDEX idx_time (created_at DESC),
  INDEX idx_user (user_id, created_at DESC),
  INDEX idx_thread (thread_id, created_at)
);

-- Tags extracted from messages
CREATE TABLE message_tags (
  message_id TEXT NOT NULL,
  tag TEXT NOT NULL,
  source TEXT NOT NULL,      -- 'human' or 'ai'
  confidence REAL,           -- 0.0 - 1.0 for AI tags
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY (message_id, tag),
  INDEX idx_tag (tag),
  INDEX idx_source (source)
);

-- Conversations (dynamically created)
CREATE TABLE conversations (
  id TEXT PRIMARY KEY,
  title TEXT,
  started_at DATETIME NOT NULL,
  last_message_at DATETIME NOT NULL,
  message_count INTEGER DEFAULT 0,
  metadata JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_last_message (last_message_at DESC)
);

-- Conversation tags (many-to-many)
CREATE TABLE conversation_tags (
  conversation_id TEXT NOT NULL,
  tag TEXT NOT NULL,

  PRIMARY KEY (conversation_id, tag),
  INDEX idx_tag (tag)
);

-- Messages in conversations (many-to-many)
CREATE TABLE conversation_messages (
  conversation_id TEXT NOT NULL,
  message_id TEXT NOT NULL,
  relevance_score REAL DEFAULT 1.0,
  added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  added_by TEXT NOT NULL,   -- 'ai' or 'user'

  PRIMARY KEY (conversation_id, message_id),
  INDEX idx_conversation (conversation_id, added_at DESC),
  INDEX idx_message (message_id)
);

-- Conversation participants (denormalized for quick lookup)
CREATE TABLE conversation_participants (
  conversation_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  message_count INTEGER DEFAULT 0,

  PRIMARY KEY (conversation_id, user_id),
  INDEX idx_user (user_id)
);
```

### Message Flow

#### 1. User Posts Message

```typescript
async function createMessage(
  waddleId: string,
  userId: string,
  rawContent: string,
  env: Env
): Promise<Message> {
  // Extract hashtags
  const { content, hashtags } = extractHashtags(rawContent);

  // Store message
  const messageId = crypto.randomUUID();
  const waddleDb = await getWaddleDb(waddleId, env);

  await waddleDb.prepare(`
    INSERT INTO messages (id, user_id, content, raw_content, created_at)
    VALUES (?, ?, ?, ?, ?)
  `).bind(
    messageId,
    userId,
    content,
    rawContent,
    new Date().toISOString()
  ).run();

  // Store human hashtags as tags
  for (const tag of hashtags) {
    await waddleDb.prepare(`
      INSERT INTO message_tags (message_id, tag, source)
      VALUES (?, ?, 'human')
    `).bind(messageId, tag).run();
  }

  // Publish event for AI analysis
  await publishEvent(env.EVENT_BUS, {
    id: crypto.randomUUID(),
    type: 'message.created',
    waddleId,
    userId,
    timestamp: new Date().toISOString(),
    data: {
      messageId,
      content,
      hashtags,
    },
  });

  // Broadcast to real-time clients
  const doId = env.WADDLE_DO.idFromName(waddleId);
  const stub = env.WADDLE_DO.get(doId);
  await stub.fetch(new Request('https://do/broadcast', {
    method: 'POST',
    body: JSON.stringify({ type: 'message', messageId, content }),
  }));

  return {
    id: messageId,
    waddleId,
    userId,
    content,
    rawContent,
    createdAt: new Date(),
    attachments: [],
  };
}

function extractHashtags(content: string): { content: string; hashtags: string[] } {
  const hashtagRegex = /#([a-zA-Z0-9_]+)/g;
  const hashtags: string[] = [];
  let match;

  while ((match = hashtagRegex.exec(content)) !== null) {
    hashtags.push(match[1].toLowerCase());
  }

  // Remove hashtags from display content
  const cleanContent = content.replace(hashtagRegex, '').trim();

  return { content: cleanContent, hashtags };
}
```

#### 2. AI Analyzes Message

```typescript
// ai-worker/message-analyzer.ts
async function analyzeMessage(event: MessageCreatedEvent, env: Env) {
  const { messageId, content, hashtags } = event.data;

  // Run AI tagging
  const aiTags = await generateTags(content, env);

  // Store AI tags
  const waddleDb = await getWaddleDb(event.waddleId, env);
  for (const tag of aiTags) {
    await waddleDb.prepare(`
      INSERT INTO message_tags (message_id, tag, source, confidence)
      VALUES (?, ?, 'ai', ?)
    `).bind(messageId, tag.name, tag.confidence).run();
  }

  // Find or create conversation
  const allTags = [...hashtags, ...aiTags.map(t => t.name)];
  const conversation = await findOrCreateConversation(
    messageId,
    allTags,
    event.waddleId,
    env
  );

  // Link message to conversation
  await waddleDb.prepare(`
    INSERT INTO conversation_messages (conversation_id, message_id, added_by, relevance_score)
    VALUES (?, ?, 'ai', ?)
  `).bind(conversation.id, messageId, aiTags[0]?.confidence || 1.0).run();
}

async function generateTags(content: string, env: Env): Promise<Array<{ name: string; confidence: number }>> {
  // Call AI API (Cloudflare AI, OpenAI, etc.)
  const response = await env.AI.run('@cf/meta/llama-3-8b-instruct', {
    prompt: `Extract 3-5 topic tags from this message. Return JSON array of {name, confidence}.

Message: ${content}`,
  });

  return response.tags;
}
```

#### 3. Conversation Grouping

```typescript
async function findOrCreateConversation(
  messageId: string,
  tags: string[],
  waddleId: string,
  env: Env
): Promise<Conversation> {
  const waddleDb = await getWaddleDb(waddleId, env);

  // Look for recent conversations with overlapping tags
  const candidates = await waddleDb.prepare(`
    SELECT c.id, c.title, COUNT(ct.tag) as matching_tags
    FROM conversations c
    JOIN conversation_tags ct ON ct.conversation_id = c.id
    WHERE ct.tag IN (${tags.map(() => '?').join(',')})
      AND c.last_message_at > datetime('now', '-24 hours')
    GROUP BY c.id
    HAVING matching_tags >= 2
    ORDER BY matching_tags DESC, c.last_message_at DESC
    LIMIT 1
  `).bind(...tags).first();

  if (candidates) {
    // Add message to existing conversation
    await waddleDb.prepare(`
      UPDATE conversations
      SET last_message_at = ?, message_count = message_count + 1
      WHERE id = ?
    `).bind(new Date().toISOString(), candidates.id).run();

    return candidates as Conversation;
  }

  // Create new conversation
  const conversationId = crypto.randomUUID();
  const title = generateConversationTitle(tags);

  await waddleDb.prepare(`
    INSERT INTO conversations (id, title, started_at, last_message_at, message_count)
    VALUES (?, ?, ?, ?, 1)
  `).bind(
    conversationId,
    title,
    new Date().toISOString(),
    new Date().toISOString()
  ).run();

  // Add tags to conversation
  for (const tag of tags) {
    await waddleDb.prepare(`
      INSERT INTO conversation_tags (conversation_id, tag)
      VALUES (?, ?)
    `).bind(conversationId, tag).run();
  }

  return {
    id: conversationId,
    waddleId,
    title,
    tags,
    startedAt: new Date(),
    lastMessageAt: new Date(),
    messageCount: 1,
    participantIds: [],
    metadata: { createdBy: 'ai' },
  };
}

function generateConversationTitle(tags: string[]): string {
  // Use primary tags to create readable title
  return tags.slice(0, 3).map(capitalize).join(' â€¢ ');
}
```

### Querying Messages

#### All Messages (Traditional View)

```typescript
async function getAllMessages(waddleId: string, limit: number, env: Env) {
  const waddleDb = await getWaddleDb(waddleId, env);

  return await waddleDb.prepare(`
    SELECT * FROM messages
    WHERE deleted_at IS NULL
    ORDER BY created_at DESC
    LIMIT ?
  `).bind(limit).all();
}
```

#### Filtered by View

```typescript
async function getMessagesByView(
  waddleId: string,
  view: View,
  env: Env
): Promise<Message[]> {
  const waddleDb = await getWaddleDb(waddleId, env);

  // Build dynamic SQL based on filters
  let sql = 'SELECT DISTINCT m.* FROM messages m';
  const params: any[] = [];

  // Join with tags if filtering by tag
  const tagFilters = view.filters.filter(f => f.type === 'tag');
  if (tagFilters.length > 0) {
    sql += ' JOIN message_tags mt ON mt.message_id = m.id';
  }

  sql += ' WHERE m.deleted_at IS NULL';

  // Apply tag filters
  if (tagFilters.length > 0) {
    const tagFilter = tagFilters[0];
    sql += ` AND mt.tag IN (${tagFilter.value.map(() => '?').join(',')})`;
    params.push(...tagFilter.value);
  }

  // Apply user filters
  const userFilters = view.filters.filter(f => f.type === 'user');
  if (userFilters.length > 0) {
    const userFilter = userFilters[0];
    if (userFilter.operator === 'equals') {
      sql += ' AND m.user_id = ?';
      params.push(userFilter.value);
    }
  }

  // Apply sort order
  sql += ` ORDER BY m.created_at ${view.sortOrder === 'oldest' ? 'ASC' : 'DESC'}`;

  return await waddleDb.prepare(sql).bind(...params).all();
}
```

#### Grouped by Conversation

```typescript
async function getConversations(waddleId: string, env: Env) {
  const waddleDb = await getWaddleDb(waddleId, env);

  // Get recent active conversations
  const conversations = await waddleDb.prepare(`
    SELECT c.*, GROUP_CONCAT(ct.tag) as tags
    FROM conversations c
    LEFT JOIN conversation_tags ct ON ct.conversation_id = c.id
    GROUP BY c.id
    ORDER BY c.last_message_at DESC
    LIMIT 50
  `).all();

  // Get messages for each conversation
  for (const conv of conversations.results) {
    const messages = await waddleDb.prepare(`
      SELECT m.*
      FROM messages m
      JOIN conversation_messages cm ON cm.message_id = m.id
      WHERE cm.conversation_id = ?
      ORDER BY m.created_at DESC
      LIMIT 20
    `).bind(conv.id).all();

    conv.messages = messages.results;
  }

  return conversations.results;
}
```

## Trade-offs

### Benefits

- **Reduced cognitive load**: No channel management
- **Flexible organization**: Users see what they want
- **Better discovery**: AI surfaces relevant conversations
- **Adaptive**: Conversations evolve with community
- **Cross-topic**: Messages can belong to multiple conversations

### Drawbacks

- **AI dependency**: Requires ML for good experience
- **Complexity**: More complex than fixed channels
- **Performance**: More database queries for filtering
- **Learning curve**: Users must understand views
- **Potential chaos**: Without channels, organization is less explicit

## Migration Path

### Phase 1: Hybrid Model (Weeks 1-4)
- Support both channels and conversations
- Channels are just pre-defined views
- Users can opt into channel-less mode

### Phase 2: Conversation-First (Weeks 5-8)
- Conversations become primary UI
- Channels available as "classic mode"
- AI grouping improves with feedback

### Phase 3: Full Channel-less (Weeks 9+)
- Remove channel concept entirely
- All messages in conversation streams
- Views are primary organizational tool

## Open Questions

1. **How do we handle voice channels?** Voice is inherently synchronous and needs fixed "rooms"
2. **What about announcements?** Should announcements bypass conversation grouping?
3. **How do users discover conversations?** Need smart defaults and suggestions
4. **What if AI makes mistakes?** Users must be able to manually re-group messages

## References

- [Zulip Topics Model](https://zulip.com/why-zulip/)
- [Discourse Category-less Tags](https://meta.discourse.org/t/beginners-guide-to-using-discourse-tags/90274)
- [Linear Triage and Grouping](https://linear.app/)